defmodule GameAssistant.Tutorializing.BookConents do

# example json:
# "{
#   \"projects\": {
#     \"space smup\": {
#       \"ch1\": {
#         \"scripts/file1\": \"line1;\\nline2;\\nline3;\\nline4;\"
#       },
#       \"ch2\": {
#         \"scripts/file2\": \"brine1;\\nbrine2;\\nbrine3;\\nbrine4;\"
#       }
#     }
#   }
# }"

  def rawContents() do
# PYSTART
   "{\"projects\": {\"Dungeon Delver\": {\"01 - Understanding the Dungeon Data\": {\"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y); \\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum]; \\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n    void Awake()\\n    {\\n        LoadMap();\\n    }\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}, \"02 - Adding the Hero\": {\"__Scripts/Dray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Dray : MonoBehaviour\\n{\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float speed = 5;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int dirHeld = -1; // Direction of the held movement key\\n\\n    private Rigidbody   rigid;\\n    private Animator    anim;                                            // a\\n\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };             // a\\n\\n    private KeyCode[] keys = new KeyCode[] { KeyCode.RightArrow,\\n        KeyCode.UpArrow, KeyCode.LeftArrow, KeyCode.DownArrow };             // a\\n\\n\\n    void Awake()\\n    {\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();                                     // a\\n    }\\n\\n    void Update()\\n    {\\n        dirHeld = -1;\\n        // Delete the four \\\"if ( Input.GetKey...\\\" lines that were here\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (Input.GetKey(keys[i])) dirHeld = i;                        // b\\n        }\\n\\n        Vector3 vel = Vector3.zero;\\n        // Delete the entire switch clause that used to be here\\n        if (dirHeld > -1) vel = directions[dirHeld];                         // b\\n\\n\\n        rigid.velocity = vel * speed;\\n\\n        // Animation\\n        if (dirHeld == -1)\\n        {                                                 // b\\n            anim.speed = 0;\\n        }\\n        else\\n        {\\n            anim.CrossFade(\\\"Dray_Walk_\\\" + dirHeld, 0);                       // c\\n            anim.speed = 1;\\n        }\\n    }\\n}\\n\", \"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y); \\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum]; \\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n    void Awake()\\n    {\\n        LoadMap();\\n    }\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}, \"03 - Giving Dray an Attack Animation\": {\"__Scripts/Dray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Dray : MonoBehaviour\\n{\\n    public enum eMode { idle, move, attack, transition }                     // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float speed = 5;\\n    public float attackDuration = 0.25f;// Number of seconds to attack\\n    public float attackDelay = 0.5f;    // Delay between attacks \\n\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int dirHeld = -1; // Direction of the held movement key\\n    public int facing = 1;   // Direction Dray is facing \\n    public eMode mode = eMode.idle;                                // a\\n\\n    private float timeAtkDone = 0;                                  // b\\n    private float timeAtkNext = 0;                                  // c\\n\\n\\n    private Rigidbody   rigid;\\n    private Animator    anim;                                            // a\\n\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };             // a\\n\\n    private KeyCode[] keys = new KeyCode[] { KeyCode.RightArrow,\\n        KeyCode.UpArrow, KeyCode.LeftArrow, KeyCode.DownArrow };             // a\\n\\n\\n    void Awake()\\n    {\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();                                     // a\\n    }\\n\\n    void Update()\\n    {\\n        //Handle Keyboard Input and manage eDrayModes\\n        dirHeld = -1;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (Input.GetKey(keys[i])) dirHeld = i;\\n        }\\n\\n        // Pressing the attack button(s)\\n        if (Input.GetKeyDown(KeyCode.Z) && Time.time >= timeAtkNext)\\n        {       // a\\n            mode = eMode.attack;\\n            timeAtkDone = Time.time + attackDuration;\\n            timeAtkNext = Time.time + attackDelay;\\n        }\\n\\n        // Finishing the attack when it\'s over\\n        if (Time.time >= timeAtkDone)\\n        {                                      // b\\n            mode = eMode.idle;\\n        }\\n\\n        // Choosing the proper mode if we\'re not attacking\\n        if (mode != eMode.attack)\\n        {                                          // c\\n            if (dirHeld == -1)\\n            {\\n                mode = eMode.idle;\\n            }\\n            else\\n            {\\n                facing = dirHeld;                                            // d\\n                mode = eMode.move;\\n            }\\n        }\\n\\n        //Act on the current mode\\n        Vector3 vel = Vector3.zero;\\n        switch (mode)\\n        {                                                      // e\\n            case eMode.attack:\\n                anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.idle:\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.move:\\n                vel = directions[dirHeld];\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 1;\\n                break;\\n        }\\n\\n        rigid.velocity = vel * speed;\\n\\n    }\\n}\\n\", \"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y); \\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum]; \\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n    void Awake()\\n    {\\n        LoadMap();\\n    }\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}, \"04 - Dray\'s Sword\": {\"__Scripts/Dray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Dray : MonoBehaviour\\n{\\n    public enum eMode { idle, move, attack, transition }                     // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float speed = 5;\\n    public float attackDuration = 0.25f;// Number of seconds to attack\\n    public float attackDelay = 0.5f;    // Delay between attacks \\n\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int dirHeld = -1; // Direction of the held movement key\\n    public int facing = 1;   // Direction Dray is facing \\n    public eMode mode = eMode.idle;                                // a\\n\\n    private float timeAtkDone = 0;                                  // b\\n    private float timeAtkNext = 0;                                  // c\\n\\n\\n    private Rigidbody   rigid;\\n    private Animator    anim;                                            // a\\n\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };             // a\\n\\n    private KeyCode[] keys = new KeyCode[] { KeyCode.RightArrow,\\n        KeyCode.UpArrow, KeyCode.LeftArrow, KeyCode.DownArrow };             // a\\n\\n\\n    void Awake()\\n    {\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();                                     // a\\n    }\\n\\n    void Update()\\n    {\\n        //Handle Keyboard Input and manage eDrayModes\\n        dirHeld = -1;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (Input.GetKey(keys[i])) dirHeld = i;\\n        }\\n\\n        // Pressing the attack button(s)\\n        if (Input.GetKeyDown(KeyCode.Z) && Time.time >= timeAtkNext)\\n        {       // a\\n            mode = eMode.attack;\\n            timeAtkDone = Time.time + attackDuration;\\n            timeAtkNext = Time.time + attackDelay;\\n        }\\n\\n        // Finishing the attack when it\'s over\\n        if (Time.time >= timeAtkDone)\\n        {                                      // b\\n            mode = eMode.idle;\\n        }\\n\\n        // Choosing the proper mode if we\'re not attacking\\n        if (mode != eMode.attack)\\n        {                                          // c\\n            if (dirHeld == -1)\\n            {\\n                mode = eMode.idle;\\n            }\\n            else\\n            {\\n                facing = dirHeld;                                            // d\\n                mode = eMode.move;\\n            }\\n        }\\n\\n        //Act on the current mode\\n        Vector3 vel = Vector3.zero;\\n        switch (mode)\\n        {                                                      // e\\n            case eMode.attack:\\n                anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.idle:\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.move:\\n                vel = directions[dirHeld];\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 1;\\n                break;\\n        }\\n\\n        rigid.velocity = vel * speed;\\n\\n    }\\n}\\n\", \"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/SwordController.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class SwordController : MonoBehaviour\\n{\\n    private GameObject sword;\\n    private Dray dray;\\n\\n    void Start()\\n    {\\n        sword = transform.Find(\\\"Sword\\\").gameObject;                          // a\\n        dray = transform.parent.GetComponent<Dray>();\\n        // Deactivate the sword\\n        sword.SetActive(false);                                              // b\\n    }\\n\\n    void Update()\\n    {\\n        transform.rotation = Quaternion.Euler(0, 0, 90 * dray.facing);       // c\\n        sword.SetActive(dray.mode == Dray.eMode.attack);                     // d\\n    }\\n}\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y); \\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum]; \\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n    void Awake()\\n    {\\n        LoadMap();\\n    }\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}, \"05 - Enemy Skeletos\": {\"__Scripts/Dray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Dray : MonoBehaviour\\n{\\n    public enum eMode { idle, move, attack, transition }                     // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float speed = 5;\\n    public float attackDuration = 0.25f;// Number of seconds to attack\\n    public float attackDelay = 0.5f;    // Delay between attacks \\n\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int dirHeld = -1; // Direction of the held movement key\\n    public int facing = 1;   // Direction Dray is facing \\n    public eMode mode = eMode.idle;                                // a\\n\\n    private float timeAtkDone = 0;                                  // b\\n    private float timeAtkNext = 0;                                  // c\\n\\n\\n    private Rigidbody   rigid;\\n    private Animator    anim;                                            // a\\n\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };             // a\\n\\n    private KeyCode[] keys = new KeyCode[] { KeyCode.RightArrow,\\n        KeyCode.UpArrow, KeyCode.LeftArrow, KeyCode.DownArrow };             // a\\n\\n\\n    void Awake()\\n    {\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();                                     // a\\n    }\\n\\n    void Update()\\n    {\\n        //Handle Keyboard Input and manage eDrayModes\\n        dirHeld = -1;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (Input.GetKey(keys[i])) dirHeld = i;\\n        }\\n\\n        // Pressing the attack button(s)\\n        if (Input.GetKeyDown(KeyCode.Z) && Time.time >= timeAtkNext)\\n        {       // a\\n            mode = eMode.attack;\\n            timeAtkDone = Time.time + attackDuration;\\n            timeAtkNext = Time.time + attackDelay;\\n        }\\n\\n        // Finishing the attack when it\'s over\\n        if (Time.time >= timeAtkDone)\\n        {                                      // b\\n            mode = eMode.idle;\\n        }\\n\\n        // Choosing the proper mode if we\'re not attacking\\n        if (mode != eMode.attack)\\n        {                                          // c\\n            if (dirHeld == -1)\\n            {\\n                mode = eMode.idle;\\n            }\\n            else\\n            {\\n                facing = dirHeld;                                            // d\\n                mode = eMode.move;\\n            }\\n        }\\n\\n        //Act on the current mode\\n        Vector3 vel = Vector3.zero;\\n        switch (mode)\\n        {                                                      // e\\n            case eMode.attack:\\n                anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.idle:\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.move:\\n                vel = directions[dirHeld];\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 1;\\n                break;\\n        }\\n\\n        rigid.velocity = vel * speed;\\n\\n    }\\n}\\n\", \"__Scripts/Enemy.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Enemy : MonoBehaviour\\n{\\n    protected static Vector3[] directions = new Vector3[] {                 // a\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };\\n\\n    [Header(\\\"Set in Inspector: Enemy\\\")]                                      // b\\n    public float maxHealth = 1;                               // c\\n\\n    [Header(\\\"Set Dynamically: Enemy\\\")]\\n    public float health;                                      // c\\n\\n    protected Animator anim;                                        // c\\n    protected Rigidbody rigid;                                       // c\\n    protected SpriteRenderer sRend;                                       // c\\n\\n    protected virtual void Awake()\\n    {                                         // d\\n        health = maxHealth;\\n        anim = GetComponent<Animator>();\\n        rigid = GetComponent<Rigidbody>();\\n        sRend = GetComponent<SpriteRenderer>();\\n    }\\n}\\n\", \"__Scripts/Skeletos.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Skeletos : Enemy\\n{                                              // a\\n    [Header(\\\"Set in Inspector: Skeletos\\\")]                                   // b\\n    public int speed = 2;\\n    public float timeThinkMin = 1f;\\n    public float timeThinkMax = 4f;\\n\\n    [Header(\\\"Set Dynamically: Skeletos\\\")]\\n    public int facing = 0;\\n    public float timeNextDecision = 0;\\n\\n    void Update()\\n    {\\n        if (Time.time >= timeNextDecision)\\n        {                                 // c\\n            DecideDirection();\\n        }\\n        // rigid is inherited from Enemy and is initialized in Enemy.Awake()\\n        rigid.velocity = directions[facing] * speed;\\n    }\\n\\n    void DecideDirection()\\n    {                                                 // d\\n        facing = Random.Range(0, 4);\\n        timeNextDecision = Time.time + Random.Range(timeThinkMin, timeThinkMax);\\n    }\\n}\\n\", \"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/SwordController.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class SwordController : MonoBehaviour\\n{\\n    private GameObject sword;\\n    private Dray dray;\\n\\n    void Start()\\n    {\\n        sword = transform.Find(\\\"Sword\\\").gameObject;                          // a\\n        dray = transform.parent.GetComponent<Dray>();\\n        // Deactivate the sword\\n        sword.SetActive(false);                                              // b\\n    }\\n\\n    void Update()\\n    {\\n        transform.rotation = Quaternion.Euler(0, 0, 90 * dray.facing);       // c\\n        sword.SetActive(dray.mode == Dray.eMode.attack);                     // d\\n    }\\n}\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y); \\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum]; \\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n    void Awake()\\n    {\\n        LoadMap();\\n    }\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}, \"06 - The InRoom Script\": {\"__Scripts/Dray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Dray : MonoBehaviour\\n{\\n    public enum eMode { idle, move, attack, transition }                     // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float speed = 5;\\n    public float attackDuration = 0.25f;// Number of seconds to attack\\n    public float attackDelay = 0.5f;    // Delay between attacks \\n\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int dirHeld = -1; // Direction of the held movement key\\n    public int facing = 1;   // Direction Dray is facing \\n    public eMode mode = eMode.idle;                                // a\\n\\n    private float timeAtkDone = 0;                                  // b\\n    private float timeAtkNext = 0;                                  // c\\n\\n\\n    private Rigidbody   rigid;\\n    private Animator    anim;                                            // a\\n\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };             // a\\n\\n    private KeyCode[] keys = new KeyCode[] { KeyCode.RightArrow,\\n        KeyCode.UpArrow, KeyCode.LeftArrow, KeyCode.DownArrow };             // a\\n\\n\\n    void Awake()\\n    {\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();                                     // a\\n    }\\n\\n    void Update()\\n    {\\n        //Handle Keyboard Input and manage eDrayModes\\n        dirHeld = -1;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (Input.GetKey(keys[i])) dirHeld = i;\\n        }\\n\\n        // Pressing the attack button(s)\\n        if (Input.GetKeyDown(KeyCode.Z) && Time.time >= timeAtkNext)\\n        {       // a\\n            mode = eMode.attack;\\n            timeAtkDone = Time.time + attackDuration;\\n            timeAtkNext = Time.time + attackDelay;\\n        }\\n\\n        // Finishing the attack when it\'s over\\n        if (Time.time >= timeAtkDone)\\n        {                                      // b\\n            mode = eMode.idle;\\n        }\\n\\n        // Choosing the proper mode if we\'re not attacking\\n        if (mode != eMode.attack)\\n        {                                          // c\\n            if (dirHeld == -1)\\n            {\\n                mode = eMode.idle;\\n            }\\n            else\\n            {\\n                facing = dirHeld;                                            // d\\n                mode = eMode.move;\\n            }\\n        }\\n\\n        //Act on the current mode\\n        Vector3 vel = Vector3.zero;\\n        switch (mode)\\n        {                                                      // e\\n            case eMode.attack:\\n                anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.idle:\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.move:\\n                vel = directions[dirHeld];\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 1;\\n                break;\\n        }\\n\\n        rigid.velocity = vel * speed;\\n\\n    }\\n}\\n\", \"__Scripts/Enemy.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Enemy : MonoBehaviour\\n{\\n    protected static Vector3[] directions = new Vector3[] {                 // a\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };\\n\\n    [Header(\\\"Set in Inspector: Enemy\\\")]                                      // b\\n    public float maxHealth = 1;                               // c\\n\\n    [Header(\\\"Set Dynamically: Enemy\\\")]\\n    public float health;                                      // c\\n\\n    protected Animator anim;                                        // c\\n    protected Rigidbody rigid;                                       // c\\n    protected SpriteRenderer sRend;                                       // c\\n\\n    protected virtual void Awake()\\n    {                                         // d\\n        health = maxHealth;\\n        anim = GetComponent<Animator>();\\n        rigid = GetComponent<Rigidbody>();\\n        sRend = GetComponent<SpriteRenderer>();\\n    }\\n}\\n\", \"__Scripts/InRoom.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class InRoom : MonoBehaviour\\n{\\n    static public float ROOM_W = 16;                                     // a\\n    static public float ROOM_H = 11;\\n    static public float WALL_T = 2;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public bool keepInRoom = true;\\n    public float gridMult = 1;                                    // a\\n\\n\\n    void LateUpdate()\\n    {\\n        if (keepInRoom)\\n        {                                                    // b\\n            Vector2 rPos = roomPos;                                          // c\\n            rPos.x = Mathf.Clamp(rPos.x, WALL_T, ROOM_W - 1 - WALL_T);\\n            rPos.y = Mathf.Clamp(rPos.y, WALL_T, ROOM_H - 1 - WALL_T);\\n            roomPos = rPos;                                                  // d\\n        }\\n    }\\n\\n    // Where is this character in local room coordinates?\\n    public Vector2 roomPos\\n    {                                        // b\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x %= ROOM_W;\\n            tPos.y %= ROOM_H;\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rm = roomNum;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            rm += value;\\n            transform.position = rm;\\n        }\\n    }\\n\\n    // Which room is this character in?\\n    public Vector2 roomNum\\n    {                                        // c\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x = Mathf.Floor(tPos.x / ROOM_W);\\n            tPos.y = Mathf.Floor(tPos.y / ROOM_H);\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rPos = roomPos;\\n            Vector2 rm = value;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            transform.position = rm + rPos;\\n        }\\n    }\\n\\n}\", \"__Scripts/Skeletos.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Skeletos : Enemy\\n{                                              // a\\n    [Header(\\\"Set in Inspector: Skeletos\\\")]                                   // b\\n    public int speed = 2;\\n    public float timeThinkMin = 1f;\\n    public float timeThinkMax = 4f;\\n\\n    [Header(\\\"Set Dynamically: Skeletos\\\")]\\n    public int facing = 0;\\n    public float timeNextDecision = 0;\\n\\n    void Update()\\n    {\\n        if (Time.time >= timeNextDecision)\\n        {                                 // c\\n            DecideDirection();\\n        }\\n        // rigid is inherited from Enemy and is initialized in Enemy.Awake()\\n        rigid.velocity = directions[facing] * speed;\\n    }\\n\\n    void DecideDirection()\\n    {                                                 // d\\n        facing = Random.Range(0, 4);\\n        timeNextDecision = Time.time + Random.Range(timeThinkMin, timeThinkMax);\\n    }\\n}\\n\", \"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/SwordController.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class SwordController : MonoBehaviour\\n{\\n    private GameObject sword;\\n    private Dray dray;\\n\\n    void Start()\\n    {\\n        sword = transform.Find(\\\"Sword\\\").gameObject;                          // a\\n        dray = transform.parent.GetComponent<Dray>();\\n        // Deactivate the sword\\n        sword.SetActive(false);                                              // b\\n    }\\n\\n    void Update()\\n    {\\n        transform.rotation = Quaternion.Euler(0, 0, 90 * dray.facing);       // c\\n        sword.SetActive(dray.mode == Dray.eMode.attack);                     // d\\n    }\\n}\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y); \\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum]; \\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n    void Awake()\\n    {\\n        LoadMap();\\n    }\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}, \"07 - Per-Tile Collision\": {\"__Scripts/Dray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Dray : MonoBehaviour\\n{\\n    public enum eMode { idle, move, attack, transition }                     // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float speed = 5;\\n    public float attackDuration = 0.25f;// Number of seconds to attack\\n    public float attackDelay = 0.5f;    // Delay between attacks \\n\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int dirHeld = -1; // Direction of the held movement key\\n    public int facing = 1;   // Direction Dray is facing \\n    public eMode mode = eMode.idle;                                // a\\n\\n    private float timeAtkDone = 0;                                  // b\\n    private float timeAtkNext = 0;                                  // c\\n\\n\\n    private Rigidbody   rigid;\\n    private Animator    anim;                                            // a\\n\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };             // a\\n\\n    private KeyCode[] keys = new KeyCode[] { KeyCode.RightArrow,\\n        KeyCode.UpArrow, KeyCode.LeftArrow, KeyCode.DownArrow };             // a\\n\\n\\n    void Awake()\\n    {\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();                                     // a\\n    }\\n\\n    void Update()\\n    {\\n        //Handle Keyboard Input and manage eDrayModes\\n        dirHeld = -1;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (Input.GetKey(keys[i])) dirHeld = i;\\n        }\\n\\n        // Pressing the attack button(s)\\n        if (Input.GetKeyDown(KeyCode.Z) && Time.time >= timeAtkNext)\\n        {       // a\\n            mode = eMode.attack;\\n            timeAtkDone = Time.time + attackDuration;\\n            timeAtkNext = Time.time + attackDelay;\\n        }\\n\\n        // Finishing the attack when it\'s over\\n        if (Time.time >= timeAtkDone)\\n        {                                      // b\\n            mode = eMode.idle;\\n        }\\n\\n        // Choosing the proper mode if we\'re not attacking\\n        if (mode != eMode.attack)\\n        {                                          // c\\n            if (dirHeld == -1)\\n            {\\n                mode = eMode.idle;\\n            }\\n            else\\n            {\\n                facing = dirHeld;                                            // d\\n                mode = eMode.move;\\n            }\\n        }\\n\\n        //Act on the current mode\\n        Vector3 vel = Vector3.zero;\\n        switch (mode)\\n        {                                                      // e\\n            case eMode.attack:\\n                anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.idle:\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.move:\\n                vel = directions[dirHeld];\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 1;\\n                break;\\n        }\\n\\n        rigid.velocity = vel * speed;\\n\\n    }\\n}\\n\", \"__Scripts/Enemy.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Enemy : MonoBehaviour\\n{\\n    protected static Vector3[] directions = new Vector3[] {                 // a\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };\\n\\n    [Header(\\\"Set in Inspector: Enemy\\\")]                                      // b\\n    public float maxHealth = 1;                               // c\\n\\n    [Header(\\\"Set Dynamically: Enemy\\\")]\\n    public float health;                                      // c\\n\\n    protected Animator anim;                                        // c\\n    protected Rigidbody rigid;                                       // c\\n    protected SpriteRenderer sRend;                                       // c\\n\\n    protected virtual void Awake()\\n    {                                         // d\\n        health = maxHealth;\\n        anim = GetComponent<Animator>();\\n        rigid = GetComponent<Rigidbody>();\\n        sRend = GetComponent<SpriteRenderer>();\\n    }\\n}\\n\", \"__Scripts/InRoom.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class InRoom : MonoBehaviour\\n{\\n    static public float ROOM_W = 16;                                     // a\\n    static public float ROOM_H = 11;\\n    static public float WALL_T = 2;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public bool keepInRoom = true;\\n    public float gridMult = 1;                                    // a\\n\\n\\n    void LateUpdate()\\n    {\\n        if (keepInRoom)\\n        {                                                    // b\\n            Vector2 rPos = roomPos;                                          // c\\n            rPos.x = Mathf.Clamp(rPos.x, WALL_T, ROOM_W - 1 - WALL_T);\\n            rPos.y = Mathf.Clamp(rPos.y, WALL_T, ROOM_H - 1 - WALL_T);\\n            roomPos = rPos;                                                  // d\\n        }\\n    }\\n\\n    // Where is this character in local room coordinates?\\n    public Vector2 roomPos\\n    {                                        // b\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x %= ROOM_W;\\n            tPos.y %= ROOM_H;\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rm = roomNum;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            rm += value;\\n            transform.position = rm;\\n        }\\n    }\\n\\n    // Which room is this character in?\\n    public Vector2 roomNum\\n    {                                        // c\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x = Mathf.Floor(tPos.x / ROOM_W);\\n            tPos.y = Mathf.Floor(tPos.y / ROOM_H);\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rPos = roomPos;\\n            Vector2 rm = value;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            transform.position = rm + rPos;\\n        }\\n    }\\n\\n}\", \"__Scripts/Skeletos.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Skeletos : Enemy\\n{                                              // a\\n    [Header(\\\"Set in Inspector: Skeletos\\\")]                                   // b\\n    public int speed = 2;\\n    public float timeThinkMin = 1f;\\n    public float timeThinkMax = 4f;\\n\\n    [Header(\\\"Set Dynamically: Skeletos\\\")]\\n    public int facing = 0;\\n    public float timeNextDecision = 0;\\n\\n    void Update()\\n    {\\n        if (Time.time >= timeNextDecision)\\n        {                                 // c\\n            DecideDirection();\\n        }\\n        // rigid is inherited from Enemy and is initialized in Enemy.Awake()\\n        rigid.velocity = directions[facing] * speed;\\n    }\\n\\n    void DecideDirection()\\n    {                                                 // d\\n        facing = Random.Range(0, 4);\\n        timeNextDecision = Time.time + Random.Range(timeThinkMin, timeThinkMax);\\n    }\\n}\\n\", \"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/SwordController.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class SwordController : MonoBehaviour\\n{\\n    private GameObject sword;\\n    private Dray dray;\\n\\n    void Start()\\n    {\\n        sword = transform.Find(\\\"Sword\\\").gameObject;                          // a\\n        dray = transform.parent.GetComponent<Dray>();\\n        // Deactivate the sword\\n        sword.SetActive(false);                                              // b\\n    }\\n\\n    void Update()\\n    {\\n        transform.rotation = Quaternion.Euler(0, 0, 90 * dray.facing);       // c\\n        sword.SetActive(dray.mode == Dray.eMode.attack);                     // d\\n    }\\n}\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n\\n    private BoxCollider bColl;                                           // a\\n\\n    void Awake()\\n    {\\n        bColl = GetComponent<BoxCollider>();                                 // a\\n    }\\n\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y); \\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum];\\n\\n        SetCollider();                                                       // b\\n    }\\n\\n    // Arrange the collider for this tile\\n    void SetCollider()\\n    {\\n        // Collider info is pulled from DelverCollisions.txt\\n        bColl.enabled = true;\\n        char c = TileCamera.COLLISIONS[tileNum];                             // c\\n        switch (c)\\n        {\\n            case \'S\': // Whole\\n                bColl.center = Vector3.zero;\\n                bColl.size = Vector3.one;\\n                break;\\n            case \'W\': // Top\\n                bColl.center = new Vector3(0, 0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'A\': // Left\\n                bColl.center = new Vector3(-0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n            case \'D\': // Right\\n                bColl.center = new Vector3(0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n\\n            // vvvvvvvv-------- These are optional --------vvvvvvvv          // d\\n            case \'Q\': // Top, Left\\n                bColl.center = new Vector3(-0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'E\': // Top, Right\\n                bColl.center = new Vector3(0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'Z\': // Bottom, left\\n                bColl.center = new Vector3(-0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'X\': // Bottom\\n                bColl.center = new Vector3(0, -0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'C\': // Bottom, Right\\n                bColl.center = new Vector3(0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            // ^^^^^^^^-------- These are optional --------^^^^^^^^          // d\\n\\n            default: // Anything else: _, |, etc.                            // e\\n                bColl.enabled = false;\\n                break;\\n        }\\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    static public string COLLISIONS;                                  // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n\\n    void Awake()\\n    {\\n        COLLISIONS = Utils.RemoveLineEndings(mapCollisions.text);          // b\\n        LoadMap();\\n    }\\n\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}, \"08 - Aligning to the Grid\": {\"__Scripts/Dray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Dray : MonoBehaviour, IFacingMover\\n{\\n    public enum eMode { idle, move, attack, transition }                     // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float speed = 5;\\n    public float attackDuration = 0.25f;// Number of seconds to attack\\n    public float attackDelay = 0.5f;    // Delay between attacks \\n\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int dirHeld = -1; // Direction of the held movement key\\n    public int facing = 1;   // Direction Dray is facing \\n    public eMode mode = eMode.idle;                                // a\\n\\n    private float timeAtkDone = 0;                                  // b\\n    private float timeAtkNext = 0;                                  // c\\n\\n\\n    private Rigidbody   rigid;\\n    private Animator    anim;                                            // a\\n    private InRoom      inRm;                                            // b\\n\\n\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };             // a\\n\\n    private KeyCode[] keys = new KeyCode[] { KeyCode.RightArrow,\\n        KeyCode.UpArrow, KeyCode.LeftArrow, KeyCode.DownArrow };             // a\\n\\n\\n    void Awake()\\n    {\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();                                     // a\\n        inRm = GetComponent<InRoom>();                                       // b\\n    }\\n\\n    void Update()\\n    {\\n        //Handle Keyboard Input and manage eDrayModes\\n        dirHeld = -1;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (Input.GetKey(keys[i])) dirHeld = i;\\n        }\\n\\n        // Pressing the attack button(s)\\n        if (Input.GetKeyDown(KeyCode.Z) && Time.time >= timeAtkNext)\\n        {       // a\\n            mode = eMode.attack;\\n            timeAtkDone = Time.time + attackDuration;\\n            timeAtkNext = Time.time + attackDelay;\\n        }\\n\\n        // Finishing the attack when it\'s over\\n        if (Time.time >= timeAtkDone)\\n        {                                      // b\\n            mode = eMode.idle;\\n        }\\n\\n        // Choosing the proper mode if we\'re not attacking\\n        if (mode != eMode.attack)\\n        {                                          // c\\n            if (dirHeld == -1)\\n            {\\n                mode = eMode.idle;\\n            }\\n            else\\n            {\\n                facing = dirHeld;                                            // d\\n                mode = eMode.move;\\n            }\\n        }\\n\\n        //Act on the current mode\\n        Vector3 vel = Vector3.zero;\\n        switch (mode)\\n        {                                                      // e\\n            case eMode.attack:\\n                anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.idle:\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.move:\\n                vel = directions[dirHeld];\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 1;\\n                break;\\n        }\\n\\n        rigid.velocity = vel * speed;\\n\\n    }\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {                                                 // c\\n        return facing;\\n    }\\n\\n    public bool moving\\n    {                                                     // d\\n        get\\n        {\\n            return (mode == eMode.move);\\n        }\\n    }\\n\\n    public float GetSpeed()\\n    {                                                // e\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {                                                 // f\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n}\\n\", \"__Scripts/Enemy.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Enemy : MonoBehaviour\\n{\\n    protected static Vector3[] directions = new Vector3[] {                 // a\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };\\n\\n    [Header(\\\"Set in Inspector: Enemy\\\")]                                      // b\\n    public float maxHealth = 1;                               // c\\n\\n    [Header(\\\"Set Dynamically: Enemy\\\")]\\n    public float health;                                      // c\\n\\n    protected Animator anim;                                        // c\\n    protected Rigidbody rigid;                                       // c\\n    protected SpriteRenderer sRend;                                       // c\\n\\n    protected virtual void Awake()\\n    {                                         // d\\n        health = maxHealth;\\n        anim = GetComponent<Animator>();\\n        rigid = GetComponent<Rigidbody>();\\n        sRend = GetComponent<SpriteRenderer>();\\n    }\\n}\\n\", \"__Scripts/GridMove.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GridMove : MonoBehaviour\\n{\\n    private IFacingMover mover;\\n\\n    void Awake()\\n    {\\n        mover = GetComponent<IFacingMover>();                                // a\\n    }\\n\\n    void FixedUpdate()\\n    {\\n        if (!mover.moving) return; // If not moving, nothing to do here\\n        int facing = mover.GetFacing();\\n\\n        // If we are moving in a direction, align to the grid\\n        // First, get the grid location\\n        Vector2 rPos = mover.roomPos;\\n        Vector2 rPosGrid = mover.GetRoomPosOnGrid();\\n        // This relies on IFacingMover (which uses InRoom) to choose grid spacing\\n\\n        // Then move towards the grid line\\n        float delta = 0;\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            delta = rPosGrid.y - rPos.y;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            delta = rPosGrid.x - rPos.x;\\n        }\\n        if (delta == 0) return; // Already aligned to the grid\\n\\n        float move = mover.GetSpeed() * Time.fixedDeltaTime;\\n        move = Mathf.Min(move, Mathf.Abs(delta));\\n        if (delta < 0) move = -move;\\n\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            rPos.y += move;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            rPos.x += move;\\n        }\\n\\n        mover.roomPos = rPos;\\n    }\\n}\\n\", \"__Scripts/IFacingMover.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IFacingMover\\n{                                              // a\\n    int GetFacing();                                                         // b\\n    bool moving { get; }                                                     // c\\n    float GetSpeed();\\n    float gridMult { get; }                                                  // d\\n    Vector2 roomPos { get; set; }                                            // e\\n    Vector2 roomNum { get; set; }\\n    Vector2 GetRoomPosOnGrid(float mult = -1);                             // f\\n}\", \"__Scripts/InRoom.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class InRoom : MonoBehaviour\\n{\\n    static public float ROOM_W = 16;                                     // a\\n    static public float ROOM_H = 11;\\n    static public float WALL_T = 2;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public bool keepInRoom = true;\\n    public float gridMult = 1;                                    // a\\n\\n\\n    void LateUpdate()\\n    {\\n        if (keepInRoom)\\n        {                                                    // b\\n            Vector2 rPos = roomPos;                                          // c\\n            rPos.x = Mathf.Clamp(rPos.x, WALL_T, ROOM_W - 1 - WALL_T);\\n            rPos.y = Mathf.Clamp(rPos.y, WALL_T, ROOM_H - 1 - WALL_T);\\n            roomPos = rPos;                                                  // d\\n        }\\n    }\\n\\n    // Where is this character in local room coordinates?\\n    public Vector2 roomPos\\n    {                                        // b\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x %= ROOM_W;\\n            tPos.y %= ROOM_H;\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rm = roomNum;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            rm += value;\\n            transform.position = rm;\\n        }\\n    }\\n\\n    // Which room is this character in?\\n    public Vector2 roomNum\\n    {                                        // c\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x = Mathf.Floor(tPos.x / ROOM_W);\\n            tPos.y = Mathf.Floor(tPos.y / ROOM_H);\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rPos = roomPos;\\n            Vector2 rm = value;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            transform.position = rm + rPos;\\n        }\\n    }\\n\\n    // What is the closest grid location to this character?\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        if (mult == -1)\\n        {\\n            mult = gridMult;\\n        }\\n        Vector2 rPos = roomPos;\\n        rPos /= mult;\\n        rPos.x = Mathf.Round(rPos.x);\\n        rPos.y = Mathf.Round(rPos.y);\\n        rPos *= mult;\\n        return rPos;\\n    }\\n\\n}\", \"__Scripts/Skeletos.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Skeletos : Enemy, IFacingMover\\n{                                              // a\\n    [Header(\\\"Set in Inspector: Skeletos\\\")]                                   // b\\n    public int speed = 2;\\n    public float timeThinkMin = 1f;\\n    public float timeThinkMax = 4f;\\n\\n    [Header(\\\"Set Dynamically: Skeletos\\\")]\\n    public int facing = 0;\\n    public float timeNextDecision = 0;\\n\\n    private InRoom inRm;                                                    // b\\n\\n    protected override void Awake()\\n    {                                       // c\\n        base.Awake();\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    void Update()\\n    {\\n        if (Time.time >= timeNextDecision)\\n        {                                 // c\\n            DecideDirection();\\n        }\\n        // rigid is inherited from Enemy and is initialized in Enemy.Awake()\\n        rigid.velocity = directions[facing] * speed;\\n    }\\n\\n    void DecideDirection()\\n    {                                                 // d\\n        facing = Random.Range(0, 4);\\n        timeNextDecision = Time.time + Random.Range(timeThinkMin, timeThinkMax);\\n    }\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {\\n        return facing;\\n    }\\n\\n    public bool moving { get { return true; } }                            // d\\n\\n    public float GetSpeed()\\n    {\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n}\\n\", \"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/SwordController.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class SwordController : MonoBehaviour\\n{\\n    private GameObject sword;\\n    private Dray dray;\\n\\n    void Start()\\n    {\\n        sword = transform.Find(\\\"Sword\\\").gameObject;                          // a\\n        dray = transform.parent.GetComponent<Dray>();\\n        // Deactivate the sword\\n        sword.SetActive(false);                                              // b\\n    }\\n\\n    void Update()\\n    {\\n        transform.rotation = Quaternion.Euler(0, 0, 90 * dray.facing);       // c\\n        sword.SetActive(dray.mode == Dray.eMode.attack);                     // d\\n    }\\n}\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n\\n    private BoxCollider bColl;                                           // a\\n\\n    void Awake()\\n    {\\n        bColl = GetComponent<BoxCollider>();                                 // a\\n    }\\n\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y); \\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum];\\n\\n        SetCollider();                                                       // b\\n    }\\n\\n    // Arrange the collider for this tile\\n    void SetCollider()\\n    {\\n        // Collider info is pulled from DelverCollisions.txt\\n        bColl.enabled = true;\\n        char c = TileCamera.COLLISIONS[tileNum];                             // c\\n        switch (c)\\n        {\\n            case \'S\': // Whole\\n                bColl.center = Vector3.zero;\\n                bColl.size = Vector3.one;\\n                break;\\n            case \'W\': // Top\\n                bColl.center = new Vector3(0, 0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'A\': // Left\\n                bColl.center = new Vector3(-0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n            case \'D\': // Right\\n                bColl.center = new Vector3(0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n\\n            // vvvvvvvv-------- These are optional --------vvvvvvvv          // d\\n            case \'Q\': // Top, Left\\n                bColl.center = new Vector3(-0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'E\': // Top, Right\\n                bColl.center = new Vector3(0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'Z\': // Bottom, left\\n                bColl.center = new Vector3(-0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'X\': // Bottom\\n                bColl.center = new Vector3(0, -0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'C\': // Bottom, Right\\n                bColl.center = new Vector3(0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            // ^^^^^^^^-------- These are optional --------^^^^^^^^          // d\\n\\n            default: // Anything else: _, |, etc.                            // e\\n                bColl.enabled = false;\\n                break;\\n        }\\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    static public string COLLISIONS;                                  // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n\\n    void Awake()\\n    {\\n        COLLISIONS = Utils.RemoveLineEndings(mapCollisions.text);          // b\\n        LoadMap();\\n    }\\n\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}, \"09 - Moving from Room to Room\": {\"__Scripts/Dray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Dray : MonoBehaviour, IFacingMover\\n{\\n    public enum eMode { idle, move, attack, transition }                     // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float speed = 5;\\n    public float attackDuration = 0.25f;// Number of seconds to attack\\n    public float attackDelay = 0.5f;    // Delay between attacks \\n    public float transitionDelay = 0.5f;// Room transition delay  // a\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int dirHeld = -1; // Direction of the held movement key\\n    public int facing = 1;   // Direction Dray is facing \\n    public eMode mode = eMode.idle;                                // a\\n\\n    private float timeAtkDone = 0;                                  // b\\n    private float timeAtkNext = 0;                                  // c;    \\n    private float transitionDone = 0;                              // a\\n    private Vector2 transitionPos;\\n\\n\\n\\n    private Rigidbody   rigid;\\n    private Animator    anim;                                            // a\\n    private InRoom      inRm;                                            // b\\n\\n\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };             // a\\n\\n    private KeyCode[] keys = new KeyCode[] { KeyCode.RightArrow,\\n        KeyCode.UpArrow, KeyCode.LeftArrow, KeyCode.DownArrow };             // a\\n\\n\\n    void Awake()\\n    {\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();                                     // a\\n        inRm = GetComponent<InRoom>();                                       // b\\n    }\\n\\n    void Update()\\n    {\\n        if (mode == eMode.transition)\\n        {                                    // b\\n            rigid.velocity = Vector3.zero;\\n            anim.speed = 0;\\n            roomPos = transitionPos;  // Keeps Dray in place\\n            if (Time.time < transitionDone) return;\\n            // The following line is only reached if Time.time >= transitionDone\\n            mode = eMode.idle;\\n        }\\n\\n        //Handle Keyboard Input and manage eDrayModes\\n        dirHeld = -1;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (Input.GetKey(keys[i])) dirHeld = i;\\n        }\\n\\n        // Pressing the attack button(s)\\n        if (Input.GetKeyDown(KeyCode.Z) && Time.time >= timeAtkNext)\\n        {       // a\\n            mode = eMode.attack;\\n            timeAtkDone = Time.time + attackDuration;\\n            timeAtkNext = Time.time + attackDelay;\\n        }\\n\\n        // Finishing the attack when it\'s over\\n        if (Time.time >= timeAtkDone)\\n        {                                      // b\\n            mode = eMode.idle;\\n        }\\n\\n        // Choosing the proper mode if we\'re not attacking\\n        if (mode != eMode.attack)\\n        {                                          // c\\n            if (dirHeld == -1)\\n            {\\n                mode = eMode.idle;\\n            }\\n            else\\n            {\\n                facing = dirHeld;                                            // d\\n                mode = eMode.move;\\n            }\\n        }\\n\\n        //Act on the current mode\\n        Vector3 vel = Vector3.zero;\\n        switch (mode)\\n        {                                                      // e\\n            case eMode.attack:\\n                anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.idle:\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.move:\\n                vel = directions[dirHeld];\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 1;\\n                break;\\n        }\\n\\n        rigid.velocity = vel * speed;\\n\\n    }\\n\\n\\n    void LateUpdate()\\n    {\\n        // Get the half-grid location of this GameObject\\n        Vector2 rPos = GetRoomPosOnGrid(0.5f);  // Forces half-grid        // c\\n\\n        // Check to see whether we\'re in a Door tile\\n        int doorNum;\\n        for (doorNum = 0; doorNum < 4; doorNum++)\\n        {\\n            if (rPos == InRoom.DOORS[doorNum])\\n            {\\n                break;                                                       // d\\n            }\\n        }\\n\\n        if (doorNum > 3 || doorNum != facing) return;                      // e\\n\\n        // Move to the next room\\n        Vector2 rm = roomNum;\\n        switch (doorNum)\\n        {                                                   // f\\n            case 0:\\n                rm.x += 1;\\n                break;\\n            case 1:\\n                rm.y += 1;\\n                break;\\n            case 2:\\n                rm.x -= 1;\\n                break;\\n            case 3:\\n                rm.y -= 1;\\n                break;\\n        }\\n\\n        // Make sure that the rm we want to jump to is valid\\n        if (rm.x >= 0 && rm.x <= InRoom.MAX_RM_X)\\n        {                          // g\\n            if (rm.y >= 0 && rm.y <= InRoom.MAX_RM_Y)\\n            {\\n                roomNum = rm;\\n                transitionPos = InRoom.DOORS[(doorNum + 2) % 4];             // h\\n                roomPos = transitionPos;\\n                mode = eMode.transition;                                     // i\\n                transitionDone = Time.time + transitionDelay;\\n            }\\n        }\\n    }\\n\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {                                                 // c\\n        return facing;\\n    }\\n\\n    public bool moving\\n    {                                                     // d\\n        get\\n        {\\n            return (mode == eMode.move);\\n        }\\n    }\\n\\n    public float GetSpeed()\\n    {                                                // e\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {                                                 // f\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n}\\n\", \"__Scripts/Enemy.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Enemy : MonoBehaviour\\n{\\n    protected static Vector3[] directions = new Vector3[] {                 // a\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };\\n\\n    [Header(\\\"Set in Inspector: Enemy\\\")]                                      // b\\n    public float maxHealth = 1;                               // c\\n\\n    [Header(\\\"Set Dynamically: Enemy\\\")]\\n    public float health;                                      // c\\n\\n    protected Animator anim;                                        // c\\n    protected Rigidbody rigid;                                       // c\\n    protected SpriteRenderer sRend;                                       // c\\n\\n    protected virtual void Awake()\\n    {                                         // d\\n        health = maxHealth;\\n        anim = GetComponent<Animator>();\\n        rigid = GetComponent<Rigidbody>();\\n        sRend = GetComponent<SpriteRenderer>();\\n    }\\n}\\n\", \"__Scripts/GridMove.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GridMove : MonoBehaviour\\n{\\n    private IFacingMover mover;\\n\\n    void Awake()\\n    {\\n        mover = GetComponent<IFacingMover>();                                // a\\n    }\\n\\n    void FixedUpdate()\\n    {\\n        if (!mover.moving) return; // If not moving, nothing to do here\\n        int facing = mover.GetFacing();\\n\\n        // If we are moving in a direction, align to the grid\\n        // First, get the grid location\\n        Vector2 rPos = mover.roomPos;\\n        Vector2 rPosGrid = mover.GetRoomPosOnGrid();\\n        // This relies on IFacingMover (which uses InRoom) to choose grid spacing\\n\\n        // Then move towards the grid line\\n        float delta = 0;\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            delta = rPosGrid.y - rPos.y;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            delta = rPosGrid.x - rPos.x;\\n        }\\n        if (delta == 0) return; // Already aligned to the grid\\n\\n        float move = mover.GetSpeed() * Time.fixedDeltaTime;\\n        move = Mathf.Min(move, Mathf.Abs(delta));\\n        if (delta < 0) move = -move;\\n\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            rPos.y += move;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            rPos.x += move;\\n        }\\n\\n        mover.roomPos = rPos;\\n    }\\n}\\n\", \"__Scripts/IFacingMover.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IFacingMover\\n{                                              // a\\n    int GetFacing();                                                         // b\\n    bool moving { get; }                                                     // c\\n    float GetSpeed();\\n    float gridMult { get; }                                                  // d\\n    Vector2 roomPos { get; set; }                                            // e\\n    Vector2 roomNum { get; set; }\\n    Vector2 GetRoomPosOnGrid(float mult = -1);                             // f\\n}\", \"__Scripts/InRoom.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class InRoom : MonoBehaviour\\n{\\n    static public float ROOM_W = 16;                                     // a\\n    static public float ROOM_H = 11;\\n    static public float WALL_T = 2;\\n\\n    static public int MAX_RM_X = 9;                                    // a\\n    static public int MAX_RM_Y = 9;\\n\\n    static public Vector2[] DOORS = new Vector2[] {                          // b\\n        new Vector2(14,   5),\\n        new Vector2(7.5f, 9),\\n        new Vector2(1,    5),\\n        new Vector2(7.5f, 1)\\n    };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public bool keepInRoom = true;\\n    public float gridMult = 1;                                    // a\\n\\n\\n    void LateUpdate()\\n    {\\n        if (keepInRoom)\\n        {                                                    // b\\n            Vector2 rPos = roomPos;                                          // c\\n            rPos.x = Mathf.Clamp(rPos.x, WALL_T, ROOM_W - 1 - WALL_T);\\n            rPos.y = Mathf.Clamp(rPos.y, WALL_T, ROOM_H - 1 - WALL_T);\\n            roomPos = rPos;                                                  // d\\n        }\\n    }\\n\\n    // Where is this character in local room coordinates?\\n    public Vector2 roomPos\\n    {                                        // b\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x %= ROOM_W;\\n            tPos.y %= ROOM_H;\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rm = roomNum;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            rm += value;\\n            transform.position = rm;\\n        }\\n    }\\n\\n    // Which room is this character in?\\n    public Vector2 roomNum\\n    {                                        // c\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x = Mathf.Floor(tPos.x / ROOM_W);\\n            tPos.y = Mathf.Floor(tPos.y / ROOM_H);\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rPos = roomPos;\\n            Vector2 rm = value;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            transform.position = rm + rPos;\\n        }\\n    }\\n\\n    // What is the closest grid location to this character?\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        if (mult == -1)\\n        {\\n            mult = gridMult;\\n        }\\n        Vector2 rPos = roomPos;\\n        rPos /= mult;\\n        rPos.x = Mathf.Round(rPos.x);\\n        rPos.y = Mathf.Round(rPos.y);\\n        rPos *= mult;\\n        return rPos;\\n    }\\n\\n}\", \"__Scripts/Skeletos.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Skeletos : Enemy, IFacingMover\\n{                                              // a\\n    [Header(\\\"Set in Inspector: Skeletos\\\")]                                   // b\\n    public int speed = 2;\\n    public float timeThinkMin = 1f;\\n    public float timeThinkMax = 4f;\\n\\n    [Header(\\\"Set Dynamically: Skeletos\\\")]\\n    public int facing = 0;\\n    public float timeNextDecision = 0;\\n\\n    private InRoom inRm;                                                    // b\\n\\n    protected override void Awake()\\n    {                                       // c\\n        base.Awake();\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    void Update()\\n    {\\n        if (Time.time >= timeNextDecision)\\n        {                                 // c\\n            DecideDirection();\\n        }\\n        // rigid is inherited from Enemy and is initialized in Enemy.Awake()\\n        rigid.velocity = directions[facing] * speed;\\n    }\\n\\n    void DecideDirection()\\n    {                                                 // d\\n        facing = Random.Range(0, 4);\\n        timeNextDecision = Time.time + Random.Range(timeThinkMin, timeThinkMax);\\n    }\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {\\n        return facing;\\n    }\\n\\n    public bool moving { get { return true; } }                            // d\\n\\n    public float GetSpeed()\\n    {\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n}\\n\", \"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/SwordController.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class SwordController : MonoBehaviour\\n{\\n    private GameObject sword;\\n    private Dray dray;\\n\\n    void Start()\\n    {\\n        sword = transform.Find(\\\"Sword\\\").gameObject;                          // a\\n        dray = transform.parent.GetComponent<Dray>();\\n        // Deactivate the sword\\n        sword.SetActive(false);                                              // b\\n    }\\n\\n    void Update()\\n    {\\n        transform.rotation = Quaternion.Euler(0, 0, 90 * dray.facing);       // c\\n        sword.SetActive(dray.mode == Dray.eMode.attack);                     // d\\n    }\\n}\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n\\n    private BoxCollider bColl;                                           // a\\n\\n    void Awake()\\n    {\\n        bColl = GetComponent<BoxCollider>();                                 // a\\n    }\\n\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y); \\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum];\\n\\n        SetCollider();                                                       // b\\n    }\\n\\n    // Arrange the collider for this tile\\n    void SetCollider()\\n    {\\n        // Collider info is pulled from DelverCollisions.txt\\n        bColl.enabled = true;\\n        char c = TileCamera.COLLISIONS[tileNum];                             // c\\n        switch (c)\\n        {\\n            case \'S\': // Whole\\n                bColl.center = Vector3.zero;\\n                bColl.size = Vector3.one;\\n                break;\\n            case \'W\': // Top\\n                bColl.center = new Vector3(0, 0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'A\': // Left\\n                bColl.center = new Vector3(-0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n            case \'D\': // Right\\n                bColl.center = new Vector3(0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n\\n            // vvvvvvvv-------- These are optional --------vvvvvvvv          // d\\n            case \'Q\': // Top, Left\\n                bColl.center = new Vector3(-0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'E\': // Top, Right\\n                bColl.center = new Vector3(0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'Z\': // Bottom, left\\n                bColl.center = new Vector3(-0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'X\': // Bottom\\n                bColl.center = new Vector3(0, -0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'C\': // Bottom, Right\\n                bColl.center = new Vector3(0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            // ^^^^^^^^-------- These are optional --------^^^^^^^^          // d\\n\\n            default: // Anything else: _, |, etc.                            // e\\n                bColl.enabled = false;\\n                break;\\n        }\\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    static public string COLLISIONS;                                  // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n\\n    void Awake()\\n    {\\n        COLLISIONS = Utils.RemoveLineEndings(mapCollisions.text);          // b\\n        LoadMap();\\n    }\\n\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}, \"10 - Making the Camera Follow Dray\": {\"__Scripts/CamFollowDray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class CamFollowDray : MonoBehaviour\\n{\\n    static public bool TRANSITIONING = false;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public InRoom drayInRm;                                            // a\\n    public float transTime = 0.5f;\\n\\n    private Vector3 p0, p1;\\n\\n    private InRoom inRm;                                                // b\\n    private float transStart;\\n\\n    void Awake()\\n    {\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    void Update()\\n    {\\n        if (TRANSITIONING)\\n        {                                                 // c\\n            float u = (Time.time - transStart) / transTime;\\n            if (u >= 1)\\n            {\\n                u = 1;\\n                TRANSITIONING = false;\\n            }\\n            transform.position = (1 - u) * p0 + u * p1;\\n        }\\n        else\\n        {                                                             // d\\n            if (drayInRm.roomNum != inRm.roomNum)\\n            {\\n                TransitionTo(drayInRm.roomNum);\\n            }\\n        }\\n    }\\n\\n    void TransitionTo(Vector2 rm)\\n    {                                        // e\\n        p0 = transform.position;\\n        inRm.roomNum = rm;\\n        p1 = transform.position + (Vector3.back * 10);\\n        transform.position = p0;\\n\\n        transStart = Time.time;\\n        TRANSITIONING = true;\\n    }\\n}\\n\", \"__Scripts/Dray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Dray : MonoBehaviour, IFacingMover\\n{\\n    public enum eMode { idle, move, attack, transition }                     // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float speed = 5;\\n    public float attackDuration = 0.25f;// Number of seconds to attack\\n    public float attackDelay = 0.5f;    // Delay between attacks \\n    public float transitionDelay = 0.5f;// Room transition delay  // a\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int dirHeld = -1; // Direction of the held movement key\\n    public int facing = 1;   // Direction Dray is facing \\n    public eMode mode = eMode.idle;                                // a\\n\\n    private float timeAtkDone = 0;                                  // b\\n    private float timeAtkNext = 0;                                  // c;    \\n    private float transitionDone = 0;                              // a\\n    private Vector2 transitionPos;\\n\\n\\n\\n    private Rigidbody   rigid;\\n    private Animator    anim;                                            // a\\n    private InRoom      inRm;                                            // b\\n\\n\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };             // a\\n\\n    private KeyCode[] keys = new KeyCode[] { KeyCode.RightArrow,\\n        KeyCode.UpArrow, KeyCode.LeftArrow, KeyCode.DownArrow };             // a\\n\\n\\n    void Awake()\\n    {\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();                                     // a\\n        inRm = GetComponent<InRoom>();                                       // b\\n    }\\n\\n    void Update()\\n    {\\n        if (mode == eMode.transition)\\n        {                                    // b\\n            rigid.velocity = Vector3.zero;\\n            anim.speed = 0;\\n            roomPos = transitionPos;  // Keeps Dray in place\\n            if (Time.time < transitionDone) return;\\n            // The following line is only reached if Time.time >= transitionDone\\n            mode = eMode.idle;\\n        }\\n\\n        //Handle Keyboard Input and manage eDrayModes\\n        dirHeld = -1;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (Input.GetKey(keys[i])) dirHeld = i;\\n        }\\n\\n        // Pressing the attack button(s)\\n        if (Input.GetKeyDown(KeyCode.Z) && Time.time >= timeAtkNext)\\n        {       // a\\n            mode = eMode.attack;\\n            timeAtkDone = Time.time + attackDuration;\\n            timeAtkNext = Time.time + attackDelay;\\n        }\\n\\n        // Finishing the attack when it\'s over\\n        if (Time.time >= timeAtkDone)\\n        {                                      // b\\n            mode = eMode.idle;\\n        }\\n\\n        // Choosing the proper mode if we\'re not attacking\\n        if (mode != eMode.attack)\\n        {                                          // c\\n            if (dirHeld == -1)\\n            {\\n                mode = eMode.idle;\\n            }\\n            else\\n            {\\n                facing = dirHeld;                                            // d\\n                mode = eMode.move;\\n            }\\n        }\\n\\n        //Act on the current mode\\n        Vector3 vel = Vector3.zero;\\n        switch (mode)\\n        {                                                      // e\\n            case eMode.attack:\\n                anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.idle:\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.move:\\n                vel = directions[dirHeld];\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 1;\\n                break;\\n        }\\n\\n        rigid.velocity = vel * speed;\\n\\n    }\\n\\n\\n    void LateUpdate()\\n    {\\n        // Get the half-grid location of this GameObject\\n        Vector2 rPos = GetRoomPosOnGrid(0.5f);  // Forces half-grid        // c\\n\\n        // Check to see whether we\'re in a Door tile\\n        int doorNum;\\n        for (doorNum = 0; doorNum < 4; doorNum++)\\n        {\\n            if (rPos == InRoom.DOORS[doorNum])\\n            {\\n                break;                                                       // d\\n            }\\n        }\\n\\n        if (doorNum > 3 || doorNum != facing) return;                      // e\\n\\n        // Move to the next room\\n        Vector2 rm = roomNum;\\n        switch (doorNum)\\n        {                                                   // f\\n            case 0:\\n                rm.x += 1;\\n                break;\\n            case 1:\\n                rm.y += 1;\\n                break;\\n            case 2:\\n                rm.x -= 1;\\n                break;\\n            case 3:\\n                rm.y -= 1;\\n                break;\\n        }\\n\\n        // Make sure that the rm we want to jump to is valid\\n        if (rm.x >= 0 && rm.x <= InRoom.MAX_RM_X)\\n        {                          // g\\n            if (rm.y >= 0 && rm.y <= InRoom.MAX_RM_Y)\\n            {\\n                roomNum = rm;\\n                transitionPos = InRoom.DOORS[(doorNum + 2) % 4];             // h\\n                roomPos = transitionPos;\\n                mode = eMode.transition;                                     // i\\n                transitionDone = Time.time + transitionDelay;\\n            }\\n        }\\n    }\\n\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {                                                 // c\\n        return facing;\\n    }\\n\\n    public bool moving\\n    {                                                     // d\\n        get\\n        {\\n            return (mode == eMode.move);\\n        }\\n    }\\n\\n    public float GetSpeed()\\n    {                                                // e\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {                                                 // f\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n}\\n\", \"__Scripts/Enemy.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Enemy : MonoBehaviour\\n{\\n    protected static Vector3[] directions = new Vector3[] {                 // a\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };\\n\\n    [Header(\\\"Set in Inspector: Enemy\\\")]                                      // b\\n    public float maxHealth = 1;                               // c\\n\\n    [Header(\\\"Set Dynamically: Enemy\\\")]\\n    public float health;                                      // c\\n\\n    protected Animator anim;                                        // c\\n    protected Rigidbody rigid;                                       // c\\n    protected SpriteRenderer sRend;                                       // c\\n\\n    protected virtual void Awake()\\n    {                                         // d\\n        health = maxHealth;\\n        anim = GetComponent<Animator>();\\n        rigid = GetComponent<Rigidbody>();\\n        sRend = GetComponent<SpriteRenderer>();\\n    }\\n}\\n\", \"__Scripts/GridMove.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GridMove : MonoBehaviour\\n{\\n    private IFacingMover mover;\\n\\n    void Awake()\\n    {\\n        mover = GetComponent<IFacingMover>();                                // a\\n    }\\n\\n    void FixedUpdate()\\n    {\\n        if (!mover.moving) return; // If not moving, nothing to do here\\n        int facing = mover.GetFacing();\\n\\n        // If we are moving in a direction, align to the grid\\n        // First, get the grid location\\n        Vector2 rPos = mover.roomPos;\\n        Vector2 rPosGrid = mover.GetRoomPosOnGrid();\\n        // This relies on IFacingMover (which uses InRoom) to choose grid spacing\\n\\n        // Then move towards the grid line\\n        float delta = 0;\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            delta = rPosGrid.y - rPos.y;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            delta = rPosGrid.x - rPos.x;\\n        }\\n        if (delta == 0) return; // Already aligned to the grid\\n\\n        float move = mover.GetSpeed() * Time.fixedDeltaTime;\\n        move = Mathf.Min(move, Mathf.Abs(delta));\\n        if (delta < 0) move = -move;\\n\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            rPos.y += move;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            rPos.x += move;\\n        }\\n\\n        mover.roomPos = rPos;\\n    }\\n}\\n\", \"__Scripts/IFacingMover.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IFacingMover\\n{                                              // a\\n    int GetFacing();                                                         // b\\n    bool moving { get; }                                                     // c\\n    float GetSpeed();\\n    float gridMult { get; }                                                  // d\\n    Vector2 roomPos { get; set; }                                            // e\\n    Vector2 roomNum { get; set; }\\n    Vector2 GetRoomPosOnGrid(float mult = -1);                             // f\\n}\", \"__Scripts/InRoom.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class InRoom : MonoBehaviour\\n{\\n    static public float ROOM_W = 16;                                     // a\\n    static public float ROOM_H = 11;\\n    static public float WALL_T = 2;\\n\\n    static public int MAX_RM_X = 9;                                    // a\\n    static public int MAX_RM_Y = 9;\\n\\n    static public Vector2[] DOORS = new Vector2[] {                          // b\\n        new Vector2(14,   5),\\n        new Vector2(7.5f, 9),\\n        new Vector2(1,    5),\\n        new Vector2(7.5f, 1)\\n    };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public bool keepInRoom = true;\\n    public float gridMult = 1;                                    // a\\n\\n\\n    void LateUpdate()\\n    {\\n        if (keepInRoom)\\n        {                                                    // b\\n            Vector2 rPos = roomPos;                                          // c\\n            rPos.x = Mathf.Clamp(rPos.x, WALL_T, ROOM_W - 1 - WALL_T);\\n            rPos.y = Mathf.Clamp(rPos.y, WALL_T, ROOM_H - 1 - WALL_T);\\n            roomPos = rPos;                                                  // d\\n        }\\n    }\\n\\n    // Where is this character in local room coordinates?\\n    public Vector2 roomPos\\n    {                                        // b\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x %= ROOM_W;\\n            tPos.y %= ROOM_H;\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rm = roomNum;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            rm += value;\\n            transform.position = rm;\\n        }\\n    }\\n\\n    // Which room is this character in?\\n    public Vector2 roomNum\\n    {                                        // c\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x = Mathf.Floor(tPos.x / ROOM_W);\\n            tPos.y = Mathf.Floor(tPos.y / ROOM_H);\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rPos = roomPos;\\n            Vector2 rm = value;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            transform.position = rm + rPos;\\n        }\\n    }\\n\\n    // What is the closest grid location to this character?\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        if (mult == -1)\\n        {\\n            mult = gridMult;\\n        }\\n        Vector2 rPos = roomPos;\\n        rPos /= mult;\\n        rPos.x = Mathf.Round(rPos.x);\\n        rPos.y = Mathf.Round(rPos.y);\\n        rPos *= mult;\\n        return rPos;\\n    }\\n\\n}\", \"__Scripts/Skeletos.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Skeletos : Enemy, IFacingMover\\n{                                              // a\\n    [Header(\\\"Set in Inspector: Skeletos\\\")]                                   // b\\n    public int speed = 2;\\n    public float timeThinkMin = 1f;\\n    public float timeThinkMax = 4f;\\n\\n    [Header(\\\"Set Dynamically: Skeletos\\\")]\\n    public int facing = 0;\\n    public float timeNextDecision = 0;\\n\\n    private InRoom inRm;                                                    // b\\n\\n    protected override void Awake()\\n    {                                       // c\\n        base.Awake();\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    void Update()\\n    {\\n        if (Time.time >= timeNextDecision)\\n        {                                 // c\\n            DecideDirection();\\n        }\\n        // rigid is inherited from Enemy and is initialized in Enemy.Awake()\\n        rigid.velocity = directions[facing] * speed;\\n    }\\n\\n    void DecideDirection()\\n    {                                                 // d\\n        facing = Random.Range(0, 4);\\n        timeNextDecision = Time.time + Random.Range(timeThinkMin, timeThinkMax);\\n    }\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {\\n        return facing;\\n    }\\n\\n    public bool moving { get { return true; } }                            // d\\n\\n    public float GetSpeed()\\n    {\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n}\\n\", \"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/SwordController.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class SwordController : MonoBehaviour\\n{\\n    private GameObject sword;\\n    private Dray dray;\\n\\n    void Start()\\n    {\\n        sword = transform.Find(\\\"Sword\\\").gameObject;                          // a\\n        dray = transform.parent.GetComponent<Dray>();\\n        // Deactivate the sword\\n        sword.SetActive(false);                                              // b\\n    }\\n\\n    void Update()\\n    {\\n        transform.rotation = Quaternion.Euler(0, 0, 90 * dray.facing);       // c\\n        sword.SetActive(dray.mode == Dray.eMode.attack);                     // d\\n    }\\n}\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n\\n    private BoxCollider bColl;                                           // a\\n\\n    void Awake()\\n    {\\n        bColl = GetComponent<BoxCollider>();                                 // a\\n    }\\n\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y); \\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum];\\n\\n        SetCollider();                                                       // b\\n    }\\n\\n    // Arrange the collider for this tile\\n    void SetCollider()\\n    {\\n        // Collider info is pulled from DelverCollisions.txt\\n        bColl.enabled = true;\\n        char c = TileCamera.COLLISIONS[tileNum];                             // c\\n        switch (c)\\n        {\\n            case \'S\': // Whole\\n                bColl.center = Vector3.zero;\\n                bColl.size = Vector3.one;\\n                break;\\n            case \'W\': // Top\\n                bColl.center = new Vector3(0, 0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'A\': // Left\\n                bColl.center = new Vector3(-0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n            case \'D\': // Right\\n                bColl.center = new Vector3(0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n\\n            // vvvvvvvv-------- These are optional --------vvvvvvvv          // d\\n            case \'Q\': // Top, Left\\n                bColl.center = new Vector3(-0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'E\': // Top, Right\\n                bColl.center = new Vector3(0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'Z\': // Bottom, left\\n                bColl.center = new Vector3(-0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'X\': // Bottom\\n                bColl.center = new Vector3(0, -0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'C\': // Bottom, Right\\n                bColl.center = new Vector3(0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            // ^^^^^^^^-------- These are optional --------^^^^^^^^          // d\\n\\n            default: // Anything else: _, |, etc.                            // e\\n                bColl.enabled = false;\\n                break;\\n        }\\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    static public string COLLISIONS;                                  // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n\\n    void Awake()\\n    {\\n        COLLISIONS = Utils.RemoveLineEndings(mapCollisions.text);          // b\\n        LoadMap();\\n    }\\n\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}, \"11 - Unlocking Doors\": {\"__Scripts/CamFollowDray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class CamFollowDray : MonoBehaviour\\n{\\n    static public bool TRANSITIONING = false;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public InRoom drayInRm;                                            // a\\n    public float transTime = 0.5f;\\n\\n    private Vector3 p0, p1;\\n\\n    private InRoom inRm;                                                // b\\n    private float transStart;\\n\\n    void Awake()\\n    {\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    void Update()\\n    {\\n        if (TRANSITIONING)\\n        {                                                 // c\\n            float u = (Time.time - transStart) / transTime;\\n            if (u >= 1)\\n            {\\n                u = 1;\\n                TRANSITIONING = false;\\n            }\\n            transform.position = (1 - u) * p0 + u * p1;\\n        }\\n        else\\n        {                                                             // d\\n            if (drayInRm.roomNum != inRm.roomNum)\\n            {\\n                TransitionTo(drayInRm.roomNum);\\n            }\\n        }\\n    }\\n\\n    void TransitionTo(Vector2 rm)\\n    {                                        // e\\n        p0 = transform.position;\\n        inRm.roomNum = rm;\\n        p1 = transform.position + (Vector3.back * 10);\\n        transform.position = p0;\\n\\n        transStart = Time.time;\\n        TRANSITIONING = true;\\n    }\\n}\\n\", \"__Scripts/Dray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Dray : MonoBehaviour, IFacingMover, IKeyMaster\\n{\\n    public enum eMode { idle, move, attack, transition }                     // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float speed = 5;\\n    public float attackDuration = 0.25f;// Number of seconds to attack\\n    public float attackDelay = 0.5f;    // Delay between attacks \\n    public float transitionDelay = 0.5f;// Room transition delay  // a\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int dirHeld = -1; // Direction of the held movement key\\n    public int facing = 1;   // Direction Dray is facing \\n    public eMode mode = eMode.idle;                                // a\\n    public int numKeys = 0;                                     // b\\n\\n    private float timeAtkDone = 0;                                  // b\\n    private float timeAtkNext = 0;                                  // c;    \\n    private float transitionDone = 0;                              // a\\n    private Vector2 transitionPos;\\n\\n\\n\\n    private Rigidbody   rigid;\\n    private Animator    anim;                                            // a\\n    private InRoom      inRm;                                            // b\\n\\n\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };             // a\\n\\n    private KeyCode[] keys = new KeyCode[] { KeyCode.RightArrow,\\n        KeyCode.UpArrow, KeyCode.LeftArrow, KeyCode.DownArrow };             // a\\n\\n\\n    void Awake()\\n    {\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();                                     // a\\n        inRm = GetComponent<InRoom>();                                       // b\\n    }\\n\\n    void Update()\\n    {\\n        if (mode == eMode.transition)\\n        {                                    // b\\n            rigid.velocity = Vector3.zero;\\n            anim.speed = 0;\\n            roomPos = transitionPos;  // Keeps Dray in place\\n            if (Time.time < transitionDone) return;\\n            // The following line is only reached if Time.time >= transitionDone\\n            mode = eMode.idle;\\n        }\\n\\n        //Handle Keyboard Input and manage eDrayModes\\n        dirHeld = -1;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (Input.GetKey(keys[i])) dirHeld = i;\\n        }\\n\\n        // Pressing the attack button(s)\\n        if (Input.GetKeyDown(KeyCode.Z) && Time.time >= timeAtkNext)\\n        {       // a\\n            mode = eMode.attack;\\n            timeAtkDone = Time.time + attackDuration;\\n            timeAtkNext = Time.time + attackDelay;\\n        }\\n\\n        // Finishing the attack when it\'s over\\n        if (Time.time >= timeAtkDone)\\n        {                                      // b\\n            mode = eMode.idle;\\n        }\\n\\n        // Choosing the proper mode if we\'re not attacking\\n        if (mode != eMode.attack)\\n        {                                          // c\\n            if (dirHeld == -1)\\n            {\\n                mode = eMode.idle;\\n            }\\n            else\\n            {\\n                facing = dirHeld;                                            // d\\n                mode = eMode.move;\\n            }\\n        }\\n\\n        //Act on the current mode\\n        Vector3 vel = Vector3.zero;\\n        switch (mode)\\n        {                                                      // e\\n            case eMode.attack:\\n                anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.idle:\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.move:\\n                vel = directions[dirHeld];\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 1;\\n                break;\\n        }\\n\\n        rigid.velocity = vel * speed;\\n\\n    }\\n\\n\\n    void LateUpdate()\\n    {\\n        // Get the half-grid location of this GameObject\\n        Vector2 rPos = GetRoomPosOnGrid(0.5f);  // Forces half-grid        // c\\n\\n        // Check to see whether we\'re in a Door tile\\n        int doorNum;\\n        for (doorNum = 0; doorNum < 4; doorNum++)\\n        {\\n            if (rPos == InRoom.DOORS[doorNum])\\n            {\\n                break;                                                       // d\\n            }\\n        }\\n\\n        if (doorNum > 3 || doorNum != facing) return;                      // e\\n\\n        // Move to the next room\\n        Vector2 rm = roomNum;\\n        switch (doorNum)\\n        {                                                   // f\\n            case 0:\\n                rm.x += 1;\\n                break;\\n            case 1:\\n                rm.y += 1;\\n                break;\\n            case 2:\\n                rm.x -= 1;\\n                break;\\n            case 3:\\n                rm.y -= 1;\\n                break;\\n        }\\n\\n        // Make sure that the rm we want to jump to is valid\\n        if (rm.x >= 0 && rm.x <= InRoom.MAX_RM_X)\\n        {                          // g\\n            if (rm.y >= 0 && rm.y <= InRoom.MAX_RM_Y)\\n            {\\n                roomNum = rm;\\n                transitionPos = InRoom.DOORS[(doorNum + 2) % 4];             // h\\n                roomPos = transitionPos;\\n                mode = eMode.transition;                                     // i\\n                transitionDone = Time.time + transitionDelay;\\n            }\\n        }\\n    }\\n\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {                                                 // c\\n        return facing;\\n    }\\n\\n    public bool moving\\n    {                                                     // d\\n        get\\n        {\\n            return (mode == eMode.move);\\n        }\\n    }\\n\\n    public float GetSpeed()\\n    {                                                // e\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {                                                 // f\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n\\n\\n    // Implementation of IKeyMaster\\n    public int keyCount\\n    {                                                    // d\\n        get { return numKeys; }\\n        set { numKeys = value; }\\n    }\\n}\\n\", \"__Scripts/Enemy.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Enemy : MonoBehaviour\\n{\\n    protected static Vector3[] directions = new Vector3[] {                 // a\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };\\n\\n    [Header(\\\"Set in Inspector: Enemy\\\")]                                      // b\\n    public float maxHealth = 1;                               // c\\n\\n    [Header(\\\"Set Dynamically: Enemy\\\")]\\n    public float health;                                      // c\\n\\n    protected Animator anim;                                        // c\\n    protected Rigidbody rigid;                                       // c\\n    protected SpriteRenderer sRend;                                       // c\\n\\n    protected virtual void Awake()\\n    {                                         // d\\n        health = maxHealth;\\n        anim = GetComponent<Animator>();\\n        rigid = GetComponent<Rigidbody>();\\n        sRend = GetComponent<SpriteRenderer>();\\n    }\\n}\\n\", \"__Scripts/GateKeeper.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GateKeeper : MonoBehaviour\\n{\\n    // These consts are based on the default DelverTiles image.\\n    // If you rearrange DelverTiles you may need to change it!\\n    //Locked Door tileNums                                           // a\\n    const int lockedR = 95;\\n    const int lockedUR = 81;\\n    const int lockedUL = 80;\\n    const int lockedL = 100;\\n    const int lockedDL = 101;\\n    const int lockedDR = 102;\\n\\n    //Open Door tileNums\\n    const int openR = 48;\\n    const int openUR = 93;\\n    const int openUL = 92;\\n    const int openL = 51;\\n    const int openDL = 26;\\n    const int openDR = 27;\\n\\n    private IKeyMaster keys;\\n\\n    void Awake()\\n    {\\n        keys = GetComponent<IKeyMaster>();\\n    }\\n\\n    void OnCollisionStay(Collision coll)\\n    {                                 // b\\n        // No keys, no need to run\\n        if (keys.keyCount < 1) return;\\n\\n        // Only worry about hitting tiles\\n        Tile ti = coll.gameObject.GetComponent<Tile>();\\n        if (ti == null) return;\\n\\n        // Only open if Dray is facing the door (avoid accidental key use)\\n        int facing = keys.GetFacing();\\n        // Check whether it\'s a door tile\\n        Tile ti2;\\n        switch (ti.tileNum)\\n        {                                                // c\\n            case lockedR:\\n                if (facing != 0) return;                                     // d\\n                ti.SetTile(ti.x, ti.y, openR);\\n                break;\\n\\n            case lockedUR:\\n                if (facing != 1) return;\\n                ti.SetTile(ti.x, ti.y, openUR);\\n                ti2 = TileCamera.TILES[ti.x - 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openUL);\\n                break;\\n\\n            case lockedUL:\\n                if (facing != 1) return;\\n                ti.SetTile(ti.x, ti.y, openUL);\\n                ti2 = TileCamera.TILES[ti.x + 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openUR);\\n                break;\\n\\n            case lockedL:\\n                if (facing != 2) return;\\n                ti.SetTile(ti.x, ti.y, openL);\\n                break;\\n\\n            case lockedDL:\\n                if (facing != 3) return;\\n                ti.SetTile(ti.x, ti.y, openDL);\\n                ti2 = TileCamera.TILES[ti.x + 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openDR);\\n                break;\\n\\n            case lockedDR:\\n                if (facing != 3) return;\\n                ti.SetTile(ti.x, ti.y, openDR);\\n                ti2 = TileCamera.TILES[ti.x - 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openDL);\\n                break;\\n\\n            default:\\n                return; // Return and avoid key decrement\\n        }\\n\\n        keys.keyCount--;\\n    }\\n}\", \"__Scripts/GridMove.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GridMove : MonoBehaviour\\n{\\n    private IFacingMover mover;\\n\\n    void Awake()\\n    {\\n        mover = GetComponent<IFacingMover>();                                // a\\n    }\\n\\n    void FixedUpdate()\\n    {\\n        if (!mover.moving) return; // If not moving, nothing to do here\\n        int facing = mover.GetFacing();\\n\\n        // If we are moving in a direction, align to the grid\\n        // First, get the grid location\\n        Vector2 rPos = mover.roomPos;\\n        Vector2 rPosGrid = mover.GetRoomPosOnGrid();\\n        // This relies on IFacingMover (which uses InRoom) to choose grid spacing\\n\\n        // Then move towards the grid line\\n        float delta = 0;\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            delta = rPosGrid.y - rPos.y;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            delta = rPosGrid.x - rPos.x;\\n        }\\n        if (delta == 0) return; // Already aligned to the grid\\n\\n        float move = mover.GetSpeed() * Time.fixedDeltaTime;\\n        move = Mathf.Min(move, Mathf.Abs(delta));\\n        if (delta < 0) move = -move;\\n\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            rPos.y += move;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            rPos.x += move;\\n        }\\n\\n        mover.roomPos = rPos;\\n    }\\n}\\n\", \"__Scripts/IFacingMover.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IFacingMover\\n{                                              // a\\n    int GetFacing();                                                         // b\\n    bool moving { get; }                                                     // c\\n    float GetSpeed();\\n    float gridMult { get; }                                                  // d\\n    Vector2 roomPos { get; set; }                                            // e\\n    Vector2 roomNum { get; set; }\\n    Vector2 GetRoomPosOnGrid(float mult = -1);                             // f\\n}\", \"__Scripts/IKeyMaster.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IKeyMaster\\n{\\n    int keyCount { get; set; }                                               // a\\n    int GetFacing();                                                         // b\\n}\\n\", \"__Scripts/InRoom.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class InRoom : MonoBehaviour\\n{\\n    static public float ROOM_W = 16;                                     // a\\n    static public float ROOM_H = 11;\\n    static public float WALL_T = 2;\\n\\n    static public int MAX_RM_X = 9;                                    // a\\n    static public int MAX_RM_Y = 9;\\n\\n    static public Vector2[] DOORS = new Vector2[] {                          // b\\n        new Vector2(14,   5),\\n        new Vector2(7.5f, 9),\\n        new Vector2(1,    5),\\n        new Vector2(7.5f, 1)\\n    };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public bool keepInRoom = true;\\n    public float gridMult = 1;                                    // a\\n\\n\\n    void LateUpdate()\\n    {\\n        if (keepInRoom)\\n        {                                                    // b\\n            Vector2 rPos = roomPos;                                          // c\\n            rPos.x = Mathf.Clamp(rPos.x, WALL_T, ROOM_W - 1 - WALL_T);\\n            rPos.y = Mathf.Clamp(rPos.y, WALL_T, ROOM_H - 1 - WALL_T);\\n            roomPos = rPos;                                                  // d\\n        }\\n    }\\n\\n    // Where is this character in local room coordinates?\\n    public Vector2 roomPos\\n    {                                        // b\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x %= ROOM_W;\\n            tPos.y %= ROOM_H;\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rm = roomNum;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            rm += value;\\n            transform.position = rm;\\n        }\\n    }\\n\\n    // Which room is this character in?\\n    public Vector2 roomNum\\n    {                                        // c\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x = Mathf.Floor(tPos.x / ROOM_W);\\n            tPos.y = Mathf.Floor(tPos.y / ROOM_H);\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rPos = roomPos;\\n            Vector2 rm = value;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            transform.position = rm + rPos;\\n        }\\n    }\\n\\n    // What is the closest grid location to this character?\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        if (mult == -1)\\n        {\\n            mult = gridMult;\\n        }\\n        Vector2 rPos = roomPos;\\n        rPos /= mult;\\n        rPos.x = Mathf.Round(rPos.x);\\n        rPos.y = Mathf.Round(rPos.y);\\n        rPos *= mult;\\n        return rPos;\\n    }\\n\\n}\", \"__Scripts/Skeletos.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Skeletos : Enemy, IFacingMover\\n{                                              // a\\n    [Header(\\\"Set in Inspector: Skeletos\\\")]                                   // b\\n    public int speed = 2;\\n    public float timeThinkMin = 1f;\\n    public float timeThinkMax = 4f;\\n\\n    [Header(\\\"Set Dynamically: Skeletos\\\")]\\n    public int facing = 0;\\n    public float timeNextDecision = 0;\\n\\n    private InRoom inRm;                                                    // b\\n\\n    protected override void Awake()\\n    {                                       // c\\n        base.Awake();\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    void Update()\\n    {\\n        if (Time.time >= timeNextDecision)\\n        {                                 // c\\n            DecideDirection();\\n        }\\n        // rigid is inherited from Enemy and is initialized in Enemy.Awake()\\n        rigid.velocity = directions[facing] * speed;\\n    }\\n\\n    void DecideDirection()\\n    {                                                 // d\\n        facing = Random.Range(0, 4);\\n        timeNextDecision = Time.time + Random.Range(timeThinkMin, timeThinkMax);\\n    }\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {\\n        return facing;\\n    }\\n\\n    public bool moving { get { return true; } }                            // d\\n\\n    public float GetSpeed()\\n    {\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n}\\n\", \"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/SwordController.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class SwordController : MonoBehaviour\\n{\\n    private GameObject sword;\\n    private Dray dray;\\n\\n    void Start()\\n    {\\n        sword = transform.Find(\\\"Sword\\\").gameObject;                          // a\\n        dray = transform.parent.GetComponent<Dray>();\\n        // Deactivate the sword\\n        sword.SetActive(false);                                              // b\\n    }\\n\\n    void Update()\\n    {\\n        transform.rotation = Quaternion.Euler(0, 0, 90 * dray.facing);       // c\\n        sword.SetActive(dray.mode == Dray.eMode.attack);                     // d\\n    }\\n}\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n\\n    private BoxCollider bColl;                                           // a\\n\\n    void Awake()\\n    {\\n        bColl = GetComponent<BoxCollider>();                                 // a\\n    }\\n\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y);\\n        }\\n        else\\n        {\\n            TileCamera.SET_MAP(x, y, eTileNum); // Replace if non-default tileNum\\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum];\\n\\n        SetCollider();                                                       // b\\n    }\\n\\n    // Arrange the collider for this tile\\n    void SetCollider()\\n    {\\n        // Collider info is pulled from DelverCollisions.txt\\n        bColl.enabled = true;\\n        char c = TileCamera.COLLISIONS[tileNum];                             // c\\n        switch (c)\\n        {\\n            case \'S\': // Whole\\n                bColl.center = Vector3.zero;\\n                bColl.size = Vector3.one;\\n                break;\\n            case \'W\': // Top\\n                bColl.center = new Vector3(0, 0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'A\': // Left\\n                bColl.center = new Vector3(-0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n            case \'D\': // Right\\n                bColl.center = new Vector3(0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n\\n            // vvvvvvvv-------- These are optional --------vvvvvvvv          // d\\n            case \'Q\': // Top, Left\\n                bColl.center = new Vector3(-0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'E\': // Top, Right\\n                bColl.center = new Vector3(0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'Z\': // Bottom, left\\n                bColl.center = new Vector3(-0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'X\': // Bottom\\n                bColl.center = new Vector3(0, -0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'C\': // Bottom, Right\\n                bColl.center = new Vector3(0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            // ^^^^^^^^-------- These are optional --------^^^^^^^^          // d\\n\\n            default: // Anything else: _, |, etc.                            // e\\n                bColl.enabled = false;\\n                break;\\n        }\\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    static public string COLLISIONS;                                  // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n\\n    void Awake()\\n    {\\n        COLLISIONS = Utils.RemoveLineEndings(mapCollisions.text);          // b\\n        LoadMap();\\n    }\\n\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}, \"12 - Adding GUI to Track Key Count and Health\": {\"__Scripts/CamFollowDray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class CamFollowDray : MonoBehaviour\\n{\\n    static public bool TRANSITIONING = false;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public InRoom drayInRm;                                            // a\\n    public float transTime = 0.5f;\\n\\n    private Vector3 p0, p1;\\n\\n    private InRoom inRm;                                                // b\\n    private float transStart;\\n\\n    void Awake()\\n    {\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    void Update()\\n    {\\n        if (TRANSITIONING)\\n        {                                                 // c\\n            float u = (Time.time - transStart) / transTime;\\n            if (u >= 1)\\n            {\\n                u = 1;\\n                TRANSITIONING = false;\\n            }\\n            transform.position = (1 - u) * p0 + u * p1;\\n        }\\n        else\\n        {                                                             // d\\n            if (drayInRm.roomNum != inRm.roomNum)\\n            {\\n                TransitionTo(drayInRm.roomNum);\\n            }\\n        }\\n    }\\n\\n    void TransitionTo(Vector2 rm)\\n    {                                        // e\\n        p0 = transform.position;\\n        inRm.roomNum = rm;\\n        p1 = transform.position + (Vector3.back * 10);\\n        transform.position = p0;\\n\\n        transStart = Time.time;\\n        TRANSITIONING = true;\\n    }\\n}\\n\", \"__Scripts/Dray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Dray : MonoBehaviour, IFacingMover, IKeyMaster\\n{\\n    public enum eMode { idle, move, attack, transition }                     // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float speed = 5;\\n    public float attackDuration = 0.25f;// Number of seconds to attack\\n    public float attackDelay = 0.5f;    // Delay between attacks \\n    public float transitionDelay = 0.5f;// Room transition delay  // a\\n    public int maxHealth = 10;                                  // a\\n\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int dirHeld = -1; // Direction of the held movement key\\n    public int facing = 1;   // Direction Dray is facing \\n    public eMode mode = eMode.idle;                                // a\\n    public int numKeys = 0;                                     // b\\n\\n    [SerializeField]                                                         // b\\n    private int _health;\\n\\n    public int health\\n    {                                                      // c\\n        get { return _health; }\\n        set { _health = value; }\\n    }\\n\\n    private float timeAtkDone = 0;                                  // b\\n    private float timeAtkNext = 0;                                  // c;    \\n    private float transitionDone = 0;                              // a\\n    private Vector2 transitionPos;\\n\\n\\n\\n    private Rigidbody   rigid;\\n    private Animator    anim;                                            // a\\n    private InRoom      inRm;                                            // b\\n\\n\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };             // a\\n\\n    private KeyCode[] keys = new KeyCode[] { KeyCode.RightArrow,\\n        KeyCode.UpArrow, KeyCode.LeftArrow, KeyCode.DownArrow };             // a\\n\\n\\n    void Awake()\\n    {\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();                                     // a\\n        inRm = GetComponent<InRoom>();                                       // b\\n        health = maxHealth;                                                  // d\\n    }\\n\\n    void Update()\\n    {\\n        if (mode == eMode.transition)\\n        {                                    // b\\n            rigid.velocity = Vector3.zero;\\n            anim.speed = 0;\\n            roomPos = transitionPos;  // Keeps Dray in place\\n            if (Time.time < transitionDone) return;\\n            // The following line is only reached if Time.time >= transitionDone\\n            mode = eMode.idle;\\n        }\\n\\n        //Handle Keyboard Input and manage eDrayModes\\n        dirHeld = -1;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (Input.GetKey(keys[i])) dirHeld = i;\\n        }\\n\\n        // Pressing the attack button(s)\\n        if (Input.GetKeyDown(KeyCode.Z) && Time.time >= timeAtkNext)\\n        {       // a\\n            mode = eMode.attack;\\n            timeAtkDone = Time.time + attackDuration;\\n            timeAtkNext = Time.time + attackDelay;\\n        }\\n\\n        // Finishing the attack when it\'s over\\n        if (Time.time >= timeAtkDone)\\n        {                                      // b\\n            mode = eMode.idle;\\n        }\\n\\n        // Choosing the proper mode if we\'re not attacking\\n        if (mode != eMode.attack)\\n        {                                          // c\\n            if (dirHeld == -1)\\n            {\\n                mode = eMode.idle;\\n            }\\n            else\\n            {\\n                facing = dirHeld;                                            // d\\n                mode = eMode.move;\\n            }\\n        }\\n\\n        //Act on the current mode\\n        Vector3 vel = Vector3.zero;\\n        switch (mode)\\n        {                                                      // e\\n            case eMode.attack:\\n                anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.idle:\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.move:\\n                vel = directions[dirHeld];\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 1;\\n                break;\\n        }\\n\\n        rigid.velocity = vel * speed;\\n\\n    }\\n\\n\\n    void LateUpdate()\\n    {\\n        // Get the half-grid location of this GameObject\\n        Vector2 rPos = GetRoomPosOnGrid(0.5f);  // Forces half-grid        // c\\n\\n        // Check to see whether we\'re in a Door tile\\n        int doorNum;\\n        for (doorNum = 0; doorNum < 4; doorNum++)\\n        {\\n            if (rPos == InRoom.DOORS[doorNum])\\n            {\\n                break;                                                       // d\\n            }\\n        }\\n\\n        if (doorNum > 3 || doorNum != facing) return;                      // e\\n\\n        // Move to the next room\\n        Vector2 rm = roomNum;\\n        switch (doorNum)\\n        {                                                   // f\\n            case 0:\\n                rm.x += 1;\\n                break;\\n            case 1:\\n                rm.y += 1;\\n                break;\\n            case 2:\\n                rm.x -= 1;\\n                break;\\n            case 3:\\n                rm.y -= 1;\\n                break;\\n        }\\n\\n        // Make sure that the rm we want to jump to is valid\\n        if (rm.x >= 0 && rm.x <= InRoom.MAX_RM_X)\\n        {                          // g\\n            if (rm.y >= 0 && rm.y <= InRoom.MAX_RM_Y)\\n            {\\n                roomNum = rm;\\n                transitionPos = InRoom.DOORS[(doorNum + 2) % 4];             // h\\n                roomPos = transitionPos;\\n                mode = eMode.transition;                                     // i\\n                transitionDone = Time.time + transitionDelay;\\n            }\\n        }\\n    }\\n\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {                                                 // c\\n        return facing;\\n    }\\n\\n    public bool moving\\n    {                                                     // d\\n        get\\n        {\\n            return (mode == eMode.move);\\n        }\\n    }\\n\\n    public float GetSpeed()\\n    {                                                // e\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {                                                 // f\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n\\n\\n    // Implementation of IKeyMaster\\n    public int keyCount\\n    {                                                    // d\\n        get { return numKeys; }\\n        set { numKeys = value; }\\n    }\\n}\\n\", \"__Scripts/Enemy.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Enemy : MonoBehaviour\\n{\\n    protected static Vector3[] directions = new Vector3[] {                 // a\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };\\n\\n    [Header(\\\"Set in Inspector: Enemy\\\")]                                      // b\\n    public float maxHealth = 1;                               // c\\n\\n    [Header(\\\"Set Dynamically: Enemy\\\")]\\n    public float health;                                      // c\\n\\n    protected Animator anim;                                        // c\\n    protected Rigidbody rigid;                                       // c\\n    protected SpriteRenderer sRend;                                       // c\\n\\n    protected virtual void Awake()\\n    {                                         // d\\n        health = maxHealth;\\n        anim = GetComponent<Animator>();\\n        rigid = GetComponent<Rigidbody>();\\n        sRend = GetComponent<SpriteRenderer>();\\n    }\\n}\\n\", \"__Scripts/GateKeeper.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GateKeeper : MonoBehaviour\\n{\\n    // These consts are based on the default DelverTiles image.\\n    // If you rearrange DelverTiles you may need to change it!\\n    //Locked Door tileNums                                           // a\\n    const int lockedR = 95;\\n    const int lockedUR = 81;\\n    const int lockedUL = 80;\\n    const int lockedL = 100;\\n    const int lockedDL = 101;\\n    const int lockedDR = 102;\\n\\n    //Open Door tileNums\\n    const int openR = 48;\\n    const int openUR = 93;\\n    const int openUL = 92;\\n    const int openL = 51;\\n    const int openDL = 26;\\n    const int openDR = 27;\\n\\n    private IKeyMaster keys;\\n\\n    void Awake()\\n    {\\n        keys = GetComponent<IKeyMaster>();\\n    }\\n\\n    void OnCollisionStay(Collision coll)\\n    {                                 // b\\n        // No keys, no need to run\\n        if (keys.keyCount < 1) return;\\n\\n        // Only worry about hitting tiles\\n        Tile ti = coll.gameObject.GetComponent<Tile>();\\n        if (ti == null) return;\\n\\n        // Only open if Dray is facing the door (avoid accidental key use)\\n        int facing = keys.GetFacing();\\n        // Check whether it\'s a door tile\\n        Tile ti2;\\n        switch (ti.tileNum)\\n        {                                                // c\\n            case lockedR:\\n                if (facing != 0) return;                                     // d\\n                ti.SetTile(ti.x, ti.y, openR);\\n                break;\\n\\n            case lockedUR:\\n                if (facing != 1) return;\\n                ti.SetTile(ti.x, ti.y, openUR);\\n                ti2 = TileCamera.TILES[ti.x - 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openUL);\\n                break;\\n\\n            case lockedUL:\\n                if (facing != 1) return;\\n                ti.SetTile(ti.x, ti.y, openUL);\\n                ti2 = TileCamera.TILES[ti.x + 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openUR);\\n                break;\\n\\n            case lockedL:\\n                if (facing != 2) return;\\n                ti.SetTile(ti.x, ti.y, openL);\\n                break;\\n\\n            case lockedDL:\\n                if (facing != 3) return;\\n                ti.SetTile(ti.x, ti.y, openDL);\\n                ti2 = TileCamera.TILES[ti.x + 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openDR);\\n                break;\\n\\n            case lockedDR:\\n                if (facing != 3) return;\\n                ti.SetTile(ti.x, ti.y, openDR);\\n                ti2 = TileCamera.TILES[ti.x - 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openDL);\\n                break;\\n\\n            default:\\n                return; // Return and avoid key decrement\\n        }\\n\\n        keys.keyCount--;\\n    }\\n}\", \"__Scripts/GridMove.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GridMove : MonoBehaviour\\n{\\n    private IFacingMover mover;\\n\\n    void Awake()\\n    {\\n        mover = GetComponent<IFacingMover>();                                // a\\n    }\\n\\n    void FixedUpdate()\\n    {\\n        if (!mover.moving) return; // If not moving, nothing to do here\\n        int facing = mover.GetFacing();\\n\\n        // If we are moving in a direction, align to the grid\\n        // First, get the grid location\\n        Vector2 rPos = mover.roomPos;\\n        Vector2 rPosGrid = mover.GetRoomPosOnGrid();\\n        // This relies on IFacingMover (which uses InRoom) to choose grid spacing\\n\\n        // Then move towards the grid line\\n        float delta = 0;\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            delta = rPosGrid.y - rPos.y;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            delta = rPosGrid.x - rPos.x;\\n        }\\n        if (delta == 0) return; // Already aligned to the grid\\n\\n        float move = mover.GetSpeed() * Time.fixedDeltaTime;\\n        move = Mathf.Min(move, Mathf.Abs(delta));\\n        if (delta < 0) move = -move;\\n\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            rPos.y += move;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            rPos.x += move;\\n        }\\n\\n        mover.roomPos = rPos;\\n    }\\n}\\n\", \"__Scripts/GuiPanel.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\npublic class GuiPanel : MonoBehaviour\\n{\\n    [Header(\\\"Set in Inspector\\\")]\\n    public Dray dray;\\n    public Sprite healthEmpty;\\n    public Sprite healthHalf;\\n    public Sprite healthFull;\\n\\n    Text keyCountText;\\n    List<Image> healthImages;\\n\\n    void Start()\\n    {\\n        // Key Count\\n        Transform trans = transform.Find(\\\"Key Count\\\");                       // a\\n        keyCountText = trans.GetComponent<Text>();\\n\\n        // Health Icons\\n        Transform healthPanel = transform.Find(\\\"Health Panel\\\");\\n        healthImages = new List<Image>();\\n        if (healthPanel != null)\\n        {                                           // b\\n            for (int i = 0; i < 20; i++)\\n            {\\n                trans = healthPanel.Find(\\\"H_\\\" + i);\\n                if (trans == null) break;\\n                healthImages.Add(trans.GetComponent<Image>());\\n            }\\n        }\\n    }\\n\\n    void Update()\\n    {\\n        // Show keys                                \\n        keyCountText.text = dray.numKeys.ToString();                         // c\\n\\n        // Show health\\n        int health = dray.health;\\n        for (int i = 0; i < healthImages.Count; i++)\\n        {                           // d\\n            if (health > 1)\\n            {\\n                healthImages[i].sprite = healthFull;\\n            }\\n            else if (health == 1)\\n            {\\n                healthImages[i].sprite = healthHalf;\\n            }\\n            else\\n            {\\n                healthImages[i].sprite = healthEmpty;\\n            }\\n            health -= 2;\\n        }\\n    }\\n}\\n\", \"__Scripts/IFacingMover.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IFacingMover\\n{                                              // a\\n    int GetFacing();                                                         // b\\n    bool moving { get; }                                                     // c\\n    float GetSpeed();\\n    float gridMult { get; }                                                  // d\\n    Vector2 roomPos { get; set; }                                            // e\\n    Vector2 roomNum { get; set; }\\n    Vector2 GetRoomPosOnGrid(float mult = -1);                             // f\\n}\", \"__Scripts/IKeyMaster.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IKeyMaster\\n{\\n    int keyCount { get; set; }                                               // a\\n    int GetFacing();                                                         // b\\n}\\n\", \"__Scripts/InRoom.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class InRoom : MonoBehaviour\\n{\\n    static public float ROOM_W = 16;                                     // a\\n    static public float ROOM_H = 11;\\n    static public float WALL_T = 2;\\n\\n    static public int MAX_RM_X = 9;                                    // a\\n    static public int MAX_RM_Y = 9;\\n\\n    static public Vector2[] DOORS = new Vector2[] {                          // b\\n        new Vector2(14,   5),\\n        new Vector2(7.5f, 9),\\n        new Vector2(1,    5),\\n        new Vector2(7.5f, 1)\\n    };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public bool keepInRoom = true;\\n    public float gridMult = 1;                                    // a\\n\\n\\n    void LateUpdate()\\n    {\\n        if (keepInRoom)\\n        {                                                    // b\\n            Vector2 rPos = roomPos;                                          // c\\n            rPos.x = Mathf.Clamp(rPos.x, WALL_T, ROOM_W - 1 - WALL_T);\\n            rPos.y = Mathf.Clamp(rPos.y, WALL_T, ROOM_H - 1 - WALL_T);\\n            roomPos = rPos;                                                  // d\\n        }\\n    }\\n\\n    // Where is this character in local room coordinates?\\n    public Vector2 roomPos\\n    {                                        // b\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x %= ROOM_W;\\n            tPos.y %= ROOM_H;\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rm = roomNum;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            rm += value;\\n            transform.position = rm;\\n        }\\n    }\\n\\n    // Which room is this character in?\\n    public Vector2 roomNum\\n    {                                        // c\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x = Mathf.Floor(tPos.x / ROOM_W);\\n            tPos.y = Mathf.Floor(tPos.y / ROOM_H);\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rPos = roomPos;\\n            Vector2 rm = value;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            transform.position = rm + rPos;\\n        }\\n    }\\n\\n    // What is the closest grid location to this character?\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        if (mult == -1)\\n        {\\n            mult = gridMult;\\n        }\\n        Vector2 rPos = roomPos;\\n        rPos /= mult;\\n        rPos.x = Mathf.Round(rPos.x);\\n        rPos.y = Mathf.Round(rPos.y);\\n        rPos *= mult;\\n        return rPos;\\n    }\\n\\n}\", \"__Scripts/Skeletos.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Skeletos : Enemy, IFacingMover\\n{                                              // a\\n    [Header(\\\"Set in Inspector: Skeletos\\\")]                                   // b\\n    public int speed = 2;\\n    public float timeThinkMin = 1f;\\n    public float timeThinkMax = 4f;\\n\\n    [Header(\\\"Set Dynamically: Skeletos\\\")]\\n    public int facing = 0;\\n    public float timeNextDecision = 0;\\n\\n    private InRoom inRm;                                                    // b\\n\\n    protected override void Awake()\\n    {                                       // c\\n        base.Awake();\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    void Update()\\n    {\\n        if (Time.time >= timeNextDecision)\\n        {                                 // c\\n            DecideDirection();\\n        }\\n        // rigid is inherited from Enemy and is initialized in Enemy.Awake()\\n        rigid.velocity = directions[facing] * speed;\\n    }\\n\\n    void DecideDirection()\\n    {                                                 // d\\n        facing = Random.Range(0, 4);\\n        timeNextDecision = Time.time + Random.Range(timeThinkMin, timeThinkMax);\\n    }\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {\\n        return facing;\\n    }\\n\\n    public bool moving { get { return true; } }                            // d\\n\\n    public float GetSpeed()\\n    {\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n}\\n\", \"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/SwordController.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class SwordController : MonoBehaviour\\n{\\n    private GameObject sword;\\n    private Dray dray;\\n\\n    void Start()\\n    {\\n        sword = transform.Find(\\\"Sword\\\").gameObject;                          // a\\n        dray = transform.parent.GetComponent<Dray>();\\n        // Deactivate the sword\\n        sword.SetActive(false);                                              // b\\n    }\\n\\n    void Update()\\n    {\\n        transform.rotation = Quaternion.Euler(0, 0, 90 * dray.facing);       // c\\n        sword.SetActive(dray.mode == Dray.eMode.attack);                     // d\\n    }\\n}\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n\\n    private BoxCollider bColl;                                           // a\\n\\n    void Awake()\\n    {\\n        bColl = GetComponent<BoxCollider>();                                 // a\\n    }\\n\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y);\\n        }\\n        else\\n        {\\n            TileCamera.SET_MAP(x, y, eTileNum); // Replace if non-default tileNum\\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum];\\n\\n        SetCollider();                                                       // b\\n    }\\n\\n    // Arrange the collider for this tile\\n    void SetCollider()\\n    {\\n        // Collider info is pulled from DelverCollisions.txt\\n        bColl.enabled = true;\\n        char c = TileCamera.COLLISIONS[tileNum];                             // c\\n        switch (c)\\n        {\\n            case \'S\': // Whole\\n                bColl.center = Vector3.zero;\\n                bColl.size = Vector3.one;\\n                break;\\n            case \'W\': // Top\\n                bColl.center = new Vector3(0, 0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'A\': // Left\\n                bColl.center = new Vector3(-0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n            case \'D\': // Right\\n                bColl.center = new Vector3(0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n\\n            // vvvvvvvv-------- These are optional --------vvvvvvvv          // d\\n            case \'Q\': // Top, Left\\n                bColl.center = new Vector3(-0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'E\': // Top, Right\\n                bColl.center = new Vector3(0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'Z\': // Bottom, left\\n                bColl.center = new Vector3(-0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'X\': // Bottom\\n                bColl.center = new Vector3(0, -0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'C\': // Bottom, Right\\n                bColl.center = new Vector3(0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            // ^^^^^^^^-------- These are optional --------^^^^^^^^          // d\\n\\n            default: // Anything else: _, |, etc.                            // e\\n                bColl.enabled = false;\\n                break;\\n        }\\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    static public string COLLISIONS;                                  // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n\\n    void Awake()\\n    {\\n        COLLISIONS = Utils.RemoveLineEndings(mapCollisions.text);          // b\\n        LoadMap();\\n    }\\n\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}, \"13 - Enabling Enemies to Damage Dray\": {\"__Scripts/CamFollowDray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class CamFollowDray : MonoBehaviour\\n{\\n    static public bool TRANSITIONING = false;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public InRoom drayInRm;                                            // a\\n    public float transTime = 0.5f;\\n\\n    private Vector3 p0, p1;\\n\\n    private InRoom inRm;                                                // b\\n    private float transStart;\\n\\n    void Awake()\\n    {\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    void Update()\\n    {\\n        if (TRANSITIONING)\\n        {                                                 // c\\n            float u = (Time.time - transStart) / transTime;\\n            if (u >= 1)\\n            {\\n                u = 1;\\n                TRANSITIONING = false;\\n            }\\n            transform.position = (1 - u) * p0 + u * p1;\\n        }\\n        else\\n        {                                                             // d\\n            if (drayInRm.roomNum != inRm.roomNum)\\n            {\\n                TransitionTo(drayInRm.roomNum);\\n            }\\n        }\\n    }\\n\\n    void TransitionTo(Vector2 rm)\\n    {                                        // e\\n        p0 = transform.position;\\n        inRm.roomNum = rm;\\n        p1 = transform.position + (Vector3.back * 10);\\n        transform.position = p0;\\n\\n        transStart = Time.time;\\n        TRANSITIONING = true;\\n    }\\n}\\n\", \"__Scripts/DamageEffect.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class DamageEffect : MonoBehaviour\\n{\\n    [Header(\\\"Set in Inspector\\\")]\\n    public int damage = 1;\\n    public bool knockback = true;\\n}\", \"__Scripts/Dray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Dray : MonoBehaviour, IFacingMover, IKeyMaster\\n{\\n    public enum eMode { idle, move, attack, transition, knockback }          // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float speed = 5;\\n    public float attackDuration = 0.25f;// Number of seconds to attack\\n    public float attackDelay = 0.5f;    // Delay between attacks \\n    public float transitionDelay = 0.5f;// Room transition delay  // a\\n    public int maxHealth = 10;                                  // a\\n    public float knockbackSpeed = 10;                             // b\\n    public float knockbackDuration = 0.25f;\\n    public float invincibleDuration = 0.5f;\\n\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int dirHeld = -1; // Direction of the held movement key\\n    public int facing = 1;   // Direction Dray is facing \\n    public eMode mode = eMode.idle;                                // a\\n    public int numKeys = 0;                                     // b\\n    public bool invincible = false;                              // c\\n\\n    [SerializeField]                                                         // b\\n    private int _health;\\n\\n    public int health\\n    {                                                      // c\\n        get { return _health; }\\n        set { _health = value; }\\n    }\\n\\n    private float timeAtkDone = 0;                                  // b\\n    private float timeAtkNext = 0;                                  // c;    \\n    private float transitionDone = 0;                              // a\\n    private Vector2 transitionPos;\\n    private float knockbackDone = 0;                               // d\\n    private float invincibleDone = 0;\\n    private Vector3 knockbackVel;\\n\\n    private SpriteRenderer sRend;                                           // e\\n    private Rigidbody   rigid;\\n    private Animator    anim;                                            // a\\n    private InRoom      inRm;                                            // b\\n\\n\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };             // a\\n\\n    private KeyCode[] keys = new KeyCode[] { KeyCode.RightArrow,\\n        KeyCode.UpArrow, KeyCode.LeftArrow, KeyCode.DownArrow };             // a\\n\\n\\n    void Awake()\\n    {\\n        sRend = GetComponent<SpriteRenderer>();                              // e\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();                                     // a\\n        inRm = GetComponent<InRoom>();                                       // b\\n        health = maxHealth;                                                  // d\\n    }\\n\\n    void Update()\\n    {\\n        // Check knockback and invincibility\\n        if (invincible && Time.time > invincibleDone) invincible = false;    // f\\n        sRend.color = invincible ? Color.red : Color.white;\\n        if (mode == eMode.knockback)\\n        {\\n            rigid.velocity = knockbackVel;\\n            if (Time.time < knockbackDone) return;\\n        }\\n\\n        if (mode == eMode.transition)\\n        {                                    // b\\n            rigid.velocity = Vector3.zero;\\n            anim.speed = 0;\\n            roomPos = transitionPos;  // Keeps Dray in place\\n            if (Time.time < transitionDone) return;\\n            // The following line is only reached if Time.time >= transitionDone\\n            mode = eMode.idle;\\n        }\\n\\n        //Handle Keyboard Input and manage eDrayModes\\n        dirHeld = -1;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (Input.GetKey(keys[i])) dirHeld = i;\\n        }\\n\\n        // Pressing the attack button(s)\\n        if (Input.GetKeyDown(KeyCode.Z) && Time.time >= timeAtkNext)\\n        {       // a\\n            mode = eMode.attack;\\n            timeAtkDone = Time.time + attackDuration;\\n            timeAtkNext = Time.time + attackDelay;\\n        }\\n\\n        // Finishing the attack when it\'s over\\n        if (Time.time >= timeAtkDone)\\n        {                                      // b\\n            mode = eMode.idle;\\n        }\\n\\n        // Choosing the proper mode if we\'re not attacking\\n        if (mode != eMode.attack)\\n        {                                          // c\\n            if (dirHeld == -1)\\n            {\\n                mode = eMode.idle;\\n            }\\n            else\\n            {\\n                facing = dirHeld;                                            // d\\n                mode = eMode.move;\\n            }\\n        }\\n\\n        //Act on the current mode\\n        Vector3 vel = Vector3.zero;\\n        switch (mode)\\n        {                                                      // e\\n            case eMode.attack:\\n                anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.idle:\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.move:\\n                vel = directions[dirHeld];\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 1;\\n                break;\\n        }\\n\\n        rigid.velocity = vel * speed;\\n\\n    }\\n\\n\\n    void LateUpdate()\\n    {\\n        // Get the half-grid location of this GameObject\\n        Vector2 rPos = GetRoomPosOnGrid(0.5f);  // Forces half-grid        // c\\n\\n        // Check to see whether we\'re in a Door tile\\n        int doorNum;\\n        for (doorNum = 0; doorNum < 4; doorNum++)\\n        {\\n            if (rPos == InRoom.DOORS[doorNum])\\n            {\\n                break;                                                       // d\\n            }\\n        }\\n\\n        if (doorNum > 3 || doorNum != facing) return;                      // e\\n\\n        // Move to the next room\\n        Vector2 rm = roomNum;\\n        switch (doorNum)\\n        {                                                   // f\\n            case 0:\\n                rm.x += 1;\\n                break;\\n            case 1:\\n                rm.y += 1;\\n                break;\\n            case 2:\\n                rm.x -= 1;\\n                break;\\n            case 3:\\n                rm.y -= 1;\\n                break;\\n        }\\n\\n        // Make sure that the rm we want to jump to is valid\\n        if (rm.x >= 0 && rm.x <= InRoom.MAX_RM_X)\\n        {                          // g\\n            if (rm.y >= 0 && rm.y <= InRoom.MAX_RM_Y)\\n            {\\n                roomNum = rm;\\n                transitionPos = InRoom.DOORS[(doorNum + 2) % 4];             // h\\n                roomPos = transitionPos;\\n                mode = eMode.transition;                                     // i\\n                transitionDone = Time.time + transitionDelay;\\n            }\\n        }\\n    }\\n\\n    void OnCollisionEnter(Collision coll)\\n    {\\n        if (invincible) return; // Return if Dray can\'t be damaged           // g\\n        DamageEffect dEf = coll.gameObject.GetComponent<DamageEffect>();\\n        if (dEf == null) return; // If no DamageEffect, exit this method\\n\\n        health -= dEf.damage;// Subtract the damage amount from health       // h\\n        invincible = true; // Make Dray invincible\\n        invincibleDone = Time.time + invincibleDuration;\\n\\n        if (dEf.knockback)\\n        { // Knockback Dray                               // i\\n            // Determine the direction of knockback\\n            Vector3 delta = transform.position - coll.transform.position;\\n            if (Mathf.Abs(delta.x) >= Mathf.Abs(delta.y))\\n            {\\n                // Knockback should be horizontal\\n                delta.x = (delta.x > 0) ? 1 : -1;\\n                delta.y = 0;\\n            }\\n            else\\n            {\\n                // Knockback should be vertical\\n                delta.x = 0;\\n                delta.y = (delta.y > 0) ? 1 : -1;\\n            }\\n\\n            // Apply knockback speed to the Rigidbody\\n            knockbackVel = delta * knockbackSpeed;\\n            rigid.velocity = knockbackVel;\\n\\n            // Set mode to knockback and set time to stop knockback\\n            mode = eMode.knockback;\\n            knockbackDone = Time.time + knockbackDuration;\\n        }\\n    }\\n\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {                                                 // c\\n        return facing;\\n    }\\n\\n    public bool moving\\n    {                                                     // d\\n        get\\n        {\\n            return (mode == eMode.move);\\n        }\\n    }\\n\\n    public float GetSpeed()\\n    {                                                // e\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {                                                 // f\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n\\n\\n    // Implementation of IKeyMaster\\n    public int keyCount\\n    {                                                    // d\\n        get { return numKeys; }\\n        set { numKeys = value; }\\n    }\\n}\\n\", \"__Scripts/Enemy.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Enemy : MonoBehaviour\\n{\\n    protected static Vector3[] directions = new Vector3[] {                 // a\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };\\n\\n    [Header(\\\"Set in Inspector: Enemy\\\")]                                      // b\\n    public float maxHealth = 1;                               // c\\n\\n    [Header(\\\"Set Dynamically: Enemy\\\")]\\n    public float health;                                      // c\\n\\n    protected Animator anim;                                        // c\\n    protected Rigidbody rigid;                                       // c\\n    protected SpriteRenderer sRend;                                       // c\\n\\n    protected virtual void Awake()\\n    {                                         // d\\n        health = maxHealth;\\n        anim = GetComponent<Animator>();\\n        rigid = GetComponent<Rigidbody>();\\n        sRend = GetComponent<SpriteRenderer>();\\n    }\\n}\\n\", \"__Scripts/GateKeeper.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GateKeeper : MonoBehaviour\\n{\\n    // These consts are based on the default DelverTiles image.\\n    // If you rearrange DelverTiles you may need to change it!\\n    //Locked Door tileNums                                           // a\\n    const int lockedR = 95;\\n    const int lockedUR = 81;\\n    const int lockedUL = 80;\\n    const int lockedL = 100;\\n    const int lockedDL = 101;\\n    const int lockedDR = 102;\\n\\n    //Open Door tileNums\\n    const int openR = 48;\\n    const int openUR = 93;\\n    const int openUL = 92;\\n    const int openL = 51;\\n    const int openDL = 26;\\n    const int openDR = 27;\\n\\n    private IKeyMaster keys;\\n\\n    void Awake()\\n    {\\n        keys = GetComponent<IKeyMaster>();\\n    }\\n\\n    void OnCollisionStay(Collision coll)\\n    {                                 // b\\n        // No keys, no need to run\\n        if (keys.keyCount < 1) return;\\n\\n        // Only worry about hitting tiles\\n        Tile ti = coll.gameObject.GetComponent<Tile>();\\n        if (ti == null) return;\\n\\n        // Only open if Dray is facing the door (avoid accidental key use)\\n        int facing = keys.GetFacing();\\n        // Check whether it\'s a door tile\\n        Tile ti2;\\n        switch (ti.tileNum)\\n        {                                                // c\\n            case lockedR:\\n                if (facing != 0) return;                                     // d\\n                ti.SetTile(ti.x, ti.y, openR);\\n                break;\\n\\n            case lockedUR:\\n                if (facing != 1) return;\\n                ti.SetTile(ti.x, ti.y, openUR);\\n                ti2 = TileCamera.TILES[ti.x - 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openUL);\\n                break;\\n\\n            case lockedUL:\\n                if (facing != 1) return;\\n                ti.SetTile(ti.x, ti.y, openUL);\\n                ti2 = TileCamera.TILES[ti.x + 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openUR);\\n                break;\\n\\n            case lockedL:\\n                if (facing != 2) return;\\n                ti.SetTile(ti.x, ti.y, openL);\\n                break;\\n\\n            case lockedDL:\\n                if (facing != 3) return;\\n                ti.SetTile(ti.x, ti.y, openDL);\\n                ti2 = TileCamera.TILES[ti.x + 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openDR);\\n                break;\\n\\n            case lockedDR:\\n                if (facing != 3) return;\\n                ti.SetTile(ti.x, ti.y, openDR);\\n                ti2 = TileCamera.TILES[ti.x - 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openDL);\\n                break;\\n\\n            default:\\n                return; // Return and avoid key decrement\\n        }\\n\\n        keys.keyCount--;\\n    }\\n}\", \"__Scripts/GridMove.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GridMove : MonoBehaviour\\n{\\n    private IFacingMover mover;\\n\\n    void Awake()\\n    {\\n        mover = GetComponent<IFacingMover>();                                // a\\n    }\\n\\n    void FixedUpdate()\\n    {\\n        if (!mover.moving) return; // If not moving, nothing to do here\\n        int facing = mover.GetFacing();\\n\\n        // If we are moving in a direction, align to the grid\\n        // First, get the grid location\\n        Vector2 rPos = mover.roomPos;\\n        Vector2 rPosGrid = mover.GetRoomPosOnGrid();\\n        // This relies on IFacingMover (which uses InRoom) to choose grid spacing\\n\\n        // Then move towards the grid line\\n        float delta = 0;\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            delta = rPosGrid.y - rPos.y;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            delta = rPosGrid.x - rPos.x;\\n        }\\n        if (delta == 0) return; // Already aligned to the grid\\n\\n        float move = mover.GetSpeed() * Time.fixedDeltaTime;\\n        move = Mathf.Min(move, Mathf.Abs(delta));\\n        if (delta < 0) move = -move;\\n\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            rPos.y += move;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            rPos.x += move;\\n        }\\n\\n        mover.roomPos = rPos;\\n    }\\n}\\n\", \"__Scripts/GuiPanel.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\npublic class GuiPanel : MonoBehaviour\\n{\\n    [Header(\\\"Set in Inspector\\\")]\\n    public Dray dray;\\n    public Sprite healthEmpty;\\n    public Sprite healthHalf;\\n    public Sprite healthFull;\\n\\n    Text keyCountText;\\n    List<Image> healthImages;\\n\\n    void Start()\\n    {\\n        // Key Count\\n        Transform trans = transform.Find(\\\"Key Count\\\");                       // a\\n        keyCountText = trans.GetComponent<Text>();\\n\\n        // Health Icons\\n        Transform healthPanel = transform.Find(\\\"Health Panel\\\");\\n        healthImages = new List<Image>();\\n        if (healthPanel != null)\\n        {                                           // b\\n            for (int i = 0; i < 20; i++)\\n            {\\n                trans = healthPanel.Find(\\\"H_\\\" + i);\\n                if (trans == null) break;\\n                healthImages.Add(trans.GetComponent<Image>());\\n            }\\n        }\\n    }\\n\\n    void Update()\\n    {\\n        // Show keys                                \\n        keyCountText.text = dray.numKeys.ToString();                         // c\\n\\n        // Show health\\n        int health = dray.health;\\n        for (int i = 0; i < healthImages.Count; i++)\\n        {                           // d\\n            if (health > 1)\\n            {\\n                healthImages[i].sprite = healthFull;\\n            }\\n            else if (health == 1)\\n            {\\n                healthImages[i].sprite = healthHalf;\\n            }\\n            else\\n            {\\n                healthImages[i].sprite = healthEmpty;\\n            }\\n            health -= 2;\\n        }\\n    }\\n}\\n\", \"__Scripts/IFacingMover.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IFacingMover\\n{                                              // a\\n    int GetFacing();                                                         // b\\n    bool moving { get; }                                                     // c\\n    float GetSpeed();\\n    float gridMult { get; }                                                  // d\\n    Vector2 roomPos { get; set; }                                            // e\\n    Vector2 roomNum { get; set; }\\n    Vector2 GetRoomPosOnGrid(float mult = -1);                             // f\\n}\", \"__Scripts/IKeyMaster.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IKeyMaster\\n{\\n    int keyCount { get; set; }                                               // a\\n    int GetFacing();                                                         // b\\n}\\n\", \"__Scripts/InRoom.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class InRoom : MonoBehaviour\\n{\\n    static public float ROOM_W = 16;                                     // a\\n    static public float ROOM_H = 11;\\n    static public float WALL_T = 2;\\n\\n    static public int MAX_RM_X = 9;                                    // a\\n    static public int MAX_RM_Y = 9;\\n\\n    static public Vector2[] DOORS = new Vector2[] {                          // b\\n        new Vector2(14,   5),\\n        new Vector2(7.5f, 9),\\n        new Vector2(1,    5),\\n        new Vector2(7.5f, 1)\\n    };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public bool keepInRoom = true;\\n    public float gridMult = 1;                                    // a\\n\\n\\n    void LateUpdate()\\n    {\\n        if (keepInRoom)\\n        {                                                    // b\\n            Vector2 rPos = roomPos;                                          // c\\n            rPos.x = Mathf.Clamp(rPos.x, WALL_T, ROOM_W - 1 - WALL_T);\\n            rPos.y = Mathf.Clamp(rPos.y, WALL_T, ROOM_H - 1 - WALL_T);\\n            roomPos = rPos;                                                  // d\\n        }\\n    }\\n\\n    // Where is this character in local room coordinates?\\n    public Vector2 roomPos\\n    {                                        // b\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x %= ROOM_W;\\n            tPos.y %= ROOM_H;\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rm = roomNum;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            rm += value;\\n            transform.position = rm;\\n        }\\n    }\\n\\n    // Which room is this character in?\\n    public Vector2 roomNum\\n    {                                        // c\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x = Mathf.Floor(tPos.x / ROOM_W);\\n            tPos.y = Mathf.Floor(tPos.y / ROOM_H);\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rPos = roomPos;\\n            Vector2 rm = value;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            transform.position = rm + rPos;\\n        }\\n    }\\n\\n    // What is the closest grid location to this character?\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        if (mult == -1)\\n        {\\n            mult = gridMult;\\n        }\\n        Vector2 rPos = roomPos;\\n        rPos /= mult;\\n        rPos.x = Mathf.Round(rPos.x);\\n        rPos.y = Mathf.Round(rPos.y);\\n        rPos *= mult;\\n        return rPos;\\n    }\\n\\n}\", \"__Scripts/Skeletos.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Skeletos : Enemy, IFacingMover\\n{                                              // a\\n    [Header(\\\"Set in Inspector: Skeletos\\\")]                                   // b\\n    public int speed = 2;\\n    public float timeThinkMin = 1f;\\n    public float timeThinkMax = 4f;\\n\\n    [Header(\\\"Set Dynamically: Skeletos\\\")]\\n    public int facing = 0;\\n    public float timeNextDecision = 0;\\n\\n    private InRoom inRm;                                                    // b\\n\\n    protected override void Awake()\\n    {                                       // c\\n        base.Awake();\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    void Update()\\n    {\\n        if (Time.time >= timeNextDecision)\\n        {                                 // c\\n            DecideDirection();\\n        }\\n        // rigid is inherited from Enemy and is initialized in Enemy.Awake()\\n        rigid.velocity = directions[facing] * speed;\\n    }\\n\\n    void DecideDirection()\\n    {                                                 // d\\n        facing = Random.Range(0, 4);\\n        timeNextDecision = Time.time + Random.Range(timeThinkMin, timeThinkMax);\\n    }\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {\\n        return facing;\\n    }\\n\\n    public bool moving { get { return true; } }                            // d\\n\\n    public float GetSpeed()\\n    {\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n}\\n\", \"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/SwordController.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class SwordController : MonoBehaviour\\n{\\n    private GameObject sword;\\n    private Dray dray;\\n\\n    void Start()\\n    {\\n        sword = transform.Find(\\\"Sword\\\").gameObject;                          // a\\n        dray = transform.parent.GetComponent<Dray>();\\n        // Deactivate the sword\\n        sword.SetActive(false);                                              // b\\n    }\\n\\n    void Update()\\n    {\\n        transform.rotation = Quaternion.Euler(0, 0, 90 * dray.facing);       // c\\n        sword.SetActive(dray.mode == Dray.eMode.attack);                     // d\\n    }\\n}\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n\\n    private BoxCollider bColl;                                           // a\\n\\n    void Awake()\\n    {\\n        bColl = GetComponent<BoxCollider>();                                 // a\\n    }\\n\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y);\\n        }\\n        else\\n        {\\n            TileCamera.SET_MAP(x, y, eTileNum); // Replace if non-default tileNum\\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum];\\n\\n        SetCollider();                                                       // b\\n    }\\n\\n    // Arrange the collider for this tile\\n    void SetCollider()\\n    {\\n        // Collider info is pulled from DelverCollisions.txt\\n        bColl.enabled = true;\\n        char c = TileCamera.COLLISIONS[tileNum];                             // c\\n        switch (c)\\n        {\\n            case \'S\': // Whole\\n                bColl.center = Vector3.zero;\\n                bColl.size = Vector3.one;\\n                break;\\n            case \'W\': // Top\\n                bColl.center = new Vector3(0, 0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'A\': // Left\\n                bColl.center = new Vector3(-0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n            case \'D\': // Right\\n                bColl.center = new Vector3(0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n\\n            // vvvvvvvv-------- These are optional --------vvvvvvvv          // d\\n            case \'Q\': // Top, Left\\n                bColl.center = new Vector3(-0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'E\': // Top, Right\\n                bColl.center = new Vector3(0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'Z\': // Bottom, left\\n                bColl.center = new Vector3(-0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'X\': // Bottom\\n                bColl.center = new Vector3(0, -0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'C\': // Bottom, Right\\n                bColl.center = new Vector3(0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            // ^^^^^^^^-------- These are optional --------^^^^^^^^          // d\\n\\n            default: // Anything else: _, |, etc.                            // e\\n                bColl.enabled = false;\\n                break;\\n        }\\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    static public string COLLISIONS;                                  // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n\\n    void Awake()\\n    {\\n        COLLISIONS = Utils.RemoveLineEndings(mapCollisions.text);          // b\\n        LoadMap();\\n    }\\n\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}, \"14 - Making Dray\'s Attack Damage Enemies\": {\"__Scripts/CamFollowDray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class CamFollowDray : MonoBehaviour\\n{\\n    static public bool TRANSITIONING = false;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public InRoom drayInRm;                                            // a\\n    public float transTime = 0.5f;\\n\\n    private Vector3 p0, p1;\\n\\n    private InRoom inRm;                                                // b\\n    private float transStart;\\n\\n    void Awake()\\n    {\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    void Update()\\n    {\\n        if (TRANSITIONING)\\n        {                                                 // c\\n            float u = (Time.time - transStart) / transTime;\\n            if (u >= 1)\\n            {\\n                u = 1;\\n                TRANSITIONING = false;\\n            }\\n            transform.position = (1 - u) * p0 + u * p1;\\n        }\\n        else\\n        {                                                             // d\\n            if (drayInRm.roomNum != inRm.roomNum)\\n            {\\n                TransitionTo(drayInRm.roomNum);\\n            }\\n        }\\n    }\\n\\n    void TransitionTo(Vector2 rm)\\n    {                                        // e\\n        p0 = transform.position;\\n        inRm.roomNum = rm;\\n        p1 = transform.position + (Vector3.back * 10);\\n        transform.position = p0;\\n\\n        transStart = Time.time;\\n        TRANSITIONING = true;\\n    }\\n}\\n\", \"__Scripts/DamageEffect.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class DamageEffect : MonoBehaviour\\n{\\n    [Header(\\\"Set in Inspector\\\")]\\n    public int damage = 1;\\n    public bool knockback = true;\\n}\", \"__Scripts/Dray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Dray : MonoBehaviour, IFacingMover, IKeyMaster\\n{\\n    public enum eMode { idle, move, attack, transition, knockback }          // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float speed = 5;\\n    public float attackDuration = 0.25f;// Number of seconds to attack\\n    public float attackDelay = 0.5f;    // Delay between attacks \\n    public float transitionDelay = 0.5f;// Room transition delay  // a\\n    public int maxHealth = 10;                                  // a\\n    public float knockbackSpeed = 10;                             // b\\n    public float knockbackDuration = 0.25f;\\n    public float invincibleDuration = 0.5f;\\n\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int dirHeld = -1; // Direction of the held movement key\\n    public int facing = 1;   // Direction Dray is facing \\n    public eMode mode = eMode.idle;                                // a\\n    public int numKeys = 0;                                     // b\\n    public bool invincible = false;                              // c\\n\\n    [SerializeField]                                                         // b\\n    private int _health;\\n\\n    public int health\\n    {                                                      // c\\n        get { return _health; }\\n        set { _health = value; }\\n    }\\n\\n    private float timeAtkDone = 0;                                  // b\\n    private float timeAtkNext = 0;                                  // c;    \\n    private float transitionDone = 0;                              // a\\n    private Vector2 transitionPos;\\n    private float knockbackDone = 0;                               // d\\n    private float invincibleDone = 0;\\n    private Vector3 knockbackVel;\\n\\n    private SpriteRenderer sRend;                                           // e\\n    private Rigidbody   rigid;\\n    private Animator    anim;                                            // a\\n    private InRoom      inRm;                                            // b\\n\\n\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };             // a\\n\\n    private KeyCode[] keys = new KeyCode[] { KeyCode.RightArrow,\\n        KeyCode.UpArrow, KeyCode.LeftArrow, KeyCode.DownArrow };             // a\\n\\n\\n    void Awake()\\n    {\\n        sRend = GetComponent<SpriteRenderer>();                              // e\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();                                     // a\\n        inRm = GetComponent<InRoom>();                                       // b\\n        health = maxHealth;                                                  // d\\n    }\\n\\n    void Update()\\n    {\\n        // Check knockback and invincibility\\n        if (invincible && Time.time > invincibleDone) invincible = false;    // f\\n        sRend.color = invincible ? Color.red : Color.white;\\n        if (mode == eMode.knockback)\\n        {\\n            rigid.velocity = knockbackVel;\\n            if (Time.time < knockbackDone) return;\\n        }\\n\\n        if (mode == eMode.transition)\\n        {                                    // b\\n            rigid.velocity = Vector3.zero;\\n            anim.speed = 0;\\n            roomPos = transitionPos;  // Keeps Dray in place\\n            if (Time.time < transitionDone) return;\\n            // The following line is only reached if Time.time >= transitionDone\\n            mode = eMode.idle;\\n        }\\n\\n        //Handle Keyboard Input and manage eDrayModes\\n        dirHeld = -1;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (Input.GetKey(keys[i])) dirHeld = i;\\n        }\\n\\n        // Pressing the attack button(s)\\n        if (Input.GetKeyDown(KeyCode.Z) && Time.time >= timeAtkNext)\\n        {       // a\\n            mode = eMode.attack;\\n            timeAtkDone = Time.time + attackDuration;\\n            timeAtkNext = Time.time + attackDelay;\\n        }\\n\\n        // Finishing the attack when it\'s over\\n        if (Time.time >= timeAtkDone)\\n        {                                      // b\\n            mode = eMode.idle;\\n        }\\n\\n        // Choosing the proper mode if we\'re not attacking\\n        if (mode != eMode.attack)\\n        {                                          // c\\n            if (dirHeld == -1)\\n            {\\n                mode = eMode.idle;\\n            }\\n            else\\n            {\\n                facing = dirHeld;                                            // d\\n                mode = eMode.move;\\n            }\\n        }\\n\\n        //Act on the current mode\\n        Vector3 vel = Vector3.zero;\\n        switch (mode)\\n        {                                                      // e\\n            case eMode.attack:\\n                anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.idle:\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.move:\\n                vel = directions[dirHeld];\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 1;\\n                break;\\n        }\\n\\n        rigid.velocity = vel * speed;\\n\\n    }\\n\\n\\n    void LateUpdate()\\n    {\\n        // Get the half-grid location of this GameObject\\n        Vector2 rPos = GetRoomPosOnGrid(0.5f);  // Forces half-grid        // c\\n\\n        // Check to see whether we\'re in a Door tile\\n        int doorNum;\\n        for (doorNum = 0; doorNum < 4; doorNum++)\\n        {\\n            if (rPos == InRoom.DOORS[doorNum])\\n            {\\n                break;                                                       // d\\n            }\\n        }\\n\\n        if (doorNum > 3 || doorNum != facing) return;                      // e\\n\\n        // Move to the next room\\n        Vector2 rm = roomNum;\\n        switch (doorNum)\\n        {                                                   // f\\n            case 0:\\n                rm.x += 1;\\n                break;\\n            case 1:\\n                rm.y += 1;\\n                break;\\n            case 2:\\n                rm.x -= 1;\\n                break;\\n            case 3:\\n                rm.y -= 1;\\n                break;\\n        }\\n\\n        // Make sure that the rm we want to jump to is valid\\n        if (rm.x >= 0 && rm.x <= InRoom.MAX_RM_X)\\n        {                          // g\\n            if (rm.y >= 0 && rm.y <= InRoom.MAX_RM_Y)\\n            {\\n                roomNum = rm;\\n                transitionPos = InRoom.DOORS[(doorNum + 2) % 4];             // h\\n                roomPos = transitionPos;\\n                mode = eMode.transition;                                     // i\\n                transitionDone = Time.time + transitionDelay;\\n            }\\n        }\\n    }\\n\\n    void OnCollisionEnter(Collision coll)\\n    {\\n        if (invincible) return; // Return if Dray can\'t be damaged           // g\\n        DamageEffect dEf = coll.gameObject.GetComponent<DamageEffect>();\\n        if (dEf == null) return; // If no DamageEffect, exit this method\\n\\n        health -= dEf.damage;// Subtract the damage amount from health       // h\\n        invincible = true; // Make Dray invincible\\n        invincibleDone = Time.time + invincibleDuration;\\n\\n        if (dEf.knockback)\\n        { // Knockback Dray                               // i\\n            // Determine the direction of knockback\\n            Vector3 delta = transform.position - coll.transform.position;\\n            if (Mathf.Abs(delta.x) >= Mathf.Abs(delta.y))\\n            {\\n                // Knockback should be horizontal\\n                delta.x = (delta.x > 0) ? 1 : -1;\\n                delta.y = 0;\\n            }\\n            else\\n            {\\n                // Knockback should be vertical\\n                delta.x = 0;\\n                delta.y = (delta.y > 0) ? 1 : -1;\\n            }\\n\\n            // Apply knockback speed to the Rigidbody\\n            knockbackVel = delta * knockbackSpeed;\\n            rigid.velocity = knockbackVel;\\n\\n            // Set mode to knockback and set time to stop knockback\\n            mode = eMode.knockback;\\n            knockbackDone = Time.time + knockbackDuration;\\n        }\\n    }\\n\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {                                                 // c\\n        return facing;\\n    }\\n\\n    public bool moving\\n    {                                                     // d\\n        get\\n        {\\n            return (mode == eMode.move);\\n        }\\n    }\\n\\n    public float GetSpeed()\\n    {                                                // e\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {                                                 // f\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n\\n\\n    // Implementation of IKeyMaster\\n    public int keyCount\\n    {                                                    // d\\n        get { return numKeys; }\\n        set { numKeys = value; }\\n    }\\n}\\n\", \"__Scripts/Enemy.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Enemy : MonoBehaviour\\n{\\n    protected static Vector3[] directions = new Vector3[] {                 // a\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };\\n\\n    [Header(\\\"Set in Inspector: Enemy\\\")]\\n    public float maxHealth = 1;\\n    public float knockbackSpeed = 10;                         // a\\n    public float knockbackDuration = 0.25f;\\n    public float invincibleDuration = 0.5f;\\n\\n    [Header(\\\"Set Dynamically: Enemy\\\")]\\n    public float health;\\n    public bool invincible = false;                          // a\\n    public bool knockback = false;\\n\\n    private float invincibleDone = 0;                          // a\\n    private float knockbackDone = 0;\\n    private Vector3 knockbackVel;\\n\\n    protected Animator anim;                                        // c\\n    protected Rigidbody rigid;                                       // c\\n    protected SpriteRenderer sRend;                                       // c\\n\\n    protected virtual void Awake()\\n    {                                         // d\\n        health = maxHealth;\\n        anim = GetComponent<Animator>();\\n        rigid = GetComponent<Rigidbody>();\\n        sRend = GetComponent<SpriteRenderer>();\\n    }\\n\\n    protected virtual void Update()\\n    {                                        // b\\n        // Check knockback and invincibility\\n        if (invincible && Time.time > invincibleDone) invincible = false;\\n        sRend.color = invincible ? Color.red : Color.white;\\n        if (knockback)\\n        {\\n            rigid.velocity = knockbackVel;\\n            if (Time.time < knockbackDone) return;\\n        }\\n\\n        anim.speed = 1;                                                      // c\\n        knockback = false;\\n    }\\n\\n    void OnTriggerEnter(Collider colld)\\n    {                                  // d\\n        if (invincible) return; // Return if this can\'t be damaged \\n        DamageEffect dEf = colld.gameObject.GetComponent<DamageEffect>();\\n        if (dEf == null) return; // If no DamageEffect, exit this method\\n\\n        health -= dEf.damage; // Subtract the damage amount from health\\n        if (health <= 0) Die();                                              // e\\n\\n        invincible = true; // Make this invincible\\n        invincibleDone = Time.time + invincibleDuration;\\n\\n        if (dEf.knockback)\\n        { // Knockback this \\n            // Determine the direction of knockback\\n            Vector3 delta = transform.position - colld.transform.root.position;\\n            if (Mathf.Abs(delta.x) >= Mathf.Abs(delta.y))\\n            {\\n                // Knockback should be horizontal\\n                delta.x = (delta.x > 0) ? 1 : -1;\\n                delta.y = 0;\\n            }\\n            else\\n            {\\n                // Knockback should be vertical\\n                delta.x = 0;\\n                delta.y = (delta.y > 0) ? 1 : -1;\\n            }\\n\\n            // Apply knockback speed to the Rigidbody\\n            knockbackVel = delta * knockbackSpeed;\\n            rigid.velocity = knockbackVel;\\n\\n            // Set mode to knockback and set time to stop knockback\\n            knockback = true;\\n            knockbackDone = Time.time + knockbackDuration;\\n            anim.speed = 0;\\n        }\\n    }\\n\\n    void Die()\\n    {                                                             // f\\n        Destroy(gameObject);\\n    }\\n}\\n\", \"__Scripts/GateKeeper.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GateKeeper : MonoBehaviour\\n{\\n    // These consts are based on the default DelverTiles image.\\n    // If you rearrange DelverTiles you may need to change it!\\n    //Locked Door tileNums                                           // a\\n    const int lockedR = 95;\\n    const int lockedUR = 81;\\n    const int lockedUL = 80;\\n    const int lockedL = 100;\\n    const int lockedDL = 101;\\n    const int lockedDR = 102;\\n\\n    //Open Door tileNums\\n    const int openR = 48;\\n    const int openUR = 93;\\n    const int openUL = 92;\\n    const int openL = 51;\\n    const int openDL = 26;\\n    const int openDR = 27;\\n\\n    private IKeyMaster keys;\\n\\n    void Awake()\\n    {\\n        keys = GetComponent<IKeyMaster>();\\n    }\\n\\n    void OnCollisionStay(Collision coll)\\n    {                                 // b\\n        // No keys, no need to run\\n        if (keys.keyCount < 1) return;\\n\\n        // Only worry about hitting tiles\\n        Tile ti = coll.gameObject.GetComponent<Tile>();\\n        if (ti == null) return;\\n\\n        // Only open if Dray is facing the door (avoid accidental key use)\\n        int facing = keys.GetFacing();\\n        // Check whether it\'s a door tile\\n        Tile ti2;\\n        switch (ti.tileNum)\\n        {                                                // c\\n            case lockedR:\\n                if (facing != 0) return;                                     // d\\n                ti.SetTile(ti.x, ti.y, openR);\\n                break;\\n\\n            case lockedUR:\\n                if (facing != 1) return;\\n                ti.SetTile(ti.x, ti.y, openUR);\\n                ti2 = TileCamera.TILES[ti.x - 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openUL);\\n                break;\\n\\n            case lockedUL:\\n                if (facing != 1) return;\\n                ti.SetTile(ti.x, ti.y, openUL);\\n                ti2 = TileCamera.TILES[ti.x + 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openUR);\\n                break;\\n\\n            case lockedL:\\n                if (facing != 2) return;\\n                ti.SetTile(ti.x, ti.y, openL);\\n                break;\\n\\n            case lockedDL:\\n                if (facing != 3) return;\\n                ti.SetTile(ti.x, ti.y, openDL);\\n                ti2 = TileCamera.TILES[ti.x + 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openDR);\\n                break;\\n\\n            case lockedDR:\\n                if (facing != 3) return;\\n                ti.SetTile(ti.x, ti.y, openDR);\\n                ti2 = TileCamera.TILES[ti.x - 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openDL);\\n                break;\\n\\n            default:\\n                return; // Return and avoid key decrement\\n        }\\n\\n        keys.keyCount--;\\n    }\\n}\", \"__Scripts/GridMove.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GridMove : MonoBehaviour\\n{\\n    private IFacingMover mover;\\n\\n    void Awake()\\n    {\\n        mover = GetComponent<IFacingMover>();                                // a\\n    }\\n\\n    void FixedUpdate()\\n    {\\n        if (!mover.moving) return; // If not moving, nothing to do here\\n        int facing = mover.GetFacing();\\n\\n        // If we are moving in a direction, align to the grid\\n        // First, get the grid location\\n        Vector2 rPos = mover.roomPos;\\n        Vector2 rPosGrid = mover.GetRoomPosOnGrid();\\n        // This relies on IFacingMover (which uses InRoom) to choose grid spacing\\n\\n        // Then move towards the grid line\\n        float delta = 0;\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            delta = rPosGrid.y - rPos.y;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            delta = rPosGrid.x - rPos.x;\\n        }\\n        if (delta == 0) return; // Already aligned to the grid\\n\\n        float move = mover.GetSpeed() * Time.fixedDeltaTime;\\n        move = Mathf.Min(move, Mathf.Abs(delta));\\n        if (delta < 0) move = -move;\\n\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            rPos.y += move;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            rPos.x += move;\\n        }\\n\\n        mover.roomPos = rPos;\\n    }\\n}\\n\", \"__Scripts/GuiPanel.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\npublic class GuiPanel : MonoBehaviour\\n{\\n    [Header(\\\"Set in Inspector\\\")]\\n    public Dray dray;\\n    public Sprite healthEmpty;\\n    public Sprite healthHalf;\\n    public Sprite healthFull;\\n\\n    Text keyCountText;\\n    List<Image> healthImages;\\n\\n    void Start()\\n    {\\n        // Key Count\\n        Transform trans = transform.Find(\\\"Key Count\\\");                       // a\\n        keyCountText = trans.GetComponent<Text>();\\n\\n        // Health Icons\\n        Transform healthPanel = transform.Find(\\\"Health Panel\\\");\\n        healthImages = new List<Image>();\\n        if (healthPanel != null)\\n        {                                           // b\\n            for (int i = 0; i < 20; i++)\\n            {\\n                trans = healthPanel.Find(\\\"H_\\\" + i);\\n                if (trans == null) break;\\n                healthImages.Add(trans.GetComponent<Image>());\\n            }\\n        }\\n    }\\n\\n    void Update()\\n    {\\n        // Show keys                                \\n        keyCountText.text = dray.numKeys.ToString();                         // c\\n\\n        // Show health\\n        int health = dray.health;\\n        for (int i = 0; i < healthImages.Count; i++)\\n        {                           // d\\n            if (health > 1)\\n            {\\n                healthImages[i].sprite = healthFull;\\n            }\\n            else if (health == 1)\\n            {\\n                healthImages[i].sprite = healthHalf;\\n            }\\n            else\\n            {\\n                healthImages[i].sprite = healthEmpty;\\n            }\\n            health -= 2;\\n        }\\n    }\\n}\\n\", \"__Scripts/IFacingMover.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IFacingMover\\n{                                              // a\\n    int GetFacing();                                                         // b\\n    bool moving { get; }                                                     // c\\n    float GetSpeed();\\n    float gridMult { get; }                                                  // d\\n    Vector2 roomPos { get; set; }                                            // e\\n    Vector2 roomNum { get; set; }\\n    Vector2 GetRoomPosOnGrid(float mult = -1);                             // f\\n}\", \"__Scripts/IKeyMaster.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IKeyMaster\\n{\\n    int keyCount { get; set; }                                               // a\\n    int GetFacing();                                                         // b\\n}\\n\", \"__Scripts/InRoom.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class InRoom : MonoBehaviour\\n{\\n    static public float ROOM_W = 16;                                     // a\\n    static public float ROOM_H = 11;\\n    static public float WALL_T = 2;\\n\\n    static public int MAX_RM_X = 9;                                    // a\\n    static public int MAX_RM_Y = 9;\\n\\n    static public Vector2[] DOORS = new Vector2[] {                          // b\\n        new Vector2(14,   5),\\n        new Vector2(7.5f, 9),\\n        new Vector2(1,    5),\\n        new Vector2(7.5f, 1)\\n    };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public bool keepInRoom = true;\\n    public float gridMult = 1;                                    // a\\n\\n\\n    void LateUpdate()\\n    {\\n        if (keepInRoom)\\n        {                                                    // b\\n            Vector2 rPos = roomPos;                                          // c\\n            rPos.x = Mathf.Clamp(rPos.x, WALL_T, ROOM_W - 1 - WALL_T);\\n            rPos.y = Mathf.Clamp(rPos.y, WALL_T, ROOM_H - 1 - WALL_T);\\n            roomPos = rPos;                                                  // d\\n        }\\n    }\\n\\n    // Where is this character in local room coordinates?\\n    public Vector2 roomPos\\n    {                                        // b\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x %= ROOM_W;\\n            tPos.y %= ROOM_H;\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rm = roomNum;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            rm += value;\\n            transform.position = rm;\\n        }\\n    }\\n\\n    // Which room is this character in?\\n    public Vector2 roomNum\\n    {                                        // c\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x = Mathf.Floor(tPos.x / ROOM_W);\\n            tPos.y = Mathf.Floor(tPos.y / ROOM_H);\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rPos = roomPos;\\n            Vector2 rm = value;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            transform.position = rm + rPos;\\n        }\\n    }\\n\\n    // What is the closest grid location to this character?\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        if (mult == -1)\\n        {\\n            mult = gridMult;\\n        }\\n        Vector2 rPos = roomPos;\\n        rPos /= mult;\\n        rPos.x = Mathf.Round(rPos.x);\\n        rPos.y = Mathf.Round(rPos.y);\\n        rPos *= mult;\\n        return rPos;\\n    }\\n\\n}\", \"__Scripts/Skeletos.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Skeletos : Enemy, IFacingMover\\n{                                              // a\\n    [Header(\\\"Set in Inspector: Skeletos\\\")]                                   // b\\n    public int speed = 2;\\n    public float timeThinkMin = 1f;\\n    public float timeThinkMax = 4f;\\n\\n    [Header(\\\"Set Dynamically: Skeletos\\\")]\\n    public int facing = 0;\\n    public float timeNextDecision = 0;\\n\\n    private InRoom inRm;                                                    // b\\n\\n    protected override void Awake()\\n    {                                       // c\\n        base.Awake();\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    override protected void Update()\\n    {                                      // a\\n        base.Update();\\n        if (knockback) return;\\n\\n        if (Time.time >= timeNextDecision)\\n        {                                 // c\\n            DecideDirection();\\n        }\\n        // rigid is inherited from Enemy and is initialized in Enemy.Awake()\\n        rigid.velocity = directions[facing] * speed;\\n    }\\n\\n    void DecideDirection()\\n    {                                                 // d\\n        facing = Random.Range(0, 4);\\n        timeNextDecision = Time.time + Random.Range(timeThinkMin, timeThinkMax);\\n    }\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {\\n        return facing;\\n    }\\n\\n    public bool moving { get { return true; } }                            // d\\n\\n    public float GetSpeed()\\n    {\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n}\\n\", \"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/SwordController.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class SwordController : MonoBehaviour\\n{\\n    private GameObject sword;\\n    private Dray dray;\\n\\n    void Start()\\n    {\\n        sword = transform.Find(\\\"Sword\\\").gameObject;                          // a\\n        dray = transform.parent.GetComponent<Dray>();\\n        // Deactivate the sword\\n        sword.SetActive(false);                                              // b\\n    }\\n\\n    void Update()\\n    {\\n        transform.rotation = Quaternion.Euler(0, 0, 90 * dray.facing);       // c\\n        sword.SetActive(dray.mode == Dray.eMode.attack);                     // d\\n    }\\n}\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n\\n    private BoxCollider bColl;                                           // a\\n\\n    void Awake()\\n    {\\n        bColl = GetComponent<BoxCollider>();                                 // a\\n    }\\n\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y);\\n        }\\n        else\\n        {\\n            TileCamera.SET_MAP(x, y, eTileNum); // Replace if non-default tileNum\\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum];\\n\\n        SetCollider();                                                       // b\\n    }\\n\\n    // Arrange the collider for this tile\\n    void SetCollider()\\n    {\\n        // Collider info is pulled from DelverCollisions.txt\\n        bColl.enabled = true;\\n        char c = TileCamera.COLLISIONS[tileNum];                             // c\\n        switch (c)\\n        {\\n            case \'S\': // Whole\\n                bColl.center = Vector3.zero;\\n                bColl.size = Vector3.one;\\n                break;\\n            case \'W\': // Top\\n                bColl.center = new Vector3(0, 0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'A\': // Left\\n                bColl.center = new Vector3(-0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n            case \'D\': // Right\\n                bColl.center = new Vector3(0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n\\n            // vvvvvvvv-------- These are optional --------vvvvvvvv          // d\\n            case \'Q\': // Top, Left\\n                bColl.center = new Vector3(-0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'E\': // Top, Right\\n                bColl.center = new Vector3(0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'Z\': // Bottom, left\\n                bColl.center = new Vector3(-0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'X\': // Bottom\\n                bColl.center = new Vector3(0, -0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'C\': // Bottom, Right\\n                bColl.center = new Vector3(0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            // ^^^^^^^^-------- These are optional --------^^^^^^^^          // d\\n\\n            default: // Anything else: _, |, etc.                            // e\\n                bColl.enabled = false;\\n                break;\\n        }\\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    static public string COLLISIONS;                                  // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n\\n    void Awake()\\n    {\\n        COLLISIONS = Utils.RemoveLineEndings(mapCollisions.text);          // b\\n        LoadMap();\\n    }\\n\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}, \"15 - Picking Up Items\": {\"__Scripts/CamFollowDray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class CamFollowDray : MonoBehaviour\\n{\\n    static public bool TRANSITIONING = false;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public InRoom drayInRm;                                            // a\\n    public float transTime = 0.5f;\\n\\n    private Vector3 p0, p1;\\n\\n    private InRoom inRm;                                                // b\\n    private float transStart;\\n\\n    void Awake()\\n    {\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    void Update()\\n    {\\n        if (TRANSITIONING)\\n        {                                                 // c\\n            float u = (Time.time - transStart) / transTime;\\n            if (u >= 1)\\n            {\\n                u = 1;\\n                TRANSITIONING = false;\\n            }\\n            transform.position = (1 - u) * p0 + u * p1;\\n        }\\n        else\\n        {                                                             // d\\n            if (drayInRm.roomNum != inRm.roomNum)\\n            {\\n                TransitionTo(drayInRm.roomNum);\\n            }\\n        }\\n    }\\n\\n    void TransitionTo(Vector2 rm)\\n    {                                        // e\\n        p0 = transform.position;\\n        inRm.roomNum = rm;\\n        p1 = transform.position + (Vector3.back * 10);\\n        transform.position = p0;\\n\\n        transStart = Time.time;\\n        TRANSITIONING = true;\\n    }\\n}\\n\", \"__Scripts/DamageEffect.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class DamageEffect : MonoBehaviour\\n{\\n    [Header(\\\"Set in Inspector\\\")]\\n    public int damage = 1;\\n    public bool knockback = true;\\n}\", \"__Scripts/Dray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Dray : MonoBehaviour, IFacingMover, IKeyMaster\\n{\\n    public enum eMode { idle, move, attack, transition, knockback }          // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float speed = 5;\\n    public float attackDuration = 0.25f;// Number of seconds to attack\\n    public float attackDelay = 0.5f;    // Delay between attacks \\n    public float transitionDelay = 0.5f;// Room transition delay  // a\\n    public int maxHealth = 10;                                  // a\\n    public float knockbackSpeed = 10;                             // b\\n    public float knockbackDuration = 0.25f;\\n    public float invincibleDuration = 0.5f;\\n\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int dirHeld = -1; // Direction of the held movement key\\n    public int facing = 1;   // Direction Dray is facing \\n    public eMode mode = eMode.idle;                                // a\\n    public int numKeys = 0;                                     // b\\n    public bool invincible = false;                              // c\\n\\n    [SerializeField]                                                         // b\\n    private int _health;\\n\\n    public int health\\n    {                                                      // c\\n        get { return _health; }\\n        set { _health = value; }\\n    }\\n\\n    private float timeAtkDone = 0;                                  // b\\n    private float timeAtkNext = 0;                                  // c;    \\n    private float transitionDone = 0;                              // a\\n    private Vector2 transitionPos;\\n    private float knockbackDone = 0;                               // d\\n    private float invincibleDone = 0;\\n    private Vector3 knockbackVel;\\n\\n    private SpriteRenderer sRend;                                           // e\\n    private Rigidbody   rigid;\\n    private Animator    anim;                                            // a\\n    private InRoom      inRm;                                            // b\\n\\n\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };             // a\\n\\n    private KeyCode[] keys = new KeyCode[] { KeyCode.RightArrow,\\n        KeyCode.UpArrow, KeyCode.LeftArrow, KeyCode.DownArrow };             // a\\n\\n\\n    void Awake()\\n    {\\n        sRend = GetComponent<SpriteRenderer>();                              // e\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();                                     // a\\n        inRm = GetComponent<InRoom>();                                       // b\\n        health = maxHealth;                                                  // d\\n    }\\n\\n    void Update()\\n    {\\n        // Check knockback and invincibility\\n        if (invincible && Time.time > invincibleDone) invincible = false;    // f\\n        sRend.color = invincible ? Color.red : Color.white;\\n        if (mode == eMode.knockback)\\n        {\\n            rigid.velocity = knockbackVel;\\n            if (Time.time < knockbackDone) return;\\n        }\\n\\n        if (mode == eMode.transition)\\n        {                                    // b\\n            rigid.velocity = Vector3.zero;\\n            anim.speed = 0;\\n            roomPos = transitionPos;  // Keeps Dray in place\\n            if (Time.time < transitionDone) return;\\n            // The following line is only reached if Time.time >= transitionDone\\n            mode = eMode.idle;\\n        }\\n\\n        //Handle Keyboard Input and manage eDrayModes\\n        dirHeld = -1;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (Input.GetKey(keys[i])) dirHeld = i;\\n        }\\n\\n        // Pressing the attack button(s)\\n        if (Input.GetKeyDown(KeyCode.Z) && Time.time >= timeAtkNext)\\n        {       // a\\n            mode = eMode.attack;\\n            timeAtkDone = Time.time + attackDuration;\\n            timeAtkNext = Time.time + attackDelay;\\n        }\\n\\n        // Finishing the attack when it\'s over\\n        if (Time.time >= timeAtkDone)\\n        {                                      // b\\n            mode = eMode.idle;\\n        }\\n\\n        // Choosing the proper mode if we\'re not attacking\\n        if (mode != eMode.attack)\\n        {                                          // c\\n            if (dirHeld == -1)\\n            {\\n                mode = eMode.idle;\\n            }\\n            else\\n            {\\n                facing = dirHeld;                                            // d\\n                mode = eMode.move;\\n            }\\n        }\\n\\n        //Act on the current mode\\n        Vector3 vel = Vector3.zero;\\n        switch (mode)\\n        {                                                      // e\\n            case eMode.attack:\\n                anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.idle:\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.move:\\n                vel = directions[dirHeld];\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 1;\\n                break;\\n        }\\n\\n        rigid.velocity = vel * speed;\\n\\n    }\\n\\n\\n    void LateUpdate()\\n    {\\n        // Get the half-grid location of this GameObject\\n        Vector2 rPos = GetRoomPosOnGrid(0.5f);  // Forces half-grid        // c\\n\\n        // Check to see whether we\'re in a Door tile\\n        int doorNum;\\n        for (doorNum = 0; doorNum < 4; doorNum++)\\n        {\\n            if (rPos == InRoom.DOORS[doorNum])\\n            {\\n                break;                                                       // d\\n            }\\n        }\\n\\n        if (doorNum > 3 || doorNum != facing) return;                      // e\\n\\n        // Move to the next room\\n        Vector2 rm = roomNum;\\n        switch (doorNum)\\n        {                                                   // f\\n            case 0:\\n                rm.x += 1;\\n                break;\\n            case 1:\\n                rm.y += 1;\\n                break;\\n            case 2:\\n                rm.x -= 1;\\n                break;\\n            case 3:\\n                rm.y -= 1;\\n                break;\\n        }\\n\\n        // Make sure that the rm we want to jump to is valid\\n        if (rm.x >= 0 && rm.x <= InRoom.MAX_RM_X)\\n        {                          // g\\n            if (rm.y >= 0 && rm.y <= InRoom.MAX_RM_Y)\\n            {\\n                roomNum = rm;\\n                transitionPos = InRoom.DOORS[(doorNum + 2) % 4];             // h\\n                roomPos = transitionPos;\\n                mode = eMode.transition;                                     // i\\n                transitionDone = Time.time + transitionDelay;\\n            }\\n        }\\n    }\\n\\n    void OnCollisionEnter(Collision coll)\\n    {\\n        if (invincible) return; // Return if Dray can\'t be damaged           // g\\n        DamageEffect dEf = coll.gameObject.GetComponent<DamageEffect>();\\n        if (dEf == null) return; // If no DamageEffect, exit this method\\n\\n        health -= dEf.damage;// Subtract the damage amount from health       // h\\n        invincible = true; // Make Dray invincible\\n        invincibleDone = Time.time + invincibleDuration;\\n\\n        if (dEf.knockback)\\n        { // Knockback Dray                               // i\\n            // Determine the direction of knockback\\n            Vector3 delta = transform.position - coll.transform.position;\\n            if (Mathf.Abs(delta.x) >= Mathf.Abs(delta.y))\\n            {\\n                // Knockback should be horizontal\\n                delta.x = (delta.x > 0) ? 1 : -1;\\n                delta.y = 0;\\n            }\\n            else\\n            {\\n                // Knockback should be vertical\\n                delta.x = 0;\\n                delta.y = (delta.y > 0) ? 1 : -1;\\n            }\\n\\n            // Apply knockback speed to the Rigidbody\\n            knockbackVel = delta * knockbackSpeed;\\n            rigid.velocity = knockbackVel;\\n\\n            // Set mode to knockback and set time to stop knockback\\n            mode = eMode.knockback;\\n            knockbackDone = Time.time + knockbackDuration;\\n        }\\n    }\\n\\n    void OnTriggerEnter(Collider colld)\\n    {\\n        PickUp pup = colld.GetComponent<PickUp>();                           // a\\n        if (pup == null) return;\\n\\n        switch (pup.itemType)\\n        {\\n            case PickUp.eType.health:\\n                health = Mathf.Min(health + 2, maxHealth);\\n                break;\\n\\n            case PickUp.eType.key:\\n                keyCount++;\\n                break;\\n        }\\n\\n        Destroy(colld.gameObject);\\n    }\\n\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {                                                 // c\\n        return facing;\\n    }\\n\\n    public bool moving\\n    {                                                     // d\\n        get\\n        {\\n            return (mode == eMode.move);\\n        }\\n    }\\n\\n    public float GetSpeed()\\n    {                                                // e\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {                                                 // f\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n\\n\\n    // Implementation of IKeyMaster\\n    public int keyCount\\n    {                                                    // d\\n        get { return numKeys; }\\n        set { numKeys = value; }\\n    }\\n}\\n\", \"__Scripts/Enemy.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Enemy : MonoBehaviour\\n{\\n    protected static Vector3[] directions = new Vector3[] {                 // a\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };\\n\\n    [Header(\\\"Set in Inspector: Enemy\\\")]\\n    public float maxHealth = 1;\\n    public float knockbackSpeed = 10;                         // a\\n    public float knockbackDuration = 0.25f;\\n    public float invincibleDuration = 0.5f;\\n\\n    [Header(\\\"Set Dynamically: Enemy\\\")]\\n    public float health;\\n    public bool invincible = false;                          // a\\n    public bool knockback = false;\\n\\n    private float invincibleDone = 0;                          // a\\n    private float knockbackDone = 0;\\n    private Vector3 knockbackVel;\\n\\n    protected Animator anim;                                        // c\\n    protected Rigidbody rigid;                                       // c\\n    protected SpriteRenderer sRend;                                       // c\\n\\n    protected virtual void Awake()\\n    {                                         // d\\n        health = maxHealth;\\n        anim = GetComponent<Animator>();\\n        rigid = GetComponent<Rigidbody>();\\n        sRend = GetComponent<SpriteRenderer>();\\n    }\\n\\n    protected virtual void Update()\\n    {                                        // b\\n        // Check knockback and invincibility\\n        if (invincible && Time.time > invincibleDone) invincible = false;\\n        sRend.color = invincible ? Color.red : Color.white;\\n        if (knockback)\\n        {\\n            rigid.velocity = knockbackVel;\\n            if (Time.time < knockbackDone) return;\\n        }\\n\\n        anim.speed = 1;                                                      // c\\n        knockback = false;\\n    }\\n\\n    void OnTriggerEnter(Collider colld)\\n    {                                  // d\\n        if (invincible) return; // Return if this can\'t be damaged \\n        DamageEffect dEf = colld.gameObject.GetComponent<DamageEffect>();\\n        if (dEf == null) return; // If no DamageEffect, exit this method\\n\\n        health -= dEf.damage; // Subtract the damage amount from health\\n        if (health <= 0) Die();                                              // e\\n\\n        invincible = true; // Make this invincible\\n        invincibleDone = Time.time + invincibleDuration;\\n\\n        if (dEf.knockback)\\n        { // Knockback this \\n            // Determine the direction of knockback\\n            Vector3 delta = transform.position - colld.transform.root.position;\\n            if (Mathf.Abs(delta.x) >= Mathf.Abs(delta.y))\\n            {\\n                // Knockback should be horizontal\\n                delta.x = (delta.x > 0) ? 1 : -1;\\n                delta.y = 0;\\n            }\\n            else\\n            {\\n                // Knockback should be vertical\\n                delta.x = 0;\\n                delta.y = (delta.y > 0) ? 1 : -1;\\n            }\\n\\n            // Apply knockback speed to the Rigidbody\\n            knockbackVel = delta * knockbackSpeed;\\n            rigid.velocity = knockbackVel;\\n\\n            // Set mode to knockback and set time to stop knockback\\n            knockback = true;\\n            knockbackDone = Time.time + knockbackDuration;\\n            anim.speed = 0;\\n        }\\n    }\\n\\n    void Die()\\n    {                                                             // f\\n        Destroy(gameObject);\\n    }\\n}\\n\", \"__Scripts/GateKeeper.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GateKeeper : MonoBehaviour\\n{\\n    // These consts are based on the default DelverTiles image.\\n    // If you rearrange DelverTiles you may need to change it!\\n    //Locked Door tileNums                                           // a\\n    const int lockedR = 95;\\n    const int lockedUR = 81;\\n    const int lockedUL = 80;\\n    const int lockedL = 100;\\n    const int lockedDL = 101;\\n    const int lockedDR = 102;\\n\\n    //Open Door tileNums\\n    const int openR = 48;\\n    const int openUR = 93;\\n    const int openUL = 92;\\n    const int openL = 51;\\n    const int openDL = 26;\\n    const int openDR = 27;\\n\\n    private IKeyMaster keys;\\n\\n    void Awake()\\n    {\\n        keys = GetComponent<IKeyMaster>();\\n    }\\n\\n    void OnCollisionStay(Collision coll)\\n    {                                 // b\\n        // No keys, no need to run\\n        if (keys.keyCount < 1) return;\\n\\n        // Only worry about hitting tiles\\n        Tile ti = coll.gameObject.GetComponent<Tile>();\\n        if (ti == null) return;\\n\\n        // Only open if Dray is facing the door (avoid accidental key use)\\n        int facing = keys.GetFacing();\\n        // Check whether it\'s a door tile\\n        Tile ti2;\\n        switch (ti.tileNum)\\n        {                                                // c\\n            case lockedR:\\n                if (facing != 0) return;                                     // d\\n                ti.SetTile(ti.x, ti.y, openR);\\n                break;\\n\\n            case lockedUR:\\n                if (facing != 1) return;\\n                ti.SetTile(ti.x, ti.y, openUR);\\n                ti2 = TileCamera.TILES[ti.x - 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openUL);\\n                break;\\n\\n            case lockedUL:\\n                if (facing != 1) return;\\n                ti.SetTile(ti.x, ti.y, openUL);\\n                ti2 = TileCamera.TILES[ti.x + 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openUR);\\n                break;\\n\\n            case lockedL:\\n                if (facing != 2) return;\\n                ti.SetTile(ti.x, ti.y, openL);\\n                break;\\n\\n            case lockedDL:\\n                if (facing != 3) return;\\n                ti.SetTile(ti.x, ti.y, openDL);\\n                ti2 = TileCamera.TILES[ti.x + 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openDR);\\n                break;\\n\\n            case lockedDR:\\n                if (facing != 3) return;\\n                ti.SetTile(ti.x, ti.y, openDR);\\n                ti2 = TileCamera.TILES[ti.x - 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openDL);\\n                break;\\n\\n            default:\\n                return; // Return and avoid key decrement\\n        }\\n\\n        keys.keyCount--;\\n    }\\n}\", \"__Scripts/GridMove.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GridMove : MonoBehaviour\\n{\\n    private IFacingMover mover;\\n\\n    void Awake()\\n    {\\n        mover = GetComponent<IFacingMover>();                                // a\\n    }\\n\\n    void FixedUpdate()\\n    {\\n        if (!mover.moving) return; // If not moving, nothing to do here\\n        int facing = mover.GetFacing();\\n\\n        // If we are moving in a direction, align to the grid\\n        // First, get the grid location\\n        Vector2 rPos = mover.roomPos;\\n        Vector2 rPosGrid = mover.GetRoomPosOnGrid();\\n        // This relies on IFacingMover (which uses InRoom) to choose grid spacing\\n\\n        // Then move towards the grid line\\n        float delta = 0;\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            delta = rPosGrid.y - rPos.y;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            delta = rPosGrid.x - rPos.x;\\n        }\\n        if (delta == 0) return; // Already aligned to the grid\\n\\n        float move = mover.GetSpeed() * Time.fixedDeltaTime;\\n        move = Mathf.Min(move, Mathf.Abs(delta));\\n        if (delta < 0) move = -move;\\n\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            rPos.y += move;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            rPos.x += move;\\n        }\\n\\n        mover.roomPos = rPos;\\n    }\\n}\\n\", \"__Scripts/GuiPanel.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\npublic class GuiPanel : MonoBehaviour\\n{\\n    [Header(\\\"Set in Inspector\\\")]\\n    public Dray dray;\\n    public Sprite healthEmpty;\\n    public Sprite healthHalf;\\n    public Sprite healthFull;\\n\\n    Text keyCountText;\\n    List<Image> healthImages;\\n\\n    void Start()\\n    {\\n        // Key Count\\n        Transform trans = transform.Find(\\\"Key Count\\\");                       // a\\n        keyCountText = trans.GetComponent<Text>();\\n\\n        // Health Icons\\n        Transform healthPanel = transform.Find(\\\"Health Panel\\\");\\n        healthImages = new List<Image>();\\n        if (healthPanel != null)\\n        {                                           // b\\n            for (int i = 0; i < 20; i++)\\n            {\\n                trans = healthPanel.Find(\\\"H_\\\" + i);\\n                if (trans == null) break;\\n                healthImages.Add(trans.GetComponent<Image>());\\n            }\\n        }\\n    }\\n\\n    void Update()\\n    {\\n        // Show keys                                \\n        keyCountText.text = dray.numKeys.ToString();                         // c\\n\\n        // Show health\\n        int health = dray.health;\\n        for (int i = 0; i < healthImages.Count; i++)\\n        {                           // d\\n            if (health > 1)\\n            {\\n                healthImages[i].sprite = healthFull;\\n            }\\n            else if (health == 1)\\n            {\\n                healthImages[i].sprite = healthHalf;\\n            }\\n            else\\n            {\\n                healthImages[i].sprite = healthEmpty;\\n            }\\n            health -= 2;\\n        }\\n    }\\n}\\n\", \"__Scripts/IFacingMover.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IFacingMover\\n{                                              // a\\n    int GetFacing();                                                         // b\\n    bool moving { get; }                                                     // c\\n    float GetSpeed();\\n    float gridMult { get; }                                                  // d\\n    Vector2 roomPos { get; set; }                                            // e\\n    Vector2 roomNum { get; set; }\\n    Vector2 GetRoomPosOnGrid(float mult = -1);                             // f\\n}\", \"__Scripts/IKeyMaster.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IKeyMaster\\n{\\n    int keyCount { get; set; }                                               // a\\n    int GetFacing();                                                         // b\\n}\\n\", \"__Scripts/InRoom.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class InRoom : MonoBehaviour\\n{\\n    static public float ROOM_W = 16;                                     // a\\n    static public float ROOM_H = 11;\\n    static public float WALL_T = 2;\\n\\n    static public int MAX_RM_X = 9;                                    // a\\n    static public int MAX_RM_Y = 9;\\n\\n    static public Vector2[] DOORS = new Vector2[] {                          // b\\n        new Vector2(14,   5),\\n        new Vector2(7.5f, 9),\\n        new Vector2(1,    5),\\n        new Vector2(7.5f, 1)\\n    };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public bool keepInRoom = true;\\n    public float gridMult = 1;                                    // a\\n\\n\\n    void LateUpdate()\\n    {\\n        if (keepInRoom)\\n        {                                                    // b\\n            Vector2 rPos = roomPos;                                          // c\\n            rPos.x = Mathf.Clamp(rPos.x, WALL_T, ROOM_W - 1 - WALL_T);\\n            rPos.y = Mathf.Clamp(rPos.y, WALL_T, ROOM_H - 1 - WALL_T);\\n            roomPos = rPos;                                                  // d\\n        }\\n    }\\n\\n    // Where is this character in local room coordinates?\\n    public Vector2 roomPos\\n    {                                        // b\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x %= ROOM_W;\\n            tPos.y %= ROOM_H;\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rm = roomNum;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            rm += value;\\n            transform.position = rm;\\n        }\\n    }\\n\\n    // Which room is this character in?\\n    public Vector2 roomNum\\n    {                                        // c\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x = Mathf.Floor(tPos.x / ROOM_W);\\n            tPos.y = Mathf.Floor(tPos.y / ROOM_H);\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rPos = roomPos;\\n            Vector2 rm = value;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            transform.position = rm + rPos;\\n        }\\n    }\\n\\n    // What is the closest grid location to this character?\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        if (mult == -1)\\n        {\\n            mult = gridMult;\\n        }\\n        Vector2 rPos = roomPos;\\n        rPos /= mult;\\n        rPos.x = Mathf.Round(rPos.x);\\n        rPos.y = Mathf.Round(rPos.y);\\n        rPos *= mult;\\n        return rPos;\\n    }\\n\\n}\", \"__Scripts/PickUp.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class PickUp : MonoBehaviour\\n{\\n    public enum eType { key, health, grappler }\\n\\n    public static float COLLIDER_DELAY = 0.5f;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public eType itemType;\\n\\n    // Awake() and Activate() disable the PickUp\'s Collider for 0.5 secs\\n    void Awake()\\n    {\\n        GetComponent<Collider>().enabled = false;\\n        Invoke(\\\"Activate\\\", COLLIDER_DELAY);\\n    }\\n\\n    void Activate()\\n    {\\n        GetComponent<Collider>().enabled = true;\\n    }\\n}\", \"__Scripts/Skeletos.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Skeletos : Enemy, IFacingMover\\n{                                              // a\\n    [Header(\\\"Set in Inspector: Skeletos\\\")]                                   // b\\n    public int speed = 2;\\n    public float timeThinkMin = 1f;\\n    public float timeThinkMax = 4f;\\n\\n    [Header(\\\"Set Dynamically: Skeletos\\\")]\\n    public int facing = 0;\\n    public float timeNextDecision = 0;\\n\\n    private InRoom inRm;                                                    // b\\n\\n    protected override void Awake()\\n    {                                       // c\\n        base.Awake();\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    override protected void Update()\\n    {                                      // a\\n        base.Update();\\n        if (knockback) return;\\n\\n        if (Time.time >= timeNextDecision)\\n        {                                 // c\\n            DecideDirection();\\n        }\\n        // rigid is inherited from Enemy and is initialized in Enemy.Awake()\\n        rigid.velocity = directions[facing] * speed;\\n    }\\n\\n    void DecideDirection()\\n    {                                                 // d\\n        facing = Random.Range(0, 4);\\n        timeNextDecision = Time.time + Random.Range(timeThinkMin, timeThinkMax);\\n    }\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {\\n        return facing;\\n    }\\n\\n    public bool moving { get { return true; } }                            // d\\n\\n    public float GetSpeed()\\n    {\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n}\\n\", \"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/SwordController.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class SwordController : MonoBehaviour\\n{\\n    private GameObject sword;\\n    private Dray dray;\\n\\n    void Start()\\n    {\\n        sword = transform.Find(\\\"Sword\\\").gameObject;                          // a\\n        dray = transform.parent.GetComponent<Dray>();\\n        // Deactivate the sword\\n        sword.SetActive(false);                                              // b\\n    }\\n\\n    void Update()\\n    {\\n        transform.rotation = Quaternion.Euler(0, 0, 90 * dray.facing);       // c\\n        sword.SetActive(dray.mode == Dray.eMode.attack);                     // d\\n    }\\n}\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n\\n    private BoxCollider bColl;                                           // a\\n\\n    void Awake()\\n    {\\n        bColl = GetComponent<BoxCollider>();                                 // a\\n    }\\n\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y);\\n        }\\n        else\\n        {\\n            TileCamera.SET_MAP(x, y, eTileNum); // Replace if non-default tileNum\\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum];\\n\\n        SetCollider();                                                       // b\\n    }\\n\\n    // Arrange the collider for this tile\\n    void SetCollider()\\n    {\\n        // Collider info is pulled from DelverCollisions.txt\\n        bColl.enabled = true;\\n        char c = TileCamera.COLLISIONS[tileNum];                             // c\\n        switch (c)\\n        {\\n            case \'S\': // Whole\\n                bColl.center = Vector3.zero;\\n                bColl.size = Vector3.one;\\n                break;\\n            case \'W\': // Top\\n                bColl.center = new Vector3(0, 0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'A\': // Left\\n                bColl.center = new Vector3(-0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n            case \'D\': // Right\\n                bColl.center = new Vector3(0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n\\n            // vvvvvvvv-------- These are optional --------vvvvvvvv          // d\\n            case \'Q\': // Top, Left\\n                bColl.center = new Vector3(-0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'E\': // Top, Right\\n                bColl.center = new Vector3(0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'Z\': // Bottom, left\\n                bColl.center = new Vector3(-0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'X\': // Bottom\\n                bColl.center = new Vector3(0, -0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'C\': // Bottom, Right\\n                bColl.center = new Vector3(0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            // ^^^^^^^^-------- These are optional --------^^^^^^^^          // d\\n\\n            default: // Anything else: _, |, etc.                            // e\\n                bColl.enabled = false;\\n                break;\\n        }\\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    static public string COLLISIONS;                                  // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n\\n    void Awake()\\n    {\\n        COLLISIONS = Utils.RemoveLineEndings(mapCollisions.text);          // b\\n        LoadMap();\\n    }\\n\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}, \"16 - Enemies Dropping Items on Death\": {\"__Scripts/CamFollowDray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class CamFollowDray : MonoBehaviour\\n{\\n    static public bool TRANSITIONING = false;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public InRoom drayInRm;                                            // a\\n    public float transTime = 0.5f;\\n\\n    private Vector3 p0, p1;\\n\\n    private InRoom inRm;                                                // b\\n    private float transStart;\\n\\n    void Awake()\\n    {\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    void Update()\\n    {\\n        if (TRANSITIONING)\\n        {                                                 // c\\n            float u = (Time.time - transStart) / transTime;\\n            if (u >= 1)\\n            {\\n                u = 1;\\n                TRANSITIONING = false;\\n            }\\n            transform.position = (1 - u) * p0 + u * p1;\\n        }\\n        else\\n        {                                                             // d\\n            if (drayInRm.roomNum != inRm.roomNum)\\n            {\\n                TransitionTo(drayInRm.roomNum);\\n            }\\n        }\\n    }\\n\\n    void TransitionTo(Vector2 rm)\\n    {                                        // e\\n        p0 = transform.position;\\n        inRm.roomNum = rm;\\n        p1 = transform.position + (Vector3.back * 10);\\n        transform.position = p0;\\n\\n        transStart = Time.time;\\n        TRANSITIONING = true;\\n    }\\n}\\n\", \"__Scripts/DamageEffect.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class DamageEffect : MonoBehaviour\\n{\\n    [Header(\\\"Set in Inspector\\\")]\\n    public int damage = 1;\\n    public bool knockback = true;\\n}\", \"__Scripts/Dray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Dray : MonoBehaviour, IFacingMover, IKeyMaster\\n{\\n    public enum eMode { idle, move, attack, transition, knockback }          // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float speed = 5;\\n    public float attackDuration = 0.25f;// Number of seconds to attack\\n    public float attackDelay = 0.5f;    // Delay between attacks \\n    public float transitionDelay = 0.5f;// Room transition delay  // a\\n    public int maxHealth = 10;                                  // a\\n    public float knockbackSpeed = 10;                             // b\\n    public float knockbackDuration = 0.25f;\\n    public float invincibleDuration = 0.5f;\\n\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int dirHeld = -1; // Direction of the held movement key\\n    public int facing = 1;   // Direction Dray is facing \\n    public eMode mode = eMode.idle;                                // a\\n    public int numKeys = 0;                                     // b\\n    public bool invincible = false;                              // c\\n\\n    [SerializeField]                                                         // b\\n    private int _health;\\n\\n    public int health\\n    {                                                      // c\\n        get { return _health; }\\n        set { _health = value; }\\n    }\\n\\n    private float timeAtkDone = 0;                                  // b\\n    private float timeAtkNext = 0;                                  // c;    \\n    private float transitionDone = 0;                              // a\\n    private Vector2 transitionPos;\\n    private float knockbackDone = 0;                               // d\\n    private float invincibleDone = 0;\\n    private Vector3 knockbackVel;\\n\\n    private SpriteRenderer sRend;                                           // e\\n    private Rigidbody   rigid;\\n    private Animator    anim;                                            // a\\n    private InRoom      inRm;                                            // b\\n\\n\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };             // a\\n\\n    private KeyCode[] keys = new KeyCode[] { KeyCode.RightArrow,\\n        KeyCode.UpArrow, KeyCode.LeftArrow, KeyCode.DownArrow };             // a\\n\\n\\n    void Awake()\\n    {\\n        sRend = GetComponent<SpriteRenderer>();                              // e\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();                                     // a\\n        inRm = GetComponent<InRoom>();                                       // b\\n        health = maxHealth;                                                  // d\\n    }\\n\\n    void Update()\\n    {\\n        // Check knockback and invincibility\\n        if (invincible && Time.time > invincibleDone) invincible = false;    // f\\n        sRend.color = invincible ? Color.red : Color.white;\\n        if (mode == eMode.knockback)\\n        {\\n            rigid.velocity = knockbackVel;\\n            if (Time.time < knockbackDone) return;\\n        }\\n\\n        if (mode == eMode.transition)\\n        {                                    // b\\n            rigid.velocity = Vector3.zero;\\n            anim.speed = 0;\\n            roomPos = transitionPos;  // Keeps Dray in place\\n            if (Time.time < transitionDone) return;\\n            // The following line is only reached if Time.time >= transitionDone\\n            mode = eMode.idle;\\n        }\\n\\n        //Handle Keyboard Input and manage eDrayModes\\n        dirHeld = -1;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (Input.GetKey(keys[i])) dirHeld = i;\\n        }\\n\\n        // Pressing the attack button(s)\\n        if (Input.GetKeyDown(KeyCode.Z) && Time.time >= timeAtkNext)\\n        {       // a\\n            mode = eMode.attack;\\n            timeAtkDone = Time.time + attackDuration;\\n            timeAtkNext = Time.time + attackDelay;\\n        }\\n\\n        // Finishing the attack when it\'s over\\n        if (Time.time >= timeAtkDone)\\n        {                                      // b\\n            mode = eMode.idle;\\n        }\\n\\n        // Choosing the proper mode if we\'re not attacking\\n        if (mode != eMode.attack)\\n        {                                          // c\\n            if (dirHeld == -1)\\n            {\\n                mode = eMode.idle;\\n            }\\n            else\\n            {\\n                facing = dirHeld;                                            // d\\n                mode = eMode.move;\\n            }\\n        }\\n\\n        //Act on the current mode\\n        Vector3 vel = Vector3.zero;\\n        switch (mode)\\n        {                                                      // e\\n            case eMode.attack:\\n                anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.idle:\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.move:\\n                vel = directions[dirHeld];\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 1;\\n                break;\\n        }\\n\\n        rigid.velocity = vel * speed;\\n\\n    }\\n\\n\\n    void LateUpdate()\\n    {\\n        // Get the half-grid location of this GameObject\\n        Vector2 rPos = GetRoomPosOnGrid(0.5f);  // Forces half-grid        // c\\n\\n        // Check to see whether we\'re in a Door tile\\n        int doorNum;\\n        for (doorNum = 0; doorNum < 4; doorNum++)\\n        {\\n            if (rPos == InRoom.DOORS[doorNum])\\n            {\\n                break;                                                       // d\\n            }\\n        }\\n\\n        if (doorNum > 3 || doorNum != facing) return;                      // e\\n\\n        // Move to the next room\\n        Vector2 rm = roomNum;\\n        switch (doorNum)\\n        {                                                   // f\\n            case 0:\\n                rm.x += 1;\\n                break;\\n            case 1:\\n                rm.y += 1;\\n                break;\\n            case 2:\\n                rm.x -= 1;\\n                break;\\n            case 3:\\n                rm.y -= 1;\\n                break;\\n        }\\n\\n        // Make sure that the rm we want to jump to is valid\\n        if (rm.x >= 0 && rm.x <= InRoom.MAX_RM_X)\\n        {                          // g\\n            if (rm.y >= 0 && rm.y <= InRoom.MAX_RM_Y)\\n            {\\n                roomNum = rm;\\n                transitionPos = InRoom.DOORS[(doorNum + 2) % 4];             // h\\n                roomPos = transitionPos;\\n                mode = eMode.transition;                                     // i\\n                transitionDone = Time.time + transitionDelay;\\n            }\\n        }\\n    }\\n\\n    void OnCollisionEnter(Collision coll)\\n    {\\n        if (invincible) return; // Return if Dray can\'t be damaged           // g\\n        DamageEffect dEf = coll.gameObject.GetComponent<DamageEffect>();\\n        if (dEf == null) return; // If no DamageEffect, exit this method\\n\\n        health -= dEf.damage;// Subtract the damage amount from health       // h\\n        invincible = true; // Make Dray invincible\\n        invincibleDone = Time.time + invincibleDuration;\\n\\n        if (dEf.knockback)\\n        { // Knockback Dray                               // i\\n            // Determine the direction of knockback\\n            Vector3 delta = transform.position - coll.transform.position;\\n            if (Mathf.Abs(delta.x) >= Mathf.Abs(delta.y))\\n            {\\n                // Knockback should be horizontal\\n                delta.x = (delta.x > 0) ? 1 : -1;\\n                delta.y = 0;\\n            }\\n            else\\n            {\\n                // Knockback should be vertical\\n                delta.x = 0;\\n                delta.y = (delta.y > 0) ? 1 : -1;\\n            }\\n\\n            // Apply knockback speed to the Rigidbody\\n            knockbackVel = delta * knockbackSpeed;\\n            rigid.velocity = knockbackVel;\\n\\n            // Set mode to knockback and set time to stop knockback\\n            mode = eMode.knockback;\\n            knockbackDone = Time.time + knockbackDuration;\\n        }\\n    }\\n\\n    void OnTriggerEnter(Collider colld)\\n    {\\n        PickUp pup = colld.GetComponent<PickUp>();                           // a\\n        if (pup == null) return;\\n\\n        switch (pup.itemType)\\n        {\\n            case PickUp.eType.health:\\n                health = Mathf.Min(health + 2, maxHealth);\\n                break;\\n\\n            case PickUp.eType.key:\\n                keyCount++;\\n                break;\\n        }\\n\\n        Destroy(colld.gameObject);\\n    }\\n\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {                                                 // c\\n        return facing;\\n    }\\n\\n    public bool moving\\n    {                                                     // d\\n        get\\n        {\\n            return (mode == eMode.move);\\n        }\\n    }\\n\\n    public float GetSpeed()\\n    {                                                // e\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {                                                 // f\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n\\n\\n    // Implementation of IKeyMaster\\n    public int keyCount\\n    {                                                    // d\\n        get { return numKeys; }\\n        set { numKeys = value; }\\n    }\\n}\\n\", \"__Scripts/Enemy.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Enemy : MonoBehaviour\\n{\\n    protected static Vector3[] directions = new Vector3[] {                 // a\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };\\n\\n    [Header(\\\"Set in Inspector: Enemy\\\")]\\n    public float maxHealth = 1;\\n    public float knockbackSpeed = 10;                         // a\\n    public float knockbackDuration = 0.25f;\\n    public float invincibleDuration = 0.5f;\\n    public GameObject[] randomItemDrops;                             // a\\n    public GameObject guaranteedItemDrop = null;\\n\\n\\n    [Header(\\\"Set Dynamically: Enemy\\\")]\\n    public float health;\\n    public bool invincible = false;                          // a\\n    public bool knockback = false;\\n\\n    private float invincibleDone = 0;                          // a\\n    private float knockbackDone = 0;\\n    private Vector3 knockbackVel;\\n\\n    protected Animator anim;                                        // c\\n    protected Rigidbody rigid;                                       // c\\n    protected SpriteRenderer sRend;                                       // c\\n\\n    protected virtual void Awake()\\n    {                                         // d\\n        health = maxHealth;\\n        anim = GetComponent<Animator>();\\n        rigid = GetComponent<Rigidbody>();\\n        sRend = GetComponent<SpriteRenderer>();\\n    }\\n\\n    protected virtual void Update()\\n    {                                        // b\\n        // Check knockback and invincibility\\n        if (invincible && Time.time > invincibleDone) invincible = false;\\n        sRend.color = invincible ? Color.red : Color.white;\\n        if (knockback)\\n        {\\n            rigid.velocity = knockbackVel;\\n            if (Time.time < knockbackDone) return;\\n        }\\n\\n        anim.speed = 1;                                                      // c\\n        knockback = false;\\n    }\\n\\n    void OnTriggerEnter(Collider colld)\\n    {                                  // d\\n        if (invincible) return; // Return if this can\'t be damaged \\n        DamageEffect dEf = colld.gameObject.GetComponent<DamageEffect>();\\n        if (dEf == null) return; // If no DamageEffect, exit this method\\n\\n        health -= dEf.damage; // Subtract the damage amount from health\\n        if (health <= 0) Die();                                              // e\\n\\n        invincible = true; // Make this invincible\\n        invincibleDone = Time.time + invincibleDuration;\\n\\n        if (dEf.knockback)\\n        { // Knockback this \\n            // Determine the direction of knockback\\n            Vector3 delta = transform.position - colld.transform.root.position;\\n            if (Mathf.Abs(delta.x) >= Mathf.Abs(delta.y))\\n            {\\n                // Knockback should be horizontal\\n                delta.x = (delta.x > 0) ? 1 : -1;\\n                delta.y = 0;\\n            }\\n            else\\n            {\\n                // Knockback should be vertical\\n                delta.x = 0;\\n                delta.y = (delta.y > 0) ? 1 : -1;\\n            }\\n\\n            // Apply knockback speed to the Rigidbody\\n            knockbackVel = delta * knockbackSpeed;\\n            rigid.velocity = knockbackVel;\\n\\n            // Set mode to knockback and set time to stop knockback\\n            knockback = true;\\n            knockbackDone = Time.time + knockbackDuration;\\n            anim.speed = 0;\\n        }\\n    }\\n\\n    void Die()\\n    {                                                             // f\\n        GameObject go;\\n        if (guaranteedItemDrop != null)\\n        {\\n            go = Instantiate<GameObject>(guaranteedItemDrop);\\n            go.transform.position = transform.position;\\n        }\\n        else if (randomItemDrops.Length > 0)\\n        {                             // b\\n            int n = Random.Range(0, randomItemDrops.Length);\\n            GameObject prefab = randomItemDrops[n];\\n            if (prefab != null)\\n            {\\n                go = Instantiate<GameObject>(prefab);\\n                go.transform.position = transform.position;\\n            }\\n        }\\n        Destroy(gameObject);\\n    }\\n}\\n\", \"__Scripts/GateKeeper.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GateKeeper : MonoBehaviour\\n{\\n    // These consts are based on the default DelverTiles image.\\n    // If you rearrange DelverTiles you may need to change it!\\n    //Locked Door tileNums                                           // a\\n    const int lockedR = 95;\\n    const int lockedUR = 81;\\n    const int lockedUL = 80;\\n    const int lockedL = 100;\\n    const int lockedDL = 101;\\n    const int lockedDR = 102;\\n\\n    //Open Door tileNums\\n    const int openR = 48;\\n    const int openUR = 93;\\n    const int openUL = 92;\\n    const int openL = 51;\\n    const int openDL = 26;\\n    const int openDR = 27;\\n\\n    private IKeyMaster keys;\\n\\n    void Awake()\\n    {\\n        keys = GetComponent<IKeyMaster>();\\n    }\\n\\n    void OnCollisionStay(Collision coll)\\n    {                                 // b\\n        // No keys, no need to run\\n        if (keys.keyCount < 1) return;\\n\\n        // Only worry about hitting tiles\\n        Tile ti = coll.gameObject.GetComponent<Tile>();\\n        if (ti == null) return;\\n\\n        // Only open if Dray is facing the door (avoid accidental key use)\\n        int facing = keys.GetFacing();\\n        // Check whether it\'s a door tile\\n        Tile ti2;\\n        switch (ti.tileNum)\\n        {                                                // c\\n            case lockedR:\\n                if (facing != 0) return;                                     // d\\n                ti.SetTile(ti.x, ti.y, openR);\\n                break;\\n\\n            case lockedUR:\\n                if (facing != 1) return;\\n                ti.SetTile(ti.x, ti.y, openUR);\\n                ti2 = TileCamera.TILES[ti.x - 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openUL);\\n                break;\\n\\n            case lockedUL:\\n                if (facing != 1) return;\\n                ti.SetTile(ti.x, ti.y, openUL);\\n                ti2 = TileCamera.TILES[ti.x + 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openUR);\\n                break;\\n\\n            case lockedL:\\n                if (facing != 2) return;\\n                ti.SetTile(ti.x, ti.y, openL);\\n                break;\\n\\n            case lockedDL:\\n                if (facing != 3) return;\\n                ti.SetTile(ti.x, ti.y, openDL);\\n                ti2 = TileCamera.TILES[ti.x + 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openDR);\\n                break;\\n\\n            case lockedDR:\\n                if (facing != 3) return;\\n                ti.SetTile(ti.x, ti.y, openDR);\\n                ti2 = TileCamera.TILES[ti.x - 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openDL);\\n                break;\\n\\n            default:\\n                return; // Return and avoid key decrement\\n        }\\n\\n        keys.keyCount--;\\n    }\\n}\", \"__Scripts/GridMove.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GridMove : MonoBehaviour\\n{\\n    private IFacingMover mover;\\n\\n    void Awake()\\n    {\\n        mover = GetComponent<IFacingMover>();                                // a\\n    }\\n\\n    void FixedUpdate()\\n    {\\n        if (!mover.moving) return; // If not moving, nothing to do here\\n        int facing = mover.GetFacing();\\n\\n        // If we are moving in a direction, align to the grid\\n        // First, get the grid location\\n        Vector2 rPos = mover.roomPos;\\n        Vector2 rPosGrid = mover.GetRoomPosOnGrid();\\n        // This relies on IFacingMover (which uses InRoom) to choose grid spacing\\n\\n        // Then move towards the grid line\\n        float delta = 0;\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            delta = rPosGrid.y - rPos.y;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            delta = rPosGrid.x - rPos.x;\\n        }\\n        if (delta == 0) return; // Already aligned to the grid\\n\\n        float move = mover.GetSpeed() * Time.fixedDeltaTime;\\n        move = Mathf.Min(move, Mathf.Abs(delta));\\n        if (delta < 0) move = -move;\\n\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            rPos.y += move;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            rPos.x += move;\\n        }\\n\\n        mover.roomPos = rPos;\\n    }\\n}\\n\", \"__Scripts/GuiPanel.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\npublic class GuiPanel : MonoBehaviour\\n{\\n    [Header(\\\"Set in Inspector\\\")]\\n    public Dray dray;\\n    public Sprite healthEmpty;\\n    public Sprite healthHalf;\\n    public Sprite healthFull;\\n\\n    Text keyCountText;\\n    List<Image> healthImages;\\n\\n    void Start()\\n    {\\n        // Key Count\\n        Transform trans = transform.Find(\\\"Key Count\\\");                       // a\\n        keyCountText = trans.GetComponent<Text>();\\n\\n        // Health Icons\\n        Transform healthPanel = transform.Find(\\\"Health Panel\\\");\\n        healthImages = new List<Image>();\\n        if (healthPanel != null)\\n        {                                           // b\\n            for (int i = 0; i < 20; i++)\\n            {\\n                trans = healthPanel.Find(\\\"H_\\\" + i);\\n                if (trans == null) break;\\n                healthImages.Add(trans.GetComponent<Image>());\\n            }\\n        }\\n    }\\n\\n    void Update()\\n    {\\n        // Show keys                                \\n        keyCountText.text = dray.numKeys.ToString();                         // c\\n\\n        // Show health\\n        int health = dray.health;\\n        for (int i = 0; i < healthImages.Count; i++)\\n        {                           // d\\n            if (health > 1)\\n            {\\n                healthImages[i].sprite = healthFull;\\n            }\\n            else if (health == 1)\\n            {\\n                healthImages[i].sprite = healthHalf;\\n            }\\n            else\\n            {\\n                healthImages[i].sprite = healthEmpty;\\n            }\\n            health -= 2;\\n        }\\n    }\\n}\\n\", \"__Scripts/IFacingMover.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IFacingMover\\n{                                              // a\\n    int GetFacing();                                                         // b\\n    bool moving { get; }                                                     // c\\n    float GetSpeed();\\n    float gridMult { get; }                                                  // d\\n    Vector2 roomPos { get; set; }                                            // e\\n    Vector2 roomNum { get; set; }\\n    Vector2 GetRoomPosOnGrid(float mult = -1);                             // f\\n}\", \"__Scripts/IKeyMaster.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IKeyMaster\\n{\\n    int keyCount { get; set; }                                               // a\\n    int GetFacing();                                                         // b\\n}\\n\", \"__Scripts/InRoom.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class InRoom : MonoBehaviour\\n{\\n    static public float ROOM_W = 16;                                     // a\\n    static public float ROOM_H = 11;\\n    static public float WALL_T = 2;\\n\\n    static public int MAX_RM_X = 9;                                    // a\\n    static public int MAX_RM_Y = 9;\\n\\n    static public Vector2[] DOORS = new Vector2[] {                          // b\\n        new Vector2(14,   5),\\n        new Vector2(7.5f, 9),\\n        new Vector2(1,    5),\\n        new Vector2(7.5f, 1)\\n    };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public bool keepInRoom = true;\\n    public float gridMult = 1;                                    // a\\n\\n\\n    void LateUpdate()\\n    {\\n        if (keepInRoom)\\n        {                                                    // b\\n            Vector2 rPos = roomPos;                                          // c\\n            rPos.x = Mathf.Clamp(rPos.x, WALL_T, ROOM_W - 1 - WALL_T);\\n            rPos.y = Mathf.Clamp(rPos.y, WALL_T, ROOM_H - 1 - WALL_T);\\n            roomPos = rPos;                                                  // d\\n        }\\n    }\\n\\n    // Where is this character in local room coordinates?\\n    public Vector2 roomPos\\n    {                                        // b\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x %= ROOM_W;\\n            tPos.y %= ROOM_H;\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rm = roomNum;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            rm += value;\\n            transform.position = rm;\\n        }\\n    }\\n\\n    // Which room is this character in?\\n    public Vector2 roomNum\\n    {                                        // c\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x = Mathf.Floor(tPos.x / ROOM_W);\\n            tPos.y = Mathf.Floor(tPos.y / ROOM_H);\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rPos = roomPos;\\n            Vector2 rm = value;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            transform.position = rm + rPos;\\n        }\\n    }\\n\\n    // What is the closest grid location to this character?\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        if (mult == -1)\\n        {\\n            mult = gridMult;\\n        }\\n        Vector2 rPos = roomPos;\\n        rPos /= mult;\\n        rPos.x = Mathf.Round(rPos.x);\\n        rPos.y = Mathf.Round(rPos.y);\\n        rPos *= mult;\\n        return rPos;\\n    }\\n\\n}\", \"__Scripts/PickUp.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class PickUp : MonoBehaviour\\n{\\n    public enum eType { key, health, grappler }\\n\\n    public static float COLLIDER_DELAY = 0.5f;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public eType itemType;\\n\\n    // Awake() and Activate() disable the PickUp\'s Collider for 0.5 secs\\n    void Awake()\\n    {\\n        GetComponent<Collider>().enabled = false;\\n        Invoke(\\\"Activate\\\", COLLIDER_DELAY);\\n    }\\n\\n    void Activate()\\n    {\\n        GetComponent<Collider>().enabled = true;\\n    }\\n}\", \"__Scripts/Skeletos.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Skeletos : Enemy, IFacingMover\\n{                                              // a\\n    [Header(\\\"Set in Inspector: Skeletos\\\")]                                   // b\\n    public int speed = 2;\\n    public float timeThinkMin = 1f;\\n    public float timeThinkMax = 4f;\\n\\n    [Header(\\\"Set Dynamically: Skeletos\\\")]\\n    public int facing = 0;\\n    public float timeNextDecision = 0;\\n\\n    private InRoom inRm;                                                    // b\\n\\n    protected override void Awake()\\n    {                                       // c\\n        base.Awake();\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    override protected void Update()\\n    {                                      // a\\n        base.Update();\\n        if (knockback) return;\\n\\n        if (Time.time >= timeNextDecision)\\n        {                                 // c\\n            DecideDirection();\\n        }\\n        // rigid is inherited from Enemy and is initialized in Enemy.Awake()\\n        rigid.velocity = directions[facing] * speed;\\n    }\\n\\n    void DecideDirection()\\n    {                                                 // d\\n        facing = Random.Range(0, 4);\\n        timeNextDecision = Time.time + Random.Range(timeThinkMin, timeThinkMax);\\n    }\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {\\n        return facing;\\n    }\\n\\n    public bool moving { get { return true; } }                            // d\\n\\n    public float GetSpeed()\\n    {\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n}\\n\", \"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/SwordController.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class SwordController : MonoBehaviour\\n{\\n    private GameObject sword;\\n    private Dray dray;\\n\\n    void Start()\\n    {\\n        sword = transform.Find(\\\"Sword\\\").gameObject;                          // a\\n        dray = transform.parent.GetComponent<Dray>();\\n        // Deactivate the sword\\n        sword.SetActive(false);                                              // b\\n    }\\n\\n    void Update()\\n    {\\n        transform.rotation = Quaternion.Euler(0, 0, 90 * dray.facing);       // c\\n        sword.SetActive(dray.mode == Dray.eMode.attack);                     // d\\n    }\\n}\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n\\n    private BoxCollider bColl;                                           // a\\n\\n    void Awake()\\n    {\\n        bColl = GetComponent<BoxCollider>();                                 // a\\n    }\\n\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y);\\n        }\\n        else\\n        {\\n            TileCamera.SET_MAP(x, y, eTileNum); // Replace if non-default tileNum\\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum];\\n\\n        SetCollider();                                                       // b\\n    }\\n\\n    // Arrange the collider for this tile\\n    void SetCollider()\\n    {\\n        // Collider info is pulled from DelverCollisions.txt\\n        bColl.enabled = true;\\n        char c = TileCamera.COLLISIONS[tileNum];                             // c\\n        switch (c)\\n        {\\n            case \'S\': // Whole\\n                bColl.center = Vector3.zero;\\n                bColl.size = Vector3.one;\\n                break;\\n            case \'W\': // Top\\n                bColl.center = new Vector3(0, 0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'A\': // Left\\n                bColl.center = new Vector3(-0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n            case \'D\': // Right\\n                bColl.center = new Vector3(0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n\\n            // vvvvvvvv-------- These are optional --------vvvvvvvv          // d\\n            case \'Q\': // Top, Left\\n                bColl.center = new Vector3(-0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'E\': // Top, Right\\n                bColl.center = new Vector3(0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'Z\': // Bottom, left\\n                bColl.center = new Vector3(-0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'X\': // Bottom\\n                bColl.center = new Vector3(0, -0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'C\': // Bottom, Right\\n                bColl.center = new Vector3(0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            // ^^^^^^^^-------- These are optional --------^^^^^^^^          // d\\n\\n            default: // Anything else: _, |, etc.                            // e\\n                bColl.enabled = false;\\n                break;\\n        }\\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    static public string COLLISIONS;                                  // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n\\n    void Awake()\\n    {\\n        COLLISIONS = Utils.RemoveLineEndings(mapCollisions.text);          // b\\n        LoadMap();\\n    }\\n\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}, \"17 - Implementing a Grappler\": {\"__Scripts/CamFollowDray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class CamFollowDray : MonoBehaviour\\n{\\n    static public bool TRANSITIONING = false;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public InRoom drayInRm;                                            // a\\n    public float transTime = 0.5f;\\n\\n    private Vector3 p0, p1;\\n\\n    private InRoom inRm;                                                // b\\n    private float transStart;\\n\\n    void Awake()\\n    {\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    void Update()\\n    {\\n        if (TRANSITIONING)\\n        {                                                 // c\\n            float u = (Time.time - transStart) / transTime;\\n            if (u >= 1)\\n            {\\n                u = 1;\\n                TRANSITIONING = false;\\n            }\\n            transform.position = (1 - u) * p0 + u * p1;\\n        }\\n        else\\n        {                                                             // d\\n            if (drayInRm.roomNum != inRm.roomNum)\\n            {\\n                TransitionTo(drayInRm.roomNum);\\n            }\\n        }\\n    }\\n\\n    void TransitionTo(Vector2 rm)\\n    {                                        // e\\n        p0 = transform.position;\\n        inRm.roomNum = rm;\\n        p1 = transform.position + (Vector3.back * 10);\\n        transform.position = p0;\\n\\n        transStart = Time.time;\\n        TRANSITIONING = true;\\n    }\\n}\\n\", \"__Scripts/DamageEffect.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class DamageEffect : MonoBehaviour\\n{\\n    [Header(\\\"Set in Inspector\\\")]\\n    public int damage = 1;\\n    public bool knockback = true;\\n}\", \"__Scripts/Dray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Dray : MonoBehaviour, IFacingMover, IKeyMaster\\n{\\n    public enum eMode { idle, move, attack, transition, knockback }          // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float speed = 5;\\n    public float attackDuration = 0.25f;// Number of seconds to attack\\n    public float attackDelay = 0.5f;    // Delay between attacks \\n    public float transitionDelay = 0.5f;// Room transition delay  // a\\n    public int maxHealth = 10;                                  // a\\n    public float knockbackSpeed = 10;                             // b\\n    public float knockbackDuration = 0.25f;\\n    public float invincibleDuration = 0.5f;\\n\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int dirHeld = -1; // Direction of the held movement key\\n    public int facing = 1;   // Direction Dray is facing \\n    public eMode mode = eMode.idle;                                // a\\n    public int numKeys = 0;                                     // b\\n    public bool invincible = false;                              // c\\n    public bool hasGrappler = false;\\n    public Vector3 lastSafeLoc;                                     // a\\n    public int lastSafeFacing;\\n\\n    [SerializeField]                                                         // b\\n    private int _health;\\n\\n    public int health\\n    {                                                      // c\\n        get { return _health; }\\n        set { _health = value; }\\n    }\\n\\n    private float timeAtkDone = 0;                                  // b\\n    private float timeAtkNext = 0;                                  // c;    \\n    private float transitionDone = 0;                              // a\\n    private Vector2 transitionPos;\\n    private float knockbackDone = 0;                               // d\\n    private float invincibleDone = 0;\\n    private Vector3 knockbackVel;\\n\\n    private SpriteRenderer sRend;                                           // e\\n    private Rigidbody   rigid;\\n    private Animator    anim;                                            // a\\n    private InRoom      inRm;                                            // b\\n\\n\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };             // a\\n\\n    private KeyCode[] keys = new KeyCode[] { KeyCode.RightArrow,\\n        KeyCode.UpArrow, KeyCode.LeftArrow, KeyCode.DownArrow };             // a\\n\\n\\n    void Awake()\\n    {\\n        sRend = GetComponent<SpriteRenderer>();                              // e\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();                                     // a\\n        inRm = GetComponent<InRoom>();                                       // b\\n        health = maxHealth;                                                  // d\\n        lastSafeLoc = transform.position; // The start position is safe.\\n        lastSafeFacing = facing;\\n    }\\n\\n    void Update()\\n    {\\n        // Check knockback and invincibility\\n        if (invincible && Time.time > invincibleDone) invincible = false;    // f\\n        sRend.color = invincible ? Color.red : Color.white;\\n        if (mode == eMode.knockback)\\n        {\\n            rigid.velocity = knockbackVel;\\n            if (Time.time < knockbackDone) return;\\n        }\\n\\n        if (mode == eMode.transition)\\n        {                                    // b\\n            rigid.velocity = Vector3.zero;\\n            anim.speed = 0;\\n            roomPos = transitionPos;  // Keeps Dray in place\\n            if (Time.time < transitionDone) return;\\n            // The following line is only reached if Time.time >= transitionDone\\n            mode = eMode.idle;\\n        }\\n\\n        //Handle Keyboard Input and manage eDrayModes\\n        dirHeld = -1;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (Input.GetKey(keys[i])) dirHeld = i;\\n        }\\n\\n        // Pressing the attack button(s)\\n        if (Input.GetKeyDown(KeyCode.Z) && Time.time >= timeAtkNext)\\n        {       // a\\n            mode = eMode.attack;\\n            timeAtkDone = Time.time + attackDuration;\\n            timeAtkNext = Time.time + attackDelay;\\n        }\\n\\n        // Finishing the attack when it\'s over\\n        if (Time.time >= timeAtkDone)\\n        {                                      // b\\n            mode = eMode.idle;\\n        }\\n\\n        // Choosing the proper mode if we\'re not attacking\\n        if (mode != eMode.attack)\\n        {                                          // c\\n            if (dirHeld == -1)\\n            {\\n                mode = eMode.idle;\\n            }\\n            else\\n            {\\n                facing = dirHeld;                                            // d\\n                mode = eMode.move;\\n            }\\n        }\\n\\n        //Act on the current mode\\n        Vector3 vel = Vector3.zero;\\n        switch (mode)\\n        {                                                      // e\\n            case eMode.attack:\\n                anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.idle:\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.move:\\n                vel = directions[dirHeld];\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 1;\\n                break;\\n        }\\n\\n        rigid.velocity = vel * speed;\\n\\n    }\\n\\n\\n    void LateUpdate()\\n    {\\n        // Get the half-grid location of this GameObject\\n        Vector2 rPos = GetRoomPosOnGrid(0.5f);  // Forces half-grid        // c\\n\\n        // Check to see whether we\'re in a Door tile\\n        int doorNum;\\n        for (doorNum = 0; doorNum < 4; doorNum++)\\n        {\\n            if (rPos == InRoom.DOORS[doorNum])\\n            {\\n                break;                                                       // d\\n            }\\n        }\\n\\n        if (doorNum > 3 || doorNum != facing) return;                      // e\\n\\n        // Move to the next room\\n        Vector2 rm = roomNum;\\n        switch (doorNum)\\n        {                                                   // f\\n            case 0:\\n                rm.x += 1;\\n                break;\\n            case 1:\\n                rm.y += 1;\\n                break;\\n            case 2:\\n                rm.x -= 1;\\n                break;\\n            case 3:\\n                rm.y -= 1;\\n                break;\\n        }\\n\\n        // Make sure that the rm we want to jump to is valid\\n        if (rm.x >= 0 && rm.x <= InRoom.MAX_RM_X)\\n        {                          // g\\n            if (rm.y >= 0 && rm.y <= InRoom.MAX_RM_Y)\\n            {\\n                roomNum = rm;\\n                transitionPos = InRoom.DOORS[(doorNum + 2) % 4];             // h\\n                roomPos = transitionPos;\\n                lastSafeLoc = transform.position;                            // b\\n                lastSafeFacing = facing;\\n                mode = eMode.transition;                                     // i\\n                transitionDone = Time.time + transitionDelay;\\n            }\\n        }\\n    }\\n\\n    void OnCollisionEnter(Collision coll)\\n    {\\n        if (invincible) return; // Return if Dray can\'t be damaged           // g\\n        DamageEffect dEf = coll.gameObject.GetComponent<DamageEffect>();\\n        if (dEf == null) return; // If no DamageEffect, exit this method\\n\\n        health -= dEf.damage;// Subtract the damage amount from health       // h\\n        invincible = true; // Make Dray invincible\\n        invincibleDone = Time.time + invincibleDuration;\\n\\n        if (dEf.knockback)\\n        { // Knockback Dray                               // i\\n            // Determine the direction of knockback\\n            Vector3 delta = transform.position - coll.transform.position;\\n            if (Mathf.Abs(delta.x) >= Mathf.Abs(delta.y))\\n            {\\n                // Knockback should be horizontal\\n                delta.x = (delta.x > 0) ? 1 : -1;\\n                delta.y = 0;\\n            }\\n            else\\n            {\\n                // Knockback should be vertical\\n                delta.x = 0;\\n                delta.y = (delta.y > 0) ? 1 : -1;\\n            }\\n\\n            // Apply knockback speed to the Rigidbody\\n            knockbackVel = delta * knockbackSpeed;\\n            rigid.velocity = knockbackVel;\\n\\n            // Set mode to knockback and set time to stop knockback\\n            mode = eMode.knockback;\\n            knockbackDone = Time.time + knockbackDuration;\\n        }\\n    }\\n\\n    void OnTriggerEnter(Collider colld)\\n    {\\n        PickUp pup = colld.GetComponent<PickUp>();                           // a\\n        if (pup == null) return;\\n\\n        switch (pup.itemType)\\n        {\\n            case PickUp.eType.health:\\n                health = Mathf.Min(health + 2, maxHealth);\\n                break;\\n\\n            case PickUp.eType.key:\\n                keyCount++;\\n                break;\\n\\n            case PickUp.eType.grappler:                                      // c\\n                hasGrappler = true;\\n                break;\\n        }\\n\\n        Destroy(colld.gameObject);\\n    }\\n\\n    public void ResetInRoom(int healthLoss = 0)\\n    {                            // d\\n        transform.position = lastSafeLoc;\\n        facing = lastSafeFacing;\\n        health -= healthLoss;\\n\\n        invincible = true; // Make Dray invincible\\n        invincibleDone = Time.time + invincibleDuration;\\n    }\\n\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {                                                 // c\\n        return facing;\\n    }\\n\\n    public bool moving\\n    {                                                     // d\\n        get\\n        {\\n            return (mode == eMode.move);\\n        }\\n    }\\n\\n    public float GetSpeed()\\n    {                                                // e\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {                                                 // f\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n\\n\\n    // Implementation of IKeyMaster\\n    public int keyCount\\n    {                                                    // d\\n        get { return numKeys; }\\n        set { numKeys = value; }\\n    }\\n}\\n\", \"__Scripts/Enemy.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Enemy : MonoBehaviour\\n{\\n    protected static Vector3[] directions = new Vector3[] {                 // a\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };\\n\\n    [Header(\\\"Set in Inspector: Enemy\\\")]\\n    public float maxHealth = 1;\\n    public float knockbackSpeed = 10;                         // a\\n    public float knockbackDuration = 0.25f;\\n    public float invincibleDuration = 0.5f;\\n    public GameObject[] randomItemDrops;                             // a\\n    public GameObject guaranteedItemDrop = null;\\n\\n\\n    [Header(\\\"Set Dynamically: Enemy\\\")]\\n    public float health;\\n    public bool invincible = false;                          // a\\n    public bool knockback = false;\\n\\n    private float invincibleDone = 0;                          // a\\n    private float knockbackDone = 0;\\n    private Vector3 knockbackVel;\\n\\n    protected Animator anim;                                        // c\\n    protected Rigidbody rigid;                                       // c\\n    protected SpriteRenderer sRend;                                       // c\\n\\n    protected virtual void Awake()\\n    {                                         // d\\n        health = maxHealth;\\n        anim = GetComponent<Animator>();\\n        rigid = GetComponent<Rigidbody>();\\n        sRend = GetComponent<SpriteRenderer>();\\n    }\\n\\n    protected virtual void Update()\\n    {                                        // b\\n        // Check knockback and invincibility\\n        if (invincible && Time.time > invincibleDone) invincible = false;\\n        sRend.color = invincible ? Color.red : Color.white;\\n        if (knockback)\\n        {\\n            rigid.velocity = knockbackVel;\\n            if (Time.time < knockbackDone) return;\\n        }\\n\\n        anim.speed = 1;                                                      // c\\n        knockback = false;\\n    }\\n\\n    void OnTriggerEnter(Collider colld)\\n    {                                  // d\\n        if (invincible) return; // Return if this can\'t be damaged \\n        DamageEffect dEf = colld.gameObject.GetComponent<DamageEffect>();\\n        if (dEf == null) return; // If no DamageEffect, exit this method\\n\\n        health -= dEf.damage; // Subtract the damage amount from health\\n        if (health <= 0) Die();                                              // e\\n\\n        invincible = true; // Make this invincible\\n        invincibleDone = Time.time + invincibleDuration;\\n\\n        if (dEf.knockback)\\n        { // Knockback this \\n            // Determine the direction of knockback\\n            Vector3 delta = transform.position - colld.transform.root.position;\\n            if (Mathf.Abs(delta.x) >= Mathf.Abs(delta.y))\\n            {\\n                // Knockback should be horizontal\\n                delta.x = (delta.x > 0) ? 1 : -1;\\n                delta.y = 0;\\n            }\\n            else\\n            {\\n                // Knockback should be vertical\\n                delta.x = 0;\\n                delta.y = (delta.y > 0) ? 1 : -1;\\n            }\\n\\n            // Apply knockback speed to the Rigidbody\\n            knockbackVel = delta * knockbackSpeed;\\n            rigid.velocity = knockbackVel;\\n\\n            // Set mode to knockback and set time to stop knockback\\n            knockback = true;\\n            knockbackDone = Time.time + knockbackDuration;\\n            anim.speed = 0;\\n        }\\n    }\\n\\n    void Die()\\n    {                                                             // f\\n        GameObject go;\\n        if (guaranteedItemDrop != null)\\n        {\\n            go = Instantiate<GameObject>(guaranteedItemDrop);\\n            go.transform.position = transform.position;\\n        }\\n        else if (randomItemDrops.Length > 0)\\n        {                             // b\\n            int n = Random.Range(0, randomItemDrops.Length);\\n            GameObject prefab = randomItemDrops[n];\\n            if (prefab != null)\\n            {\\n                go = Instantiate<GameObject>(prefab);\\n                go.transform.position = transform.position;\\n            }\\n        }\\n        Destroy(gameObject);\\n    }\\n}\\n\", \"__Scripts/GateKeeper.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GateKeeper : MonoBehaviour\\n{\\n    // These consts are based on the default DelverTiles image.\\n    // If you rearrange DelverTiles you may need to change it!\\n    //Locked Door tileNums                                           // a\\n    const int lockedR = 95;\\n    const int lockedUR = 81;\\n    const int lockedUL = 80;\\n    const int lockedL = 100;\\n    const int lockedDL = 101;\\n    const int lockedDR = 102;\\n\\n    //Open Door tileNums\\n    const int openR = 48;\\n    const int openUR = 93;\\n    const int openUL = 92;\\n    const int openL = 51;\\n    const int openDL = 26;\\n    const int openDR = 27;\\n\\n    private IKeyMaster keys;\\n\\n    void Awake()\\n    {\\n        keys = GetComponent<IKeyMaster>();\\n    }\\n\\n    void OnCollisionStay(Collision coll)\\n    {                                 // b\\n        // No keys, no need to run\\n        if (keys.keyCount < 1) return;\\n\\n        // Only worry about hitting tiles\\n        Tile ti = coll.gameObject.GetComponent<Tile>();\\n        if (ti == null) return;\\n\\n        // Only open if Dray is facing the door (avoid accidental key use)\\n        int facing = keys.GetFacing();\\n        // Check whether it\'s a door tile\\n        Tile ti2;\\n        switch (ti.tileNum)\\n        {                                                // c\\n            case lockedR:\\n                if (facing != 0) return;                                     // d\\n                ti.SetTile(ti.x, ti.y, openR);\\n                break;\\n\\n            case lockedUR:\\n                if (facing != 1) return;\\n                ti.SetTile(ti.x, ti.y, openUR);\\n                ti2 = TileCamera.TILES[ti.x - 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openUL);\\n                break;\\n\\n            case lockedUL:\\n                if (facing != 1) return;\\n                ti.SetTile(ti.x, ti.y, openUL);\\n                ti2 = TileCamera.TILES[ti.x + 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openUR);\\n                break;\\n\\n            case lockedL:\\n                if (facing != 2) return;\\n                ti.SetTile(ti.x, ti.y, openL);\\n                break;\\n\\n            case lockedDL:\\n                if (facing != 3) return;\\n                ti.SetTile(ti.x, ti.y, openDL);\\n                ti2 = TileCamera.TILES[ti.x + 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openDR);\\n                break;\\n\\n            case lockedDR:\\n                if (facing != 3) return;\\n                ti.SetTile(ti.x, ti.y, openDR);\\n                ti2 = TileCamera.TILES[ti.x - 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openDL);\\n                break;\\n\\n            default:\\n                return; // Return and avoid key decrement\\n        }\\n\\n        keys.keyCount--;\\n    }\\n}\", \"__Scripts/Grapple.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Grapple : MonoBehaviour\\n{\\n    public enum eMode { none, gOut, gInMiss, gInHit }                        // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float grappleSpd = 10;\\n    public float grappleLength = 7;\\n    public float grappleInLength = 0.5f;\\n    public int unsafeTileHealthPenalty = 2;\\n    public TextAsset mapGrappleable;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eMode mode = eMode.none;\\n    // TileNums that can be grappled\\n    public List<int> grappleTiles;                                    // b\\n    public List<int> unsafeTiles;\\n\\n    private Dray dray;\\n    private Rigidbody rigid;\\n    private Animator anim;\\n    private Collider drayColld;\\n\\n    private GameObject grapHead;                                        // c\\n    private LineRenderer grapLine;\\n\\n    private Vector3 p0, p1;\\n    private int facing;\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };\\n\\n    void Awake()\\n    {\\n        string gTiles = mapGrappleable.text;                                 // d\\n        gTiles = Utils.RemoveLineEndings(gTiles);\\n        grappleTiles = new List<int>();\\n        unsafeTiles = new List<int>();\\n        for (int i = 0; i < gTiles.Length; i++)\\n        {\\n            switch (gTiles[i])\\n            {\\n                case \'S\':\\n                    grappleTiles.Add(i);\\n                    break;\\n\\n                case \'X\':\\n                    unsafeTiles.Add(i);\\n                    break;\\n            }\\n        }\\n\\n        dray = GetComponent<Dray>();\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();\\n        drayColld = GetComponent<Collider>();\\n\\n        Transform trans = transform.Find(\\\"Grappler\\\");\\n        grapHead = trans.gameObject;\\n        grapLine = grapHead.GetComponent<LineRenderer>();\\n        grapHead.SetActive(false);\\n    }\\n\\n    void Update()\\n    {\\n        if (!dray.hasGrappler) return;                                       // e\\n\\n        switch (mode)\\n        {\\n            case eMode.none:\\n                // If the grapple button is pressed \\n                if (Input.GetKeyDown(KeyCode.X))\\n                {\\n                    StartGrapple();\\n                }\\n                break;\\n        }\\n    }\\n\\n    void StartGrapple()\\n    {                                                    // f\\n        facing = dray.GetFacing();\\n        dray.enabled = false;                                                // g\\n        anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n        drayColld.enabled = false;\\n        rigid.velocity = Vector3.zero;\\n\\n        grapHead.SetActive(true);\\n\\n        p0 = transform.position + (directions[facing] * 0.5f);\\n        p1 = p0;\\n        grapHead.transform.position = p1;\\n        grapHead.transform.rotation = Quaternion.Euler(0, 0, 90 * facing);\\n\\n        grapLine.positionCount = 2;                                          // h\\n        grapLine.SetPosition(0, p0);\\n        grapLine.SetPosition(1, p1);\\n        mode = eMode.gOut;\\n    }\\n\\n    void FixedUpdate()\\n    {\\n        switch (mode)\\n        {\\n            case eMode.gOut: // Grappler shooting out                        // i\\n                p1 += directions[facing] * grappleSpd * Time.fixedDeltaTime;\\n                grapHead.transform.position = p1;\\n                grapLine.SetPosition(1, p1);\\n\\n                // Check to see whether the grapple hit anything\\n                int tileNum = TileCamera.GET_MAP(p1.x, p1.y);\\n                if (grappleTiles.IndexOf(tileNum) != -1)\\n                {\\n                    // We\'ve hit a grappleable tile!\\n                    mode = eMode.gInHit;\\n                    break;\\n                }\\n                if ((p1 - p0).magnitude >= grappleLength)\\n                {\\n                    // The grapple reached its end and didn\'t hit anything\\n                    mode = eMode.gInMiss;\\n                }\\n                break;\\n\\n            case eMode.gInMiss: // Grappler missed; return at double speed   // j\\n                p1 -= directions[facing] * 2 * grappleSpd * Time.fixedDeltaTime;\\n                if (Vector3.Dot((p1 - p0), directions[facing]) > 0)\\n                {\\n                    // The grapple is still in front of Dray\\n                    grapHead.transform.position = p1;\\n                    grapLine.SetPosition(1, p1);\\n                }\\n                else\\n                {\\n                    StopGrapple();\\n                }\\n                break;\\n\\n            case eMode.gInHit: // Grappler hit, pulling Dray to wall         // k\\n                float dist = grappleInLength + grappleSpd * Time.fixedDeltaTime;\\n                if (dist > (p1 - p0).magnitude)\\n                {\\n                    p0 = p1 - (directions[facing] * grappleInLength);\\n                    transform.position = p0;\\n                    StopGrapple();\\n                    break;\\n                }\\n                p0 += directions[facing] * grappleSpd * Time.fixedDeltaTime;\\n                transform.position = p0;\\n                grapLine.SetPosition(0, p0);\\n                grapHead.transform.position = p1;\\n                break;\\n        }\\n\\n    }\\n\\n    void StopGrapple()\\n    {                                                     // l\\n        dray.enabled = true;\\n        drayColld.enabled = true;\\n\\n        // Check for unsafe tile\\n        int tileNum = TileCamera.GET_MAP(p0.x, p0.y);\\n        if (mode == eMode.gInHit && unsafeTiles.IndexOf(tileNum) != -1)\\n        {\\n            // We landed on an unsafe tile\\n            dray.ResetInRoom(unsafeTileHealthPenalty);\\n        }\\n\\n        grapHead.SetActive(false);\\n\\n        mode = eMode.none;\\n    }\\n\\n    void OnTriggerEnter(Collider colld)\\n    {                                  // m\\n        Enemy e = colld.GetComponent<Enemy>();\\n        if (e == null) return;\\n\\n        mode = eMode.gInMiss;\\n    }\\n}\", \"__Scripts/GridMove.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GridMove : MonoBehaviour\\n{\\n    private IFacingMover mover;\\n\\n    void Awake()\\n    {\\n        mover = GetComponent<IFacingMover>();                                // a\\n    }\\n\\n    void FixedUpdate()\\n    {\\n        if (!mover.moving) return; // If not moving, nothing to do here\\n        int facing = mover.GetFacing();\\n\\n        // If we are moving in a direction, align to the grid\\n        // First, get the grid location\\n        Vector2 rPos = mover.roomPos;\\n        Vector2 rPosGrid = mover.GetRoomPosOnGrid();\\n        // This relies on IFacingMover (which uses InRoom) to choose grid spacing\\n\\n        // Then move towards the grid line\\n        float delta = 0;\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            delta = rPosGrid.y - rPos.y;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            delta = rPosGrid.x - rPos.x;\\n        }\\n        if (delta == 0) return; // Already aligned to the grid\\n\\n        float move = mover.GetSpeed() * Time.fixedDeltaTime;\\n        move = Mathf.Min(move, Mathf.Abs(delta));\\n        if (delta < 0) move = -move;\\n\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            rPos.y += move;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            rPos.x += move;\\n        }\\n\\n        mover.roomPos = rPos;\\n    }\\n}\\n\", \"__Scripts/GuiPanel.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\npublic class GuiPanel : MonoBehaviour\\n{\\n    [Header(\\\"Set in Inspector\\\")]\\n    public Dray dray;\\n    public Sprite healthEmpty;\\n    public Sprite healthHalf;\\n    public Sprite healthFull;\\n\\n    Text keyCountText;\\n    List<Image> healthImages;\\n\\n    void Start()\\n    {\\n        // Key Count\\n        Transform trans = transform.Find(\\\"Key Count\\\");                       // a\\n        keyCountText = trans.GetComponent<Text>();\\n\\n        // Health Icons\\n        Transform healthPanel = transform.Find(\\\"Health Panel\\\");\\n        healthImages = new List<Image>();\\n        if (healthPanel != null)\\n        {                                           // b\\n            for (int i = 0; i < 20; i++)\\n            {\\n                trans = healthPanel.Find(\\\"H_\\\" + i);\\n                if (trans == null) break;\\n                healthImages.Add(trans.GetComponent<Image>());\\n            }\\n        }\\n    }\\n\\n    void Update()\\n    {\\n        // Show keys                                \\n        keyCountText.text = dray.numKeys.ToString();                         // c\\n\\n        // Show health\\n        int health = dray.health;\\n        for (int i = 0; i < healthImages.Count; i++)\\n        {                           // d\\n            if (health > 1)\\n            {\\n                healthImages[i].sprite = healthFull;\\n            }\\n            else if (health == 1)\\n            {\\n                healthImages[i].sprite = healthHalf;\\n            }\\n            else\\n            {\\n                healthImages[i].sprite = healthEmpty;\\n            }\\n            health -= 2;\\n        }\\n    }\\n}\\n\", \"__Scripts/IFacingMover.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IFacingMover\\n{                                              // a\\n    int GetFacing();                                                         // b\\n    bool moving { get; }                                                     // c\\n    float GetSpeed();\\n    float gridMult { get; }                                                  // d\\n    Vector2 roomPos { get; set; }                                            // e\\n    Vector2 roomNum { get; set; }\\n    Vector2 GetRoomPosOnGrid(float mult = -1);                             // f\\n}\", \"__Scripts/IKeyMaster.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IKeyMaster\\n{\\n    int keyCount { get; set; }                                               // a\\n    int GetFacing();                                                         // b\\n}\\n\", \"__Scripts/InRoom.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class InRoom : MonoBehaviour\\n{\\n    static public float ROOM_W = 16;                                     // a\\n    static public float ROOM_H = 11;\\n    static public float WALL_T = 2;\\n\\n    static public int MAX_RM_X = 9;                                    // a\\n    static public int MAX_RM_Y = 9;\\n\\n    static public Vector2[] DOORS = new Vector2[] {                          // b\\n        new Vector2(14,   5),\\n        new Vector2(7.5f, 9),\\n        new Vector2(1,    5),\\n        new Vector2(7.5f, 1)\\n    };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public bool keepInRoom = true;\\n    public float gridMult = 1;                                    // a\\n\\n\\n    void LateUpdate()\\n    {\\n        if (keepInRoom)\\n        {                                                    // b\\n            Vector2 rPos = roomPos;                                          // c\\n            rPos.x = Mathf.Clamp(rPos.x, WALL_T, ROOM_W - 1 - WALL_T);\\n            rPos.y = Mathf.Clamp(rPos.y, WALL_T, ROOM_H - 1 - WALL_T);\\n            roomPos = rPos;                                                  // d\\n        }\\n    }\\n\\n    // Where is this character in local room coordinates?\\n    public Vector2 roomPos\\n    {                                        // b\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x %= ROOM_W;\\n            tPos.y %= ROOM_H;\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rm = roomNum;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            rm += value;\\n            transform.position = rm;\\n        }\\n    }\\n\\n    // Which room is this character in?\\n    public Vector2 roomNum\\n    {                                        // c\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x = Mathf.Floor(tPos.x / ROOM_W);\\n            tPos.y = Mathf.Floor(tPos.y / ROOM_H);\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rPos = roomPos;\\n            Vector2 rm = value;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            transform.position = rm + rPos;\\n        }\\n    }\\n\\n    // What is the closest grid location to this character?\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        if (mult == -1)\\n        {\\n            mult = gridMult;\\n        }\\n        Vector2 rPos = roomPos;\\n        rPos /= mult;\\n        rPos.x = Mathf.Round(rPos.x);\\n        rPos.y = Mathf.Round(rPos.y);\\n        rPos *= mult;\\n        return rPos;\\n    }\\n\\n}\", \"__Scripts/PickUp.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class PickUp : MonoBehaviour\\n{\\n    public enum eType { key, health, grappler }\\n\\n    public static float COLLIDER_DELAY = 0.5f;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public eType itemType;\\n\\n    // Awake() and Activate() disable the PickUp\'s Collider for 0.5 secs\\n    void Awake()\\n    {\\n        GetComponent<Collider>().enabled = false;\\n        Invoke(\\\"Activate\\\", COLLIDER_DELAY);\\n    }\\n\\n    void Activate()\\n    {\\n        GetComponent<Collider>().enabled = true;\\n    }\\n}\", \"__Scripts/Skeletos.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Skeletos : Enemy, IFacingMover\\n{                                              // a\\n    [Header(\\\"Set in Inspector: Skeletos\\\")]                                   // b\\n    public int speed = 2;\\n    public float timeThinkMin = 1f;\\n    public float timeThinkMax = 4f;\\n\\n    [Header(\\\"Set Dynamically: Skeletos\\\")]\\n    public int facing = 0;\\n    public float timeNextDecision = 0;\\n\\n    private InRoom inRm;                                                    // b\\n\\n    protected override void Awake()\\n    {                                       // c\\n        base.Awake();\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    override protected void Update()\\n    {                                      // a\\n        base.Update();\\n        if (knockback) return;\\n\\n        if (Time.time >= timeNextDecision)\\n        {                                 // c\\n            DecideDirection();\\n        }\\n        // rigid is inherited from Enemy and is initialized in Enemy.Awake()\\n        rigid.velocity = directions[facing] * speed;\\n    }\\n\\n    void DecideDirection()\\n    {                                                 // d\\n        facing = Random.Range(0, 4);\\n        timeNextDecision = Time.time + Random.Range(timeThinkMin, timeThinkMax);\\n    }\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {\\n        return facing;\\n    }\\n\\n    public bool moving { get { return true; } }                            // d\\n\\n    public float GetSpeed()\\n    {\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n}\\n\", \"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/SwordController.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class SwordController : MonoBehaviour\\n{\\n    private GameObject sword;\\n    private Dray dray;\\n\\n    void Start()\\n    {\\n        sword = transform.Find(\\\"Sword\\\").gameObject;                          // a\\n        dray = transform.parent.GetComponent<Dray>();\\n        // Deactivate the sword\\n        sword.SetActive(false);                                              // b\\n    }\\n\\n    void Update()\\n    {\\n        transform.rotation = Quaternion.Euler(0, 0, 90 * dray.facing);       // c\\n        sword.SetActive(dray.mode == Dray.eMode.attack);                     // d\\n    }\\n}\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n\\n    private BoxCollider bColl;                                           // a\\n\\n    void Awake()\\n    {\\n        bColl = GetComponent<BoxCollider>();                                 // a\\n    }\\n\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y);\\n        }\\n        else\\n        {\\n            TileCamera.SET_MAP(x, y, eTileNum); // Replace if non-default tileNum\\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum];\\n\\n        SetCollider();                                                       // b\\n    }\\n\\n    // Arrange the collider for this tile\\n    void SetCollider()\\n    {\\n        // Collider info is pulled from DelverCollisions.txt\\n        bColl.enabled = true;\\n        char c = TileCamera.COLLISIONS[tileNum];                             // c\\n        switch (c)\\n        {\\n            case \'S\': // Whole\\n                bColl.center = Vector3.zero;\\n                bColl.size = Vector3.one;\\n                break;\\n            case \'W\': // Top\\n                bColl.center = new Vector3(0, 0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'A\': // Left\\n                bColl.center = new Vector3(-0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n            case \'D\': // Right\\n                bColl.center = new Vector3(0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n\\n            // vvvvvvvv-------- These are optional --------vvvvvvvv          // d\\n            case \'Q\': // Top, Left\\n                bColl.center = new Vector3(-0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'E\': // Top, Right\\n                bColl.center = new Vector3(0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'Z\': // Bottom, left\\n                bColl.center = new Vector3(-0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'X\': // Bottom\\n                bColl.center = new Vector3(0, -0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'C\': // Bottom, Right\\n                bColl.center = new Vector3(0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            // ^^^^^^^^-------- These are optional --------^^^^^^^^          // d\\n\\n            default: // Anything else: _, |, etc.                            // e\\n                bColl.enabled = false;\\n                break;\\n        }\\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    static public string COLLISIONS;                                  // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n\\n    void Awake()\\n    {\\n        COLLISIONS = Utils.RemoveLineEndings(mapCollisions.text);          // b\\n        LoadMap();\\n    }\\n\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}, \"18 - Implementing a New Dungeon--The Hat\": {\"__Scripts/CamFollowDray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class CamFollowDray : MonoBehaviour\\n{\\n    static public bool TRANSITIONING = false;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public InRoom drayInRm;                                            // a\\n    public float transTime = 0.5f;\\n\\n    private Vector3 p0, p1;\\n\\n    private InRoom inRm;                                                // b\\n    private float transStart;\\n\\n    void Awake()\\n    {\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    void Update()\\n    {\\n        if (TRANSITIONING)\\n        {                                                 // c\\n            float u = (Time.time - transStart) / transTime;\\n            if (u >= 1)\\n            {\\n                u = 1;\\n                TRANSITIONING = false;\\n            }\\n            transform.position = (1 - u) * p0 + u * p1;\\n        }\\n        else\\n        {                                                             // d\\n            if (drayInRm.roomNum != inRm.roomNum)\\n            {\\n                TransitionTo(drayInRm.roomNum);\\n            }\\n        }\\n    }\\n\\n    void TransitionTo(Vector2 rm)\\n    {                                        // e\\n        p0 = transform.position;\\n        inRm.roomNum = rm;\\n        p1 = transform.position + (Vector3.back * 10);\\n        transform.position = p0;\\n\\n        transStart = Time.time;\\n        TRANSITIONING = true;\\n    }\\n}\\n\", \"__Scripts/DamageEffect.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class DamageEffect : MonoBehaviour\\n{\\n    [Header(\\\"Set in Inspector\\\")]\\n    public int damage = 1;\\n    public bool knockback = true;\\n}\", \"__Scripts/Dray.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Dray : MonoBehaviour, IFacingMover, IKeyMaster\\n{\\n    public enum eMode { idle, move, attack, transition, knockback }          // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float speed = 5;\\n    public float attackDuration = 0.25f;// Number of seconds to attack\\n    public float attackDelay = 0.5f;    // Delay between attacks \\n    public float transitionDelay = 0.5f;// Room transition delay  // a\\n    public int maxHealth = 10;                                  // a\\n    public float knockbackSpeed = 10;                             // b\\n    public float knockbackDuration = 0.25f;\\n    public float invincibleDuration = 0.5f;\\n\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int dirHeld = -1; // Direction of the held movement key\\n    public int facing = 1;   // Direction Dray is facing \\n    public eMode mode = eMode.idle;                                // a\\n    public int numKeys = 0;                                     // b\\n    public bool invincible = false;                              // c\\n    public bool hasGrappler = false;\\n    public Vector3 lastSafeLoc;                                     // a\\n    public int lastSafeFacing;\\n\\n    [SerializeField]                                                         // b\\n    private int _health;\\n\\n    public int health\\n    {                                                      // c\\n        get { return _health; }\\n        set { _health = value; }\\n    }\\n\\n    private float timeAtkDone = 0;                                  // b\\n    private float timeAtkNext = 0;                                  // c;    \\n    private float transitionDone = 0;                              // a\\n    private Vector2 transitionPos;\\n    private float knockbackDone = 0;                               // d\\n    private float invincibleDone = 0;\\n    private Vector3 knockbackVel;\\n\\n    private SpriteRenderer sRend;                                           // e\\n    private Rigidbody   rigid;\\n    private Animator    anim;                                            // a\\n    private InRoom      inRm;                                            // b\\n\\n\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };             // a\\n\\n    private KeyCode[] keys = new KeyCode[] { KeyCode.RightArrow,\\n        KeyCode.UpArrow, KeyCode.LeftArrow, KeyCode.DownArrow };             // a\\n\\n\\n    void Awake()\\n    {\\n        sRend = GetComponent<SpriteRenderer>();                              // e\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();                                     // a\\n        inRm = GetComponent<InRoom>();                                       // b\\n        health = maxHealth;                                                  // d\\n        lastSafeLoc = transform.position; // The start position is safe.\\n        lastSafeFacing = facing;\\n    }\\n\\n    void Update()\\n    {\\n        // Check knockback and invincibility\\n        if (invincible && Time.time > invincibleDone) invincible = false;    // f\\n        sRend.color = invincible ? Color.red : Color.white;\\n        if (mode == eMode.knockback)\\n        {\\n            rigid.velocity = knockbackVel;\\n            if (Time.time < knockbackDone) return;\\n        }\\n\\n        if (mode == eMode.transition)\\n        {                                    // b\\n            rigid.velocity = Vector3.zero;\\n            anim.speed = 0;\\n            roomPos = transitionPos;  // Keeps Dray in place\\n            if (Time.time < transitionDone) return;\\n            // The following line is only reached if Time.time >= transitionDone\\n            mode = eMode.idle;\\n        }\\n\\n        //Handle Keyboard Input and manage eDrayModes\\n        dirHeld = -1;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            if (Input.GetKey(keys[i])) dirHeld = i;\\n        }\\n\\n        // Pressing the attack button(s)\\n        if (Input.GetKeyDown(KeyCode.Z) && Time.time >= timeAtkNext)\\n        {       // a\\n            mode = eMode.attack;\\n            timeAtkDone = Time.time + attackDuration;\\n            timeAtkNext = Time.time + attackDelay;\\n        }\\n\\n        // Finishing the attack when it\'s over\\n        if (Time.time >= timeAtkDone)\\n        {                                      // b\\n            mode = eMode.idle;\\n        }\\n\\n        // Choosing the proper mode if we\'re not attacking\\n        if (mode != eMode.attack)\\n        {                                          // c\\n            if (dirHeld == -1)\\n            {\\n                mode = eMode.idle;\\n            }\\n            else\\n            {\\n                facing = dirHeld;                                            // d\\n                mode = eMode.move;\\n            }\\n        }\\n\\n        //Act on the current mode\\n        Vector3 vel = Vector3.zero;\\n        switch (mode)\\n        {                                                      // e\\n            case eMode.attack:\\n                anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.idle:\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 0;\\n                break;\\n\\n            case eMode.move:\\n                vel = directions[dirHeld];\\n                anim.CrossFade(\\\"Dray_Walk_\\\" + facing, 0);\\n                anim.speed = 1;\\n                break;\\n        }\\n\\n        rigid.velocity = vel * speed;\\n\\n    }\\n\\n\\n    void LateUpdate()\\n    {\\n        // Get the half-grid location of this GameObject\\n        Vector2 rPos = GetRoomPosOnGrid(0.5f);  // Forces half-grid        // c\\n\\n        // Check to see whether we\'re in a Door tile\\n        int doorNum;\\n        for (doorNum = 0; doorNum < 4; doorNum++)\\n        {\\n            if (rPos == InRoom.DOORS[doorNum])\\n            {\\n                break;                                                       // d\\n            }\\n        }\\n\\n        if (doorNum > 3 || doorNum != facing) return;                      // e\\n\\n        // Move to the next room\\n        Vector2 rm = roomNum;\\n        switch (doorNum)\\n        {                                                   // f\\n            case 0:\\n                rm.x += 1;\\n                break;\\n            case 1:\\n                rm.y += 1;\\n                break;\\n            case 2:\\n                rm.x -= 1;\\n                break;\\n            case 3:\\n                rm.y -= 1;\\n                break;\\n        }\\n\\n        // Make sure that the rm we want to jump to is valid\\n        if (rm.x >= 0 && rm.x <= InRoom.MAX_RM_X)\\n        {                          // g\\n            if (rm.y >= 0 && rm.y <= InRoom.MAX_RM_Y)\\n            {\\n                roomNum = rm;\\n                transitionPos = InRoom.DOORS[(doorNum + 2) % 4];             // h\\n                roomPos = transitionPos;\\n                lastSafeLoc = transform.position;                            // b\\n                lastSafeFacing = facing;\\n                mode = eMode.transition;                                     // i\\n                transitionDone = Time.time + transitionDelay;\\n            }\\n        }\\n    }\\n\\n    void OnCollisionEnter(Collision coll)\\n    {\\n        if (invincible) return; // Return if Dray can\'t be damaged           // g\\n        DamageEffect dEf = coll.gameObject.GetComponent<DamageEffect>();\\n        if (dEf == null) return; // If no DamageEffect, exit this method\\n\\n        health -= dEf.damage;// Subtract the damage amount from health       // h\\n        invincible = true; // Make Dray invincible\\n        invincibleDone = Time.time + invincibleDuration;\\n\\n        if (dEf.knockback)\\n        { // Knockback Dray                               // i\\n            // Determine the direction of knockback\\n            Vector3 delta = transform.position - coll.transform.position;\\n            if (Mathf.Abs(delta.x) >= Mathf.Abs(delta.y))\\n            {\\n                // Knockback should be horizontal\\n                delta.x = (delta.x > 0) ? 1 : -1;\\n                delta.y = 0;\\n            }\\n            else\\n            {\\n                // Knockback should be vertical\\n                delta.x = 0;\\n                delta.y = (delta.y > 0) ? 1 : -1;\\n            }\\n\\n            // Apply knockback speed to the Rigidbody\\n            knockbackVel = delta * knockbackSpeed;\\n            rigid.velocity = knockbackVel;\\n\\n            // Set mode to knockback and set time to stop knockback\\n            mode = eMode.knockback;\\n            knockbackDone = Time.time + knockbackDuration;\\n        }\\n    }\\n\\n    void OnTriggerEnter(Collider colld)\\n    {\\n        PickUp pup = colld.GetComponent<PickUp>();                           // a\\n        if (pup == null) return;\\n\\n        switch (pup.itemType)\\n        {\\n            case PickUp.eType.health:\\n                health = Mathf.Min(health + 2, maxHealth);\\n                break;\\n\\n            case PickUp.eType.key:\\n                keyCount++;\\n                break;\\n\\n            case PickUp.eType.grappler:                                      // c\\n                hasGrappler = true;\\n                break;\\n        }\\n\\n        Destroy(colld.gameObject);\\n    }\\n\\n    public void ResetInRoom(int healthLoss = 0)\\n    {                            // d\\n        transform.position = lastSafeLoc;\\n        facing = lastSafeFacing;\\n        health -= healthLoss;\\n\\n        invincible = true; // Make Dray invincible\\n        invincibleDone = Time.time + invincibleDuration;\\n    }\\n\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {                                                 // c\\n        return facing;\\n    }\\n\\n    public bool moving\\n    {                                                     // d\\n        get\\n        {\\n            return (mode == eMode.move);\\n        }\\n    }\\n\\n    public float GetSpeed()\\n    {                                                // e\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {                                                 // f\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n\\n\\n    // Implementation of IKeyMaster\\n    public int keyCount\\n    {                                                    // d\\n        get { return numKeys; }\\n        set { numKeys = value; }\\n    }\\n}\\n\", \"__Scripts/Enemy.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Enemy : MonoBehaviour\\n{\\n    protected static Vector3[] directions = new Vector3[] {                 // a\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };\\n\\n    [Header(\\\"Set in Inspector: Enemy\\\")]\\n    public float maxHealth = 1;\\n    public float knockbackSpeed = 10;                         // a\\n    public float knockbackDuration = 0.25f;\\n    public float invincibleDuration = 0.5f;\\n    public GameObject[] randomItemDrops;                             // a\\n    public GameObject guaranteedItemDrop = null;\\n\\n\\n    [Header(\\\"Set Dynamically: Enemy\\\")]\\n    public float health;\\n    public bool invincible = false;                          // a\\n    public bool knockback = false;\\n\\n    private float invincibleDone = 0;                          // a\\n    private float knockbackDone = 0;\\n    private Vector3 knockbackVel;\\n\\n    protected Animator anim;                                        // c\\n    protected Rigidbody rigid;                                       // c\\n    protected SpriteRenderer sRend;                                       // c\\n\\n    protected virtual void Awake()\\n    {                                         // d\\n        health = maxHealth;\\n        anim = GetComponent<Animator>();\\n        rigid = GetComponent<Rigidbody>();\\n        sRend = GetComponent<SpriteRenderer>();\\n    }\\n\\n    protected virtual void Update()\\n    {                                        // b\\n        // Check knockback and invincibility\\n        if (invincible && Time.time > invincibleDone) invincible = false;\\n        sRend.color = invincible ? Color.red : Color.white;\\n        if (knockback)\\n        {\\n            rigid.velocity = knockbackVel;\\n            if (Time.time < knockbackDone) return;\\n        }\\n\\n        anim.speed = 1;                                                      // c\\n        knockback = false;\\n    }\\n\\n    void OnTriggerEnter(Collider colld)\\n    {                                  // d\\n        if (invincible) return; // Return if this can\'t be damaged \\n        DamageEffect dEf = colld.gameObject.GetComponent<DamageEffect>();\\n        if (dEf == null) return; // If no DamageEffect, exit this method\\n\\n        health -= dEf.damage; // Subtract the damage amount from health\\n        if (health <= 0) Die();                                              // e\\n\\n        invincible = true; // Make this invincible\\n        invincibleDone = Time.time + invincibleDuration;\\n\\n        if (dEf.knockback)\\n        { // Knockback this \\n            // Determine the direction of knockback\\n            Vector3 delta = transform.position - colld.transform.root.position;\\n            if (Mathf.Abs(delta.x) >= Mathf.Abs(delta.y))\\n            {\\n                // Knockback should be horizontal\\n                delta.x = (delta.x > 0) ? 1 : -1;\\n                delta.y = 0;\\n            }\\n            else\\n            {\\n                // Knockback should be vertical\\n                delta.x = 0;\\n                delta.y = (delta.y > 0) ? 1 : -1;\\n            }\\n\\n            // Apply knockback speed to the Rigidbody\\n            knockbackVel = delta * knockbackSpeed;\\n            rigid.velocity = knockbackVel;\\n\\n            // Set mode to knockback and set time to stop knockback\\n            knockback = true;\\n            knockbackDone = Time.time + knockbackDuration;\\n            anim.speed = 0;\\n        }\\n    }\\n\\n    void Die()\\n    {                                                             // f\\n        GameObject go;\\n        if (guaranteedItemDrop != null)\\n        {\\n            go = Instantiate<GameObject>(guaranteedItemDrop);\\n            go.transform.position = transform.position;\\n        }\\n        else if (randomItemDrops.Length > 0)\\n        {                             // b\\n            int n = Random.Range(0, randomItemDrops.Length);\\n            GameObject prefab = randomItemDrops[n];\\n            if (prefab != null)\\n            {\\n                go = Instantiate<GameObject>(prefab);\\n                go.transform.position = transform.position;\\n            }\\n        }\\n        Destroy(gameObject);\\n    }\\n}\\n\", \"__Scripts/GateKeeper.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GateKeeper : MonoBehaviour\\n{\\n    // These consts are based on the default DelverTiles image.\\n    // If you rearrange DelverTiles you may need to change it!\\n    //Locked Door tileNums                                           // a\\n    const int lockedR = 95;\\n    const int lockedUR = 81;\\n    const int lockedUL = 80;\\n    const int lockedL = 100;\\n    const int lockedDL = 101;\\n    const int lockedDR = 102;\\n\\n    //Open Door tileNums\\n    const int openR = 48;\\n    const int openUR = 93;\\n    const int openUL = 92;\\n    const int openL = 51;\\n    const int openDL = 26;\\n    const int openDR = 27;\\n\\n    private IKeyMaster keys;\\n\\n    void Awake()\\n    {\\n        keys = GetComponent<IKeyMaster>();\\n    }\\n\\n    void OnCollisionStay(Collision coll)\\n    {                                 // b\\n        // No keys, no need to run\\n        if (keys.keyCount < 1) return;\\n\\n        // Only worry about hitting tiles\\n        Tile ti = coll.gameObject.GetComponent<Tile>();\\n        if (ti == null) return;\\n\\n        // Only open if Dray is facing the door (avoid accidental key use)\\n        int facing = keys.GetFacing();\\n        // Check whether it\'s a door tile\\n        Tile ti2;\\n        switch (ti.tileNum)\\n        {                                                // c\\n            case lockedR:\\n                if (facing != 0) return;                                     // d\\n                ti.SetTile(ti.x, ti.y, openR);\\n                break;\\n\\n            case lockedUR:\\n                if (facing != 1) return;\\n                ti.SetTile(ti.x, ti.y, openUR);\\n                ti2 = TileCamera.TILES[ti.x - 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openUL);\\n                break;\\n\\n            case lockedUL:\\n                if (facing != 1) return;\\n                ti.SetTile(ti.x, ti.y, openUL);\\n                ti2 = TileCamera.TILES[ti.x + 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openUR);\\n                break;\\n\\n            case lockedL:\\n                if (facing != 2) return;\\n                ti.SetTile(ti.x, ti.y, openL);\\n                break;\\n\\n            case lockedDL:\\n                if (facing != 3) return;\\n                ti.SetTile(ti.x, ti.y, openDL);\\n                ti2 = TileCamera.TILES[ti.x + 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openDR);\\n                break;\\n\\n            case lockedDR:\\n                if (facing != 3) return;\\n                ti.SetTile(ti.x, ti.y, openDR);\\n                ti2 = TileCamera.TILES[ti.x - 1, ti.y];\\n                ti2.SetTile(ti2.x, ti2.y, openDL);\\n                break;\\n\\n            default:\\n                return; // Return and avoid key decrement\\n        }\\n\\n        keys.keyCount--;\\n    }\\n}\", \"__Scripts/Grapple.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Grapple : MonoBehaviour\\n{\\n    public enum eMode { none, gOut, gInMiss, gInHit }                        // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float grappleSpd = 10;\\n    public float grappleLength = 7;\\n    public float grappleInLength = 0.5f;\\n    public int unsafeTileHealthPenalty = 2;\\n    public TextAsset mapGrappleable;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eMode mode = eMode.none;\\n    // TileNums that can be grappled\\n    public List<int> grappleTiles;                                    // b\\n    public List<int> unsafeTiles;\\n\\n    private Dray dray;\\n    private Rigidbody rigid;\\n    private Animator anim;\\n    private Collider drayColld;\\n\\n    private GameObject grapHead;                                        // c\\n    private LineRenderer grapLine;\\n\\n    private Vector3 p0, p1;\\n    private int facing;\\n\\n    private Vector3[] directions = new Vector3[] {\\n        Vector3.right, Vector3.up, Vector3.left, Vector3.down };\\n\\n    void Awake()\\n    {\\n        string gTiles = mapGrappleable.text;                                 // d\\n        gTiles = Utils.RemoveLineEndings(gTiles);\\n        grappleTiles = new List<int>();\\n        unsafeTiles = new List<int>();\\n        for (int i = 0; i < gTiles.Length; i++)\\n        {\\n            switch (gTiles[i])\\n            {\\n                case \'S\':\\n                    grappleTiles.Add(i);\\n                    break;\\n\\n                case \'X\':\\n                    unsafeTiles.Add(i);\\n                    break;\\n            }\\n        }\\n\\n        dray = GetComponent<Dray>();\\n        rigid = GetComponent<Rigidbody>();\\n        anim = GetComponent<Animator>();\\n        drayColld = GetComponent<Collider>();\\n\\n        Transform trans = transform.Find(\\\"Grappler\\\");\\n        grapHead = trans.gameObject;\\n        grapLine = grapHead.GetComponent<LineRenderer>();\\n        grapHead.SetActive(false);\\n    }\\n\\n    void Update()\\n    {\\n        if (!dray.hasGrappler) return;                                       // e\\n\\n        switch (mode)\\n        {\\n            case eMode.none:\\n                // If the grapple button is pressed \\n                if (Input.GetKeyDown(KeyCode.X))\\n                {\\n                    StartGrapple();\\n                }\\n                break;\\n        }\\n    }\\n\\n    void StartGrapple()\\n    {                                                    // f\\n        facing = dray.GetFacing();\\n        dray.enabled = false;                                                // g\\n        anim.CrossFade(\\\"Dray_Attack_\\\" + facing, 0);\\n        drayColld.enabled = false;\\n        rigid.velocity = Vector3.zero;\\n\\n        grapHead.SetActive(true);\\n\\n        p0 = transform.position + (directions[facing] * 0.5f);\\n        p1 = p0;\\n        grapHead.transform.position = p1;\\n        grapHead.transform.rotation = Quaternion.Euler(0, 0, 90 * facing);\\n\\n        grapLine.positionCount = 2;                                          // h\\n        grapLine.SetPosition(0, p0);\\n        grapLine.SetPosition(1, p1);\\n        mode = eMode.gOut;\\n    }\\n\\n    void FixedUpdate()\\n    {\\n        switch (mode)\\n        {\\n            case eMode.gOut: // Grappler shooting out                        // i\\n                p1 += directions[facing] * grappleSpd * Time.fixedDeltaTime;\\n                grapHead.transform.position = p1;\\n                grapLine.SetPosition(1, p1);\\n\\n                // Check to see whether the grapple hit anything\\n                int tileNum = TileCamera.GET_MAP(p1.x, p1.y);\\n                if (grappleTiles.IndexOf(tileNum) != -1)\\n                {\\n                    // We\'ve hit a grappleable tile!\\n                    mode = eMode.gInHit;\\n                    break;\\n                }\\n                if ((p1 - p0).magnitude >= grappleLength)\\n                {\\n                    // The grapple reached its end and didn\'t hit anything\\n                    mode = eMode.gInMiss;\\n                }\\n                break;\\n\\n            case eMode.gInMiss: // Grappler missed; return at double speed   // j\\n                p1 -= directions[facing] * 2 * grappleSpd * Time.fixedDeltaTime;\\n                if (Vector3.Dot((p1 - p0), directions[facing]) > 0)\\n                {\\n                    // The grapple is still in front of Dray\\n                    grapHead.transform.position = p1;\\n                    grapLine.SetPosition(1, p1);\\n                }\\n                else\\n                {\\n                    StopGrapple();\\n                }\\n                break;\\n\\n            case eMode.gInHit: // Grappler hit, pulling Dray to wall         // k\\n                float dist = grappleInLength + grappleSpd * Time.fixedDeltaTime;\\n                if (dist > (p1 - p0).magnitude)\\n                {\\n                    p0 = p1 - (directions[facing] * grappleInLength);\\n                    transform.position = p0;\\n                    StopGrapple();\\n                    break;\\n                }\\n                p0 += directions[facing] * grappleSpd * Time.fixedDeltaTime;\\n                transform.position = p0;\\n                grapLine.SetPosition(0, p0);\\n                grapHead.transform.position = p1;\\n                break;\\n        }\\n\\n    }\\n\\n    void StopGrapple()\\n    {                                                     // l\\n        dray.enabled = true;\\n        drayColld.enabled = true;\\n\\n        // Check for unsafe tile\\n        int tileNum = TileCamera.GET_MAP(p0.x, p0.y);\\n        if (mode == eMode.gInHit && unsafeTiles.IndexOf(tileNum) != -1)\\n        {\\n            // We landed on an unsafe tile\\n            dray.ResetInRoom(unsafeTileHealthPenalty);\\n        }\\n\\n        grapHead.SetActive(false);\\n\\n        mode = eMode.none;\\n    }\\n\\n    void OnTriggerEnter(Collider colld)\\n    {                                  // m\\n        Enemy e = colld.GetComponent<Enemy>();\\n        if (e == null) return;\\n\\n        mode = eMode.gInMiss;\\n    }\\n}\", \"__Scripts/GridMove.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class GridMove : MonoBehaviour\\n{\\n    private IFacingMover mover;\\n\\n    void Awake()\\n    {\\n        mover = GetComponent<IFacingMover>();                                // a\\n    }\\n\\n    void FixedUpdate()\\n    {\\n        if (!mover.moving) return; // If not moving, nothing to do here\\n        int facing = mover.GetFacing();\\n\\n        // If we are moving in a direction, align to the grid\\n        // First, get the grid location\\n        Vector2 rPos = mover.roomPos;\\n        Vector2 rPosGrid = mover.GetRoomPosOnGrid();\\n        // This relies on IFacingMover (which uses InRoom) to choose grid spacing\\n\\n        // Then move towards the grid line\\n        float delta = 0;\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            delta = rPosGrid.y - rPos.y;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            delta = rPosGrid.x - rPos.x;\\n        }\\n        if (delta == 0) return; // Already aligned to the grid\\n\\n        float move = mover.GetSpeed() * Time.fixedDeltaTime;\\n        move = Mathf.Min(move, Mathf.Abs(delta));\\n        if (delta < 0) move = -move;\\n\\n        if (facing == 0 || facing == 2)\\n        {\\n            // Horizontal movement, align to y grid\\n            rPos.y += move;\\n        }\\n        else\\n        {\\n            // Vertical movement, align to x grid\\n            rPos.x += move;\\n        }\\n\\n        mover.roomPos = rPos;\\n    }\\n}\\n\", \"__Scripts/GuiPanel.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\npublic class GuiPanel : MonoBehaviour\\n{\\n    [Header(\\\"Set in Inspector\\\")]\\n    public Dray dray;\\n    public Sprite healthEmpty;\\n    public Sprite healthHalf;\\n    public Sprite healthFull;\\n\\n    Text keyCountText;\\n    List<Image> healthImages;\\n\\n    void Start()\\n    {\\n        // Key Count\\n        Transform trans = transform.Find(\\\"Key Count\\\");                       // a\\n        keyCountText = trans.GetComponent<Text>();\\n\\n        // Health Icons\\n        Transform healthPanel = transform.Find(\\\"Health Panel\\\");\\n        healthImages = new List<Image>();\\n        if (healthPanel != null)\\n        {                                           // b\\n            for (int i = 0; i < 20; i++)\\n            {\\n                trans = healthPanel.Find(\\\"H_\\\" + i);\\n                if (trans == null) break;\\n                healthImages.Add(trans.GetComponent<Image>());\\n            }\\n        }\\n    }\\n\\n    void Update()\\n    {\\n        // Show keys                                \\n        keyCountText.text = dray.numKeys.ToString();                         // c\\n\\n        // Show health\\n        int health = dray.health;\\n        for (int i = 0; i < healthImages.Count; i++)\\n        {                           // d\\n            if (health > 1)\\n            {\\n                healthImages[i].sprite = healthFull;\\n            }\\n            else if (health == 1)\\n            {\\n                healthImages[i].sprite = healthHalf;\\n            }\\n            else\\n            {\\n                healthImages[i].sprite = healthEmpty;\\n            }\\n            health -= 2;\\n        }\\n    }\\n}\\n\", \"__Scripts/IFacingMover.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IFacingMover\\n{                                              // a\\n    int GetFacing();                                                         // b\\n    bool moving { get; }                                                     // c\\n    float GetSpeed();\\n    float gridMult { get; }                                                  // d\\n    Vector2 roomPos { get; set; }                                            // e\\n    Vector2 roomNum { get; set; }\\n    Vector2 GetRoomPosOnGrid(float mult = -1);                             // f\\n}\", \"__Scripts/IKeyMaster.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic interface IKeyMaster\\n{\\n    int keyCount { get; set; }                                               // a\\n    int GetFacing();                                                         // b\\n}\\n\", \"__Scripts/InRoom.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class InRoom : MonoBehaviour\\n{\\n    static public float ROOM_W = 16;                                     // a\\n    static public float ROOM_H = 11;\\n    static public float WALL_T = 2;\\n\\n    static public int MAX_RM_X = 9;                                    // a\\n    static public int MAX_RM_Y = 9;\\n\\n    static public Vector2[] DOORS = new Vector2[] {                          // b\\n        new Vector2(14,   5),\\n        new Vector2(7.5f, 9),\\n        new Vector2(1,    5),\\n        new Vector2(7.5f, 1)\\n    };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public bool keepInRoom = true;\\n    public float gridMult = 1;                                    // a\\n\\n\\n    void LateUpdate()\\n    {\\n        if (keepInRoom)\\n        {                                                    // b\\n            Vector2 rPos = roomPos;                                          // c\\n            rPos.x = Mathf.Clamp(rPos.x, WALL_T, ROOM_W - 1 - WALL_T);\\n            rPos.y = Mathf.Clamp(rPos.y, WALL_T, ROOM_H - 1 - WALL_T);\\n            roomPos = rPos;                                                  // d\\n        }\\n    }\\n\\n    // Where is this character in local room coordinates?\\n    public Vector2 roomPos\\n    {                                        // b\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x %= ROOM_W;\\n            tPos.y %= ROOM_H;\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rm = roomNum;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            rm += value;\\n            transform.position = rm;\\n        }\\n    }\\n\\n    // Which room is this character in?\\n    public Vector2 roomNum\\n    {                                        // c\\n        get\\n        {\\n            Vector2 tPos = transform.position;\\n            tPos.x = Mathf.Floor(tPos.x / ROOM_W);\\n            tPos.y = Mathf.Floor(tPos.y / ROOM_H);\\n            return tPos;\\n        }\\n        set\\n        {\\n            Vector2 rPos = roomPos;\\n            Vector2 rm = value;\\n            rm.x *= ROOM_W;\\n            rm.y *= ROOM_H;\\n            transform.position = rm + rPos;\\n        }\\n    }\\n\\n    // What is the closest grid location to this character?\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        if (mult == -1)\\n        {\\n            mult = gridMult;\\n        }\\n        Vector2 rPos = roomPos;\\n        rPos /= mult;\\n        rPos.x = Mathf.Round(rPos.x);\\n        rPos.y = Mathf.Round(rPos.y);\\n        rPos *= mult;\\n        return rPos;\\n    }\\n\\n}\", \"__Scripts/PickUp.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class PickUp : MonoBehaviour\\n{\\n    public enum eType { key, health, grappler }\\n\\n    public static float COLLIDER_DELAY = 0.5f;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public eType itemType;\\n\\n    // Awake() and Activate() disable the PickUp\'s Collider for 0.5 secs\\n    void Awake()\\n    {\\n        GetComponent<Collider>().enabled = false;\\n        Invoke(\\\"Activate\\\", COLLIDER_DELAY);\\n    }\\n\\n    void Activate()\\n    {\\n        GetComponent<Collider>().enabled = true;\\n    }\\n}\", \"__Scripts/Skeletos.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Skeletos : Enemy, IFacingMover\\n{                                              // a\\n    [Header(\\\"Set in Inspector: Skeletos\\\")]                                   // b\\n    public int speed = 2;\\n    public float timeThinkMin = 1f;\\n    public float timeThinkMax = 4f;\\n\\n    [Header(\\\"Set Dynamically: Skeletos\\\")]\\n    public int facing = 0;\\n    public float timeNextDecision = 0;\\n\\n    private InRoom inRm;                                                    // b\\n\\n    protected override void Awake()\\n    {                                       // c\\n        base.Awake();\\n        inRm = GetComponent<InRoom>();\\n    }\\n\\n    override protected void Update()\\n    {                                      // a\\n        base.Update();\\n        if (knockback) return;\\n\\n        if (Time.time >= timeNextDecision)\\n        {                                 // c\\n            DecideDirection();\\n        }\\n        // rigid is inherited from Enemy and is initialized in Enemy.Awake()\\n        rigid.velocity = directions[facing] * speed;\\n    }\\n\\n    void DecideDirection()\\n    {                                                 // d\\n        facing = Random.Range(0, 4);\\n        timeNextDecision = Time.time + Random.Range(timeThinkMin, timeThinkMax);\\n    }\\n\\n    // Implementation of IFacingMover\\n    public int GetFacing()\\n    {\\n        return facing;\\n    }\\n\\n    public bool moving { get { return true; } }                            // d\\n\\n    public float GetSpeed()\\n    {\\n        return speed;\\n    }\\n\\n    public float gridMult\\n    {\\n        get { return inRm.gridMult; }\\n    }\\n\\n    public Vector2 roomPos\\n    {\\n        get { return inRm.roomPos; }\\n        set { inRm.roomPos = value; }\\n    }\\n\\n    public Vector2 roomNum\\n    {\\n        get { return inRm.roomNum; }\\n        set { inRm.roomNum = value; }\\n    }\\n\\n    public Vector2 GetRoomPosOnGrid(float mult = -1)\\n    {\\n        return inRm.GetRoomPosOnGrid(mult);\\n    }\\n}\\n\", \"__Scripts/Spiker.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Spiker : MonoBehaviour {\\n/*\\n    enum eMode { search, attack, retract };\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float            sensorRange = 0.75f;\\n    public float            attackSpeed = 6;\\n    public float            retractSpeed = 3;\\n    public float            radius = 0.4f;\\n\\n    private eMode           mode = eMode.search;\\n    private InRoom          inRm;\\n    private Dray            dray;\\n    private SphereCollider  drayColld;\\n    private Vector3         p0, p1;\\n    private DamageEffect    dEf;\\n\\n\\tvoid Start () {\\n        inRm = GetComponent<InRoom>();\\n\\n        GameObject go = GameObject.Find(\\\"Dray\\\");\\n        dray = go.GetComponent<Dray>();\\n        drayColld = go.GetComponent<SphereCollider>();\\n        dEf = GetComponent<DamageEffect>();\\n\\t}\\n\\t\\n\\tvoid Update () {\\n        switch (mode) {\\n            case eMode.search:\\n                // Check whether Dray is in the same room\\n                if (dray.roomNum != inRm.roomNum) return;\\n\\n                float moveAmt;\\n                if ( Mathf.Abs( dray.roomPos.x - inRm.roomPos.x ) < sensorRange ) {\\n                    // Attack Vertically\\n                    moveAmt = ( InRoom.ROOM_H - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    // The -0.5f above accounts for radius of Spiker\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.y < InRoom.ROOM_H/2) {\\n                        p1.y += moveAmt; \\n                    } else {\\n                        p1.y -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n\\n                if ( Mathf.Abs( dray.roomPos.y - inRm.roomPos.y ) < sensorRange ) {\\n                    // Attack Horizontally\\n                    moveAmt = ( InRoom.ROOM_W - (InRoom.WALL_T*2) )/2 - 1;//0.5f;\\n                    p1 = p0 = transform.position;\\n                    if (inRm.roomPos.x < InRoom.ROOM_W/2) {\\n                        p1.x += moveAmt; \\n                    } else {\\n                        p1.x -= moveAmt;\\n                    }\\n                    mode = eMode.attack;\\n                }\\n                break;\\n        }\\n    }\\n\\n    void FixedUpdate() {\\n        Vector3 dir, pos, delta;\\n\\n        switch (mode) {\\n            case eMode.attack:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * attackSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p1-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p1;\\n                    mode = eMode.retract;\\n                    break;\\n                }\\n                transform.position = pos + delta;\\n\\n                // Test for collision with Dray\\n                if ( (dray.transform.position - transform.position).magnitude < radius + drayColld.radius ) {\\n                    dray.TakeDamage(dEf, transform.position);\\n                }\\n                break;\\n\\n            case eMode.retract:\\n                dir = (p1 - p0).normalized;\\n                pos = transform.position;\\n                delta = dir * retractSpeed * Time.fixedDeltaTime;\\n                if (delta.magnitude > (p0-pos).magnitude) {\\n                    // We\'re close enough to switch directions\\n                    transform.position = p0;\\n                    mode = eMode.search;\\n                    break;\\n                }\\n                transform.position = pos - delta;\\n                break;\\n\\n        }\\n\\t}\\n*/   \\n}\\n\", \"__Scripts/SwordController.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class SwordController : MonoBehaviour\\n{\\n    private GameObject sword;\\n    private Dray dray;\\n\\n    void Start()\\n    {\\n        sword = transform.Find(\\\"Sword\\\").gameObject;                          // a\\n        dray = transform.parent.GetComponent<Dray>();\\n        // Deactivate the sword\\n        sword.SetActive(false);                                              // b\\n    }\\n\\n    void Update()\\n    {\\n        transform.rotation = Quaternion.Euler(0, 0, 90 * dray.facing);       // c\\n        sword.SetActive(dray.mode == Dray.eMode.attack);                     // d\\n    }\\n}\", \"__Scripts/Tile.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\npublic class Tile : MonoBehaviour\\n{\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int x;\\n    public int y;\\n    public int tileNum;\\n\\n    private BoxCollider bColl;                                           // a\\n\\n    void Awake()\\n    {\\n        bColl = GetComponent<BoxCollider>();                                 // a\\n    }\\n\\n    public void SetTile(int eX, int eY, int eTileNum = -1)\\n    { \\n        x = eX;\\n        y = eY;\\n        transform.localPosition = new Vector3(x, y, 0);\\n        gameObject.name = x.ToString(\\\"D3\\\") + \\\"x\\\" + y.ToString(\\\"D3\\\"); \\n        if (eTileNum == -1)\\n        {\\n            eTileNum = TileCamera.GET_MAP(x, y);\\n        }\\n        else\\n        {\\n            TileCamera.SET_MAP(x, y, eTileNum); // Replace if non-default tileNum\\n        }\\n        tileNum = eTileNum;\\n        GetComponent<SpriteRenderer>().sprite = TileCamera.SPRITES[tileNum];\\n\\n        SetCollider();                                                       // b\\n    }\\n\\n    // Arrange the collider for this tile\\n    void SetCollider()\\n    {\\n        // Collider info is pulled from DelverCollisions.txt\\n        bColl.enabled = true;\\n        char c = TileCamera.COLLISIONS[tileNum];                             // c\\n        switch (c)\\n        {\\n            case \'S\': // Whole\\n                bColl.center = Vector3.zero;\\n                bColl.size = Vector3.one;\\n                break;\\n            case \'W\': // Top\\n                bColl.center = new Vector3(0, 0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'A\': // Left\\n                bColl.center = new Vector3(-0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n            case \'D\': // Right\\n                bColl.center = new Vector3(0.25f, 0, 0);\\n                bColl.size = new Vector3(0.5f, 1, 1);\\n                break;\\n\\n            // vvvvvvvv-------- These are optional --------vvvvvvvv          // d\\n            case \'Q\': // Top, Left\\n                bColl.center = new Vector3(-0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'E\': // Top, Right\\n                bColl.center = new Vector3(0.25f, 0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'Z\': // Bottom, left\\n                bColl.center = new Vector3(-0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            case \'X\': // Bottom\\n                bColl.center = new Vector3(0, -0.25f, 0);\\n                bColl.size = new Vector3(1, 0.5f, 1);\\n                break;\\n            case \'C\': // Bottom, Right\\n                bColl.center = new Vector3(0.25f, -0.25f, 0);\\n                bColl.size = new Vector3(0.5f, 0.5f, 1);\\n                break;\\n            // ^^^^^^^^-------- These are optional --------^^^^^^^^          // d\\n\\n            default: // Anything else: _, |, etc.                            // e\\n                bColl.enabled = false;\\n                break;\\n        }\\n    }\\n}\", \"__Scripts/TileCamera.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\n[System.Serializable]\\npublic class TileSwap\\n{                                                      // a\\n    public int tileNum;\\n    public GameObject swapPrefab;\\n    public GameObject guaranteedItemDrop;\\n    public int overrideTileNum = -1;\\n}\\n\\npublic class TileCamera : MonoBehaviour\\n{\\n    static private int W, H;\\n    static private int[,] MAP;\\n    static public Sprite[] SPRITES;\\n    static public Transform TILE_ANCHOR;\\n    static public Tile[,] TILES;\\n    static public string COLLISIONS;                                  // a\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public TextAsset mapData;\\n    public Texture2D mapTiles;\\n    public TextAsset mapCollisions; // This will be used later\\n    public Tile tilePrefab;\\n    public int defaultTileNum;                              // b\\n    public List<TileSwap> tileSwaps;                                   // c\\n\\n    private Dictionary<int, TileSwap> tileSwapDict;                           // c\\n    private Transform enemyAnchor, itemAnchor;\\n\\n\\n    void Awake()\\n    {\\n        COLLISIONS = Utils.RemoveLineEndings(mapCollisions.text);          // b\\n        PrepareTileSwapDict();                                               // d\\n        enemyAnchor = (new GameObject(\\\"Enemy Anchor\\\")).transform;\\n        itemAnchor = (new GameObject(\\\"Item Anchor\\\")).transform;\\n        LoadMap();\\n    }\\n\\n    public void LoadMap()\\n    {\\n        // Create the TILE_ANCHOR. All Tiles will have this as their parent.\\n        GameObject go = new GameObject(\\\"TILE_ANCHOR\\\");\\n        TILE_ANCHOR = go.transform;\\n        // Load all of the Sprites from mapTiles\\n        SPRITES = Resources.LoadAll<Sprite>(mapTiles.name); // a\\n                                                            // Read in the map data\\n        string[] lines = mapData.text.Split(\'\\\\n\'); // b\\n        H = lines.Length;\\n        string[] tileNums = lines[0].Split(\' \');\\n        W = tileNums.Length;\\n        System.Globalization.NumberStyles hexNum; // c\\n        hexNum = System.Globalization.NumberStyles.HexNumber;\\n        // Place the map data into a 2D Array for faster access\\n        MAP = new int[W, H];\\n        for (int j = 0; j < H; j++)\\n        {\\n            tileNums = lines[j].Split(\' \');\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (tileNums[i] == \\\"..\\\")\\n                {\\n                    MAP[i, j] = 0;\\n                }\\n                else\\n                {\\n                    MAP[i, j] = int.Parse(tileNums[i], hexNum); // d\\n                }\\n                CheckTileSwaps(i, j);                                         // e\\n            }\\n        }\\n        print(\\\"Parsed \\\" + SPRITES.Length + \\\" sprites.\\\"); // e\\n        print(\\\"Map size: \\\" + W + \\\" wide by \\\" + H + \\\" high\\\");\\n        ShowMap();\\n    }\\n\\n    void ShowMap()\\n    {\\n        TILES = new Tile[W, H];\\n        // Run through the entire map and instantiate Tiles where necessary\\n        for (int j = 0; j < H; j++)\\n        {\\n            for (int i = 0; i < W; i++)\\n            {\\n                if (MAP[i, j] != 0)\\n                {\\n                    Tile ti = Instantiate<Tile>(tilePrefab); // b\\n                    ti.transform.SetParent(TILE_ANCHOR);\\n                    ti.SetTile(i, j); // c\\n                    TILES[i, j] = ti;\\n                }\\n            }\\n        }\\n    }\\n\\n    void PrepareTileSwapDict()\\n    {                                             // d\\n        tileSwapDict = new Dictionary<int, TileSwap>();\\n        foreach (TileSwap ts in tileSwaps)\\n        {\\n            tileSwapDict.Add(ts.tileNum, ts);\\n        }\\n    }\\n\\n    void CheckTileSwaps(int i, int j)\\n    {                                      // e\\n        int tNum = GET_MAP(i, j);\\n        if (!tileSwapDict.ContainsKey(tNum)) return;\\n\\n        // We do need to swap a tile\\n        TileSwap ts = tileSwapDict[tNum];\\n        if (ts.swapPrefab != null)\\n        {                                         // f\\n            GameObject go = Instantiate(ts.swapPrefab);\\n            Enemy e = go.GetComponent<Enemy>();\\n            if (e != null)\\n            {\\n                go.transform.SetParent(enemyAnchor);\\n            }\\n            else\\n            {\\n                go.transform.SetParent(itemAnchor);\\n            }\\n            go.transform.position = new Vector3(i, j, 0);\\n            if (ts.guaranteedItemDrop != null)\\n            {                             // g\\n                if (e != null)\\n                {\\n                    e.guaranteedItemDrop = ts.guaranteedItemDrop;\\n                }\\n            }\\n        }\\n        // Replace with another tile\\n        if (ts.overrideTileNum == -1)\\n        {                                      // h\\n            SET_MAP(i, j, defaultTileNum);\\n        }\\n        else\\n        {\\n            SET_MAP(i, j, ts.overrideTileNum);\\n        }\\n    }\\n\\n    static public int GET_MAP(int x, int y)\\n    { // f\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return -1; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        return MAP[x, y];\\n    }\\n\\n\\n    static public int GET_MAP(float x, float y)\\n    { // A float GET_MAP() overload\\n        int tX = Mathf.RoundToInt(x);\\n        int tY = Mathf.RoundToInt(y - 0.25f); // g\\n        return GET_MAP(tX, tY);\\n    }\\n    static public void SET_MAP(int x, int y, int tNum)\\n    { // f\\n      // Additional security or a break point could be set here.\\n        if (x < 0 || x >= W || y < 0 || y >= H)\\n        {\\n            return; // Do not allow IndexOutOfRangeExceptions\\n        }\\n        MAP[x, y] = tNum;\\n    }\\n}\", \"__Scripts/ProtoTools/FloatingScore.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n// An enum to track the possible states of a FloatingScore\\npublic enum eFSState {\\n    idle,\\n    pre,\\n    active,\\n    post\\n}\\n\\n// FloatingScore can move itself on screen following a Bezier curve\\npublic class FloatingScore : MonoBehaviour {\\n    [Header(\\\"Set Dynamically\\\")]\\n    public eFSState         state = eFSState.idle;\\n    [SerializeField]\\n    private int             _score = 0;\\n    public string           scoreString;\\n\\n    // The score property sets both _score and scoreString \\n    public int score {\\n        get {\\n            return(_score); \\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\"); // \\\"N0\\\" adds commas to the num\\n            // Search \\\"C# Standard Numeric Format Strings\\\" for ToString formats\\n            GetComponent<Text>().text = scoreString;\\n        }\\n    }\\n\\n    public List<Vector2>    bezierPts; // Bezier points for movement \\n    public List<float>      fontSizes; // Bezier points for font scaling \\n    public float            timeStart = -1f;\\n    public float            timeDuration = 1f;\\n    public string           easingCurve = Easing.InOut; // Uses Easing in Utils.cs\\n\\n    // The GameObject that will receive the SendMessage when this is done moving\\n    public GameObject       reportFinishTo = null;\\n\\n    private RectTransform   rectTrans;\\n    private Text            txt;\\n\\n    // Set up the FloatingScore and movement\\n    // Note the use of parameter defaults for eTimeS & eTimeD\\n    public void Init(List<Vector2> ePts, float eTimeS = 0, float eTimeD = 1) {\\n        rectTrans = GetComponent<RectTransform>();\\n        rectTrans.anchoredPosition = Vector2.zero;\\n\\n        txt = GetComponent<Text>();\\n\\n        bezierPts = new List<Vector2>(ePts);\\n\\n        if (ePts.Count == 1) { // If there\'s only one point\\n            // ...then just go there.\\n            transform.position = ePts[0];\\n            return;\\n        }\\n\\n        // If eTimeS is the default, just start at the current time\\n        if (eTimeS == 0) eTimeS = Time.time;\\n        timeStart = eTimeS;\\n        timeDuration = eTimeD;\\n        state = eFSState.pre; // Set it to the pre state, ready to start moving\\n    }\\n\\n    public void FSCallback(FloatingScore fs) {\\n        // When this callback is called by SendMessage,\\n        //   add the score from the calling FloatingScore\\n        score += fs.score;\\n    }\\n\\n    // Update is called once per frame\\n    void Update () {\\n        // If this is not moving, just return\\n        if (state == eFSState.idle) return;\\n\\n        // Get u from the current time and duration\\n        // u ranges from 0 to 1 (usually)\\n        float u = (Time.time - timeStart)/timeDuration;\\n        // Use Easing class from Utils to curve the u value\\n        float uC = Easing.Ease (u, easingCurve);\\n        if (u<0) { // If u<0, then we shouldn\'t move yet.\\n            state = eFSState.pre;\\n            txt.enabled= false; // Hide the score initially\\n        } else {\\n            if (u>=1) { // If u>=1, we\'re done moving\\n                uC = 1; // Set uC=1 so we don\'t overshoot\\n                state = eFSState.post;\\n                if (reportFinishTo != null) { //If there\'s a callback GameObject\\n                    // Use SendMessage to call the FSCallback method\\n                    //   with this as the parameter.\\n                    reportFinishTo.SendMessage(\\\"FSCallback\\\", this);\\n                    // Now that the message has been sent,\\n                    //   Destroy this gameObject\\n                    Destroy (gameObject);\\n                } else { // If there is nothing to callback\\n                    // ...then don\'t destroy this. Just let it stay still.\\n                    state = eFSState.idle;\\n                }\\n            } else {\\n                // 0<=u<1, which means that this is active and moving\\n                state = eFSState.active;\\n                txt.enabled = true; // Show the score once more\\n            }\\n\\n            // Use Bezier curve to move this to the right point\\n            Vector2 pos = Utils.Bezier(uC, bezierPts);\\n            // RectTransform anchors can be used to position UI objects relative\\n            //   to total size of the screen\\n            rectTrans.anchorMin = rectTrans.anchorMax = pos;\\n            if (fontSizes != null && fontSizes.Count>0) {\\n                // If fontSizes has values in it\\n                // ...then adjust the fontSize of this GUIText\\n                int size = Mathf.RoundToInt( Utils.Bezier(uC, fontSizes) );\\n                GetComponent<Text>().fontSize = size;\\n            } \\n        }\\n    } \\n}\", \"__Scripts/ProtoTools/PT_XMLReader.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n\\n/*\\n<xml>\\n    <jeremy age=\\\"36\\\">\\n        <friend name=\\\"Harrison\\\">\\n            \\\"Hello\\\"\\n        </friend>\\n    </jeremy>\\n</xml>\\n\\n\\nXMLHashtable xml;\\nxml[\\\"jeremy\\\"][0][\\\"friend\\\"][0].text\\nxml[\\\"jeremy\\\"][0].att(\\\"age\\\");\\n*/\\n\\n\\n\\n[System.Serializable]\\npublic class PT_XMLReader {\\n    static public bool      SHOW_COMMENTS = false;\\n\\n    //public string input;\\n    //public TextAsset inputTA;\\n    public string xmlText;\\n    public PT_XMLHashtable xml;\\n\\n    /*\\n    void Awake() {\\n        inputTA = Resources.Load(\\\"WellFormedSample\\\") as TextAsset;  \\n        input = inputTA.text;\\n        print(input);\\n        output = new XMLHashtable();\\n        Parse(input, output);\\n        // TODO: Make something which will trace a Hashtable or output it as XML\\n        print(output[\\\"videocollection\\\"][0][\\\"video\\\"][1][\\\"title\\\"][0].text);\\n    }\\n    */\\n\\n    // This function creates a new XMLHashtable and calls the real Parse()\\n    public void Parse(string eS) {\\n        xmlText = eS;\\n        xml = new PT_XMLHashtable();\\n        Parse(eS, xml);\\n    }\\n\\n    // This function will parse a possible series of tags\\n    void Parse(string eS, PT_XMLHashtable eH) {\\n        eS = eS.Trim();\\n        // Replace any tabs with spaces\\n        eS = eS.Replace(\'\\\\t\',\' \');\\n        while(eS.Length > 0) {\\n            eS = ParseTag(eS, eH);\\n            eS = eS.Trim();\\n        }\\n    }\\n\\n    // This function parses a single tag and calls Parse() if it encounters subtags\\n    string ParseTag(string eS, PT_XMLHashtable eH) {\\n        // search for \\\"<\\\"\\n        int ndx = eS.IndexOf(\\\"<\\\");\\n        int end, end1, end2, end3;\\n        if (ndx == -1) {\\n            // It\'s possible that this is just a string (e.g. <someTagTheStringIsInside>string</someTagTheStringIsInside>)\\n            end3 = eS.IndexOf(\\\">\\\"); // This closes a standard tag; look for the closing tag\\n            if (end3 == -1) {\\n                // In that case, we just need to add an @ key/value to the hashtable\\n                eS = eS.Trim(); // I think this is redundant\\n                //eH[\\\"@\\\"] = eS;\\n                eH.text = eS;\\n            }\\n            return(\\\"\\\"); // We\'re done with this tag\\n        }\\n        // Ignore this if it is just an XML header (e.g. <?xml version=\\\"1.0\\\"?>)\\n        if (eS[ndx+1] == \'?\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"?>\\\");\\n            string header = eS.Substring(ndx, ndx2-ndx+2);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            eH.header = header;\\n            return(eS.Substring(ndx2+2));\\n        }\\n        // Ignore this if it is an XML comment (e.g. <!-- Comment text -->)\\n        if (eS[ndx+1] == \'!\') {\\n            // search for the closing tag of this header\\n            int ndx2 = eS.IndexOf(\\\"-->\\\");\\n            string comment = eS.Substring(ndx, ndx2-ndx+3);\\n            if (SHOW_COMMENTS) Debug.Log(\\\"XMl Comment: \\\"+comment);\\n            //eH[\\\"@XML_Header\\\"] = header;\\n            return(eS.Substring(ndx2+3));\\n        }\\n\\n        // Find the end of the tag name\\n        // For the next few comments, this is what happens when this character is the first one found after the beginning of the tag\\n        end1 = eS.IndexOf(\\\" \\\", ndx);    // This means that we\'ll have attributes\\n        end2 = eS.IndexOf(\\\"/\\\", ndx);    // Immediately closes the tag, \\n        end3 = eS.IndexOf(\\\">\\\", ndx);    // This closes a standard tag; look for the closing tag\\n        if (end1 == -1) end1 = int.MaxValue;\\n        if (end2 == -1) end2 = int.MaxValue;\\n        if (end3 == -1) end3 = int.MaxValue;\\n\\n\\n        end = Mathf.Min(end1, end2, end3);\\n        string tag = eS.Substring(ndx+1, end-ndx-1);\\n\\n        // search for this tag in eH. If it\'s not there, make it\\n        if (!eH.ContainsKey(tag)) {\\n            eH[tag] = new PT_XMLHashList();\\n        }\\n        // Create a hashtable to contain this tag\'s information\\n        PT_XMLHashList arrL = eH[tag] as PT_XMLHashList;\\n        //int thisHashIndex = arrL.Count;\\n        PT_XMLHashtable thisHash = new PT_XMLHashtable();\\n        arrL.Add(thisHash);\\n\\n        // Pull the attributes string\\n        string atts = \\\"\\\";\\n        if (end1 < end3) {\\n            try {\\n                atts = eS.Substring(end1, end3-end1);\\n            }\\n            catch(System.Exception ex) {\\n                Debug.LogException(ex);\\n                Debug.Log(\\\"break\\\");\\n            }\\n        }\\n        // Parse the attributes, which are all guaranteed to be strings\\n        string att, val;\\n        int eqNdx, spNdx;\\n        while (atts.Length > 0) {\\n            atts = atts.Trim();\\n            eqNdx = atts.IndexOf(\\\"=\\\");\\n            if (eqNdx == -1) break;\\n            //att = \\\"@\\\"+atts.Substring(0,eqNdx);\\n            att = atts.Substring(0,eqNdx);\\n            spNdx = atts.IndexOf(\\\" \\\",eqNdx);\\n            if (spNdx == -1) { // This is the last attribute and doesn\'t have a space after it\\n                val = atts.Substring(eqNdx+1);\\n                if (val[val.Length-1] == \'/\') { // If the trailing / from /> was caught, remove it\\n                    val = val.Substring(0,val.Length-1);\\n                }\\n                atts = \\\"\\\";\\n            } else { // This attribute has a space after it\\n                val = atts.Substring(eqNdx+1, spNdx - eqNdx - 2);\\n                atts = atts.Substring(spNdx);\\n            }\\n            val = val.Trim(\'\\\\\\\"\');\\n            //thisHash[att] = val; // All attributes have to be unique, so this should be okay.\\n            thisHash.attSet(att, val);\\n        }\\n\\n\\n        // Pull the subs, which is everything contained by this tag but exclusing the tags on either side (e.g. <tag att=\\\"hi\\\">.....subs.....</tag>)\\n        string subs = \\\"\\\";\\n        string leftoverString = \\\"\\\";\\n        // singleLine means this doesn\'t have a separate closing tag (e.g. <tag att=\\\"hi\\\" />)\\n        bool singleLine = (end2 == end3-1);// ? true : false;\\n        if (!singleLine) { // This is a multiline tag (e.g. <tag> ....  </tag>)\\n            // find the closing tag\\n            int close = eS.IndexOf(\\\"</\\\"+tag+\\\">\\\");\\n            // TODO: Should this do something more if there is no closing tag?\\n            if (close == -1) {\\n                Debug.Log(\\\"XMLReader ERROR: XML not well formed. Closing tag </\\\"+tag+\\\"> missing.\\\");\\n                return(\\\"\\\");\\n            }\\n            subs = eS.Substring(end3+1, close-end3-1);\\n            leftoverString = eS.Substring( eS.IndexOf(\\\">\\\",close)+1 );\\n        } else {\\n            leftoverString = eS.Substring(end3+1);\\n        }\\n\\n        subs = subs.Trim();\\n        // Call Parse if this contains subs\\n        if (subs.Length > 0) {\\n            Parse(subs, thisHash);\\n        }\\n\\n        // Trim and return the leftover string\\n        leftoverString = leftoverString.Trim();\\n        return(leftoverString);\\n\\n    }\\n\\n}\\n\\n\\n\\npublic class PT_XMLHashList {\\n    public ArrayList list = new ArrayList();\\n\\n    public PT_XMLHashtable this[int s] {\\n        get {\\n            return(list[s] as PT_XMLHashtable);\\n        }\\n        set {\\n            list[s] = value;\\n        }\\n    }\\n\\n    public void Add(PT_XMLHashtable eH) {\\n        list.Add(eH);\\n    }\\n\\n    public int Count {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n\\n    public int length {\\n        get {\\n            return(list.Count);\\n        }\\n    }\\n}\\n\\n\\npublic class PT_XMLHashtable {\\n\\n    public List<string>             keys = new List<string>();\\n    public List<PT_XMLHashList>     nodesList = new List<PT_XMLHashList>();\\n    public List<string>             attKeys = new List<string>();\\n    public List<string>             attributesList = new List<string>();\\n\\n    public PT_XMLHashList Get(string key) {\\n        int ndx = Index(key);\\n        if (ndx == -1) return(null);\\n        return( nodesList[ndx] );\\n    }\\n\\n    public void Set(string key, PT_XMLHashList val) {\\n        int ndx = Index(key);\\n        if (ndx != -1) {\\n            nodesList[ndx] = val;\\n        } else {\\n            keys.Add(key);\\n            nodesList.Add(val);\\n        }\\n    }\\n\\n    public int Index(string key) {\\n        return(keys.IndexOf(key));\\n    }\\n\\n    public int AttIndex(string attKey) {\\n        return(attKeys.IndexOf(attKey));\\n    }\\n\\n\\n    public PT_XMLHashList this[string s] {\\n        get {\\n            return( Get(s) );\\n        }\\n        set {\\n            Set( s, value );\\n        }\\n    }\\n\\n    public string att(string attKey) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) return(\\\"\\\");\\n        return( attributesList[ndx] );\\n    }\\n\\n    public void attSet(string attKey, string val) {\\n        int ndx = AttIndex(attKey);\\n        if (ndx == -1) {\\n            attKeys.Add(attKey);\\n            attributesList.Add(val);\\n        } else {\\n            attributesList[ndx] = val;\\n        }\\n    }\\n\\n    public string text {\\n        get {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string header {\\n        get {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) return( \\\"\\\" );\\n            return( attributesList[ndx] );\\n        }\\n        set {\\n            int ndx = AttIndex(\\\"@XML_Header\\\");\\n            if (ndx == -1) {\\n                attKeys.Add(\\\"@XML_Header\\\");\\n                attributesList.Add(value);\\n            } else {\\n                attributesList[ndx] = value;\\n            }\\n        }\\n    }\\n\\n\\n    public string nodes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string key in keys) {\\n                s += key+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public string attributes {\\n        get {\\n            string s = \\\"\\\";\\n            foreach (string attKey in attKeys) {\\n                s += attKey+\\\"   \\\";\\n            }\\n            return(s);\\n        }\\n    }\\n\\n    public bool ContainsKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool ContainsAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n    public bool HasKey(string key) {\\n        return( Index(key) != -1 );\\n    }\\n\\n    public bool HasAtt(string attKey) {\\n        return( AttIndex(attKey) != -1 );\\n    }\\n\\n}\\n\\n/* Old XMLHashtable Class\\n\\npublic class XMLHashtable {\\n    \\n    private Hashtable hash = new Hashtable();\\n    \\n    public XMLArrayList this[string s] {\\n        get {\\n            return(hash[s] as XMLArrayList);\\n        }\\n        set {\\n            hash[s] = value;\\n        }\\n    }\\n    \\n    public string att(string s) {\\n        return(hash[\\\"@\\\"+s] as string);\\n    }\\n    \\n    public void attSet(string s, string v) {\\n        hash[\\\"@\\\"+s] = v;\\n    }\\n    \\n    public string text {\\n        get {\\n            return(hash[\\\"@\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@\\\"] = value;\\n        }\\n    }\\n    \\n    public string header {\\n        get {\\n            return(hash[\\\"@XML_Header\\\"] as string);\\n        }\\n        set {\\n            hash[\\\"@XML_Header\\\"] = value;\\n        }\\n    }\\n    \\n    public bool ContainsKey(string tag) {\\n        return(hash.ContainsKey(tag));\\n    }\\n    \\n}\\n\\n*/\\n\\n\\n/*\\n\\n1. look for <\\n2. look for next >\\n3. look for / before the >\\n\\n\\n\\n*/\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\", \"__Scripts/ProtoTools/Scoreboard.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\nusing UnityEngine.UI;\\n\\n\\n// The Scoreboard class manages showing the score to the player\\npublic class Scoreboard : MonoBehaviour {\\n    public static Scoreboard S; // The singleton for Scoreboard\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject       prefabFloatingScore;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    [SerializeField] private int    _score = 0;\\n    [SerializeField] private string _scoreString;\\n\\n    private Transform       canvasTrans;\\n\\n    // The score property also sets the scoreString\\n    public int score {\\n        get {\\n            return(_score);\\n        }\\n        set {\\n            _score = value;\\n            scoreString = _score.ToString(\\\"N0\\\");\\n        }\\n    }\\n\\n    // The scoreString property also sets the Text.text\\n    public string scoreString {\\n        get {\\n            return(_scoreString);\\n        }\\n        set {\\n            _scoreString = value;\\n            GetComponent<Text>().text = _scoreString;\\n        }\\n    }\\n\\n    void Awake() {\\n        if (S == null) {\\n            S = this; // Set the private singleton\\n        } else {\\n            Debug.LogError(\\\"ERROR: Scoreboard.Awake(): S is already set!\\\");\\n        }\\n        canvasTrans = transform.parent;\\n    }\\n\\n    // When called by SendMessage, this adds the fs.score to this.score\\n    public void FSCallback(FloatingScore fs) {\\n        score += fs.score;\\n    }\\n\\n    // This will Instantiate a new FloatingScore GameObject and initialize it.\\n    // It also returns a pointer to the FloatingScore created so that the\\n    //   calling function can do more with it (like set fontSizes, and so on)\\n    public FloatingScore CreateFloatingScore(int amt, List<Vector2> pts) {\\n        GameObject go = Instantiate<GameObject>(prefabFloatingScore);\\n        go.transform.SetParent( canvasTrans );\\n        FloatingScore fs = go.GetComponent<FloatingScore>();\\n        fs.score = amt;\\n        fs.reportFinishTo = this.gameObject; // Set fs to call back to this\\n        fs.Init(pts);\\n        return(fs);\\n    }\\n}\\n\", \"__Scripts/ProtoTools/Utils.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing System.Collections.Generic;\\n\\n// This is actually OUTSIDE of the Utils Class\\npublic enum BoundsTest {\\n    center,     // Is the center of the GameObject on screen\\n    onScreen,   // Are the bounds entirely on screen\\n    offScreen   // Are the bounds entirely off screen\\n}\\n\\npublic class Utils : MonoBehaviour {\\n\\n\\n    //============================ Bounds Functions ============================\\\\\\n\\n    // Creates bounds that encapsulate of the two Bounds passed in.\\n    public static Bounds BoundsUnion( Bounds b0, Bounds b1 ) {\\n        // If the size of one of the bounds is Vector3.zero, ignore that one\\n        if ( b0.size==Vector3.zero && b1.size!=Vector3.zero ) {\\n            return( b1 );\\n        } else if ( b0.size!=Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        } else if ( b0.size==Vector3.zero && b1.size==Vector3.zero ) {\\n            return( b0 );\\n        }\\n        // Stretch b0 to include the b1.min and b1.max\\n        b0.Encapsulate(b1.min);\\n        b0.Encapsulate(b1.max);\\n        return( b0 );\\n    }\\n\\n    public static Bounds CombineBoundsOfChildren(GameObject go) {\\n        // Create an empty Bounds b\\n        Bounds b = new Bounds(Vector3.zero, Vector3.zero);\\n        // If this GameObject has a Renderer Component...\\n        if (go.GetComponent<Renderer>() != null) {\\n            // Expand b to contain the Renderer\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Renderer>().bounds);\\n        }\\n        // If this GameObject has a Collider Component...\\n        if (go.GetComponent<Collider>() != null) {\\n            // Expand b to contain the Collider\'s Bounds\\n            b = BoundsUnion(b, go.GetComponent<Collider>().bounds);\\n        }\\n        // Iterate through each child of this gameObject.transform\\n        foreach( Transform t in go.transform ) {\\n            // Expand b to contain their Bounds as well\\n            b = BoundsUnion( b, CombineBoundsOfChildren( t.gameObject ) );\\n        }\\n\\n        return( b );\\n    }\\n\\n    // Make a static read-only public property camBounds\\n    static public Bounds camBounds {\\n        get {\\n            // if _camBounds hasn\'t been set yet\\n            if (_camBounds.size == Vector3.zero) {\\n                // SetCameraBounds using the default Camera\\n                SetCameraBounds();\\n            }\\n            return( _camBounds );\\n        }\\n    }\\n    // This is the private static field that camBounds uses\\n    static private Bounds _camBounds;\\n\\n    public static void SetCameraBounds(Camera cam=null) {\\n        // If no Camera was passed in, use the main Camera\\n        if (cam == null) cam = Camera.main;\\n        // This makes a couple important assumptions about the camera!:\\n        //   1. The camera is Orthographic\\n        //   2. The camera is at a rotation of R:[0,0,0]\\n\\n        // Make Vector3s at the topLeft and bottomRight of the Screen coords\\n        Vector3 topLeft = new Vector3( 0, 0, 0 );\\n        Vector3 bottomRight = new Vector3( Screen.width, Screen.height, 0 );\\n\\n        // Convert these to world coordinates\\n        Vector3 boundTLN = cam.ScreenToWorldPoint( topLeft );\\n        Vector3 boundBRF = cam.ScreenToWorldPoint( bottomRight );\\n\\n        // Adjust the z to be at the near and far Camera clipping planes\\n        boundTLN.z += cam.nearClipPlane;\\n        boundBRF.z += cam.farClipPlane;\\n\\n        // Find the center of the Bounds\\n        Vector3 center = (boundTLN + boundBRF)/2f;\\n        _camBounds = new Bounds( center, Vector3.zero );\\n        // Expand _camBounds to encapsulate the extents.\\n        _camBounds.Encapsulate( boundTLN );\\n        _camBounds.Encapsulate( boundBRF );\\n    }\\n\\n\\n\\n    // Test to see whether Bounds are on screen.\\n    public static Vector3 ScreenBoundsCheck(Bounds bnd, BoundsTest test = BoundsTest.center) {\\n        // Call the more generic BoundsInBoundsCheck with camBounds as bigB\\n        return( BoundsInBoundsCheck( camBounds, bnd, test ) );\\n    }\\n\\n    // Tests to see whether lilB is inside bigB\\n    public static Vector3 BoundsInBoundsCheck( Bounds bigB, Bounds lilB, BoundsTest test = BoundsTest.onScreen ) {\\n        // Get the center of lilB\\n        Vector3 pos = lilB.center;\\n\\n        // Initialize the offset at [0,0,0]\\n        Vector3 off = Vector3.zero;\\n\\n        switch (test) {         \\n            // The center test determines what off (offset) would have to be applied to lilB to move its center back inside bigB\\n            case BoundsTest.center:\\n                // if the center is contained, return Vector3.zero\\n                if ( bigB.Contains( pos ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not contained, find the offset\\n                if (pos.x > bigB.max.x) {\\n                    off.x = pos.x - bigB.max.x;\\n                } else  if (pos.x < bigB.min.x) {\\n                    off.x = pos.x - bigB.min.x;\\n                }\\n                if (pos.y > bigB.max.y) {\\n                    off.y = pos.y - bigB.max.y;\\n                } else  if (pos.y < bigB.min.y) {\\n                    off.y = pos.y - bigB.min.y;\\n                }\\n                if (pos.z > bigB.max.z) {\\n                    off.z = pos.z - bigB.max.z;\\n                } else  if (pos.z < bigB.min.z) {\\n                    off.z = pos.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The onScreen test determines what off would have to be applied to keep all of lilB inside bigB\\n            case BoundsTest.onScreen:\\n                // find whether bigB contains all of lilB\\n                if ( bigB.Contains( lilB.min ) && bigB.Contains( lilB.max ) ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.max.x > bigB.max.x) {\\n                    off.x = lilB.max.x - bigB.max.x;\\n                } else  if (lilB.min.x < bigB.min.x) {\\n                    off.x = lilB.min.x - bigB.min.x;\\n                }\\n                if (lilB.max.y > bigB.max.y) {\\n                    off.y = lilB.max.y - bigB.max.y;\\n                } else  if (lilB.min.y < bigB.min.y) {\\n                    off.y = lilB.min.y - bigB.min.y;\\n                }\\n                if (lilB.max.z > bigB.max.z) {\\n                    off.z = lilB.max.z - bigB.max.z;\\n                } else  if (lilB.min.z < bigB.min.z) {\\n                    off.z = lilB.min.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n                // The offScreen test determines what off would need to be applied to move any tiny part of lilB inside of bigB\\n            case BoundsTest.offScreen:\\n                // find whether bigB contains any of lilB\\n                bool cMin = bigB.Contains( lilB.min );\\n                bool cMax = bigB.Contains( lilB.max );\\n                if ( cMin || cMax ) {\\n                    return( Vector3.zero );\\n                }\\n                // if not, find the offset\\n                if (lilB.min.x > bigB.max.x) {\\n                    off.x = lilB.min.x - bigB.max.x;\\n                } else  if (lilB.max.x < bigB.min.x) {\\n                    off.x = lilB.max.x - bigB.min.x;\\n                }\\n                if (lilB.min.y > bigB.max.y) {\\n                    off.y = lilB.min.y - bigB.max.y;\\n                } else  if (lilB.max.y < bigB.min.y) {\\n                    off.y = lilB.max.y - bigB.min.y;\\n                }\\n                if (lilB.min.z > bigB.max.z) {\\n                    off.z = lilB.min.z - bigB.max.z;\\n                } else  if (lilB.max.z < bigB.min.z) {\\n                    off.z = lilB.max.z - bigB.min.z;\\n                }\\n                return( off );\\n\\n        }\\n\\n        return( Vector3.zero );\\n    }\\n\\n\\n    //============================ Transform Functions ============================\\\\\\n\\n    // This function will iteratively climb up the transform.parent tree\\n    //   until it either finds a parent with a tag != \\\"Untagged\\\" or no parent\\n    public static GameObject FindTaggedParent(GameObject go) {\\n        // If this gameObject has a tag\\n        if (go.tag != \\\"Untagged\\\") {\\n            // then return this gameObject\\n            return(go);\\n        }\\n        // If there is no parent of this Transform\\n        if (go.transform.parent == null) {\\n            // We\'ve reached the end of the line with no interesting tag\\n            // So return null\\n            return( null );\\n        }\\n        // Otherwise, recursively climb up the tree\\n        return( FindTaggedParent( go.transform.parent.gameObject ) );\\n    }\\n    // This version of the function handles things if a Transform is passed in\\n    public static GameObject FindTaggedParent(Transform t) {\\n        return( FindTaggedParent( t.gameObject ) );\\n    }\\n\\n\\n\\n\\n    //============================ Materials Functions ============================\\n\\n    // Returns a list of all Materials in this GameObject or its children\\n    static public Material[] GetAllMaterials( GameObject go ) {\\n        List<Material> mats = new List<Material>();\\n        if (go.GetComponent<Renderer>() != null) {\\n            mats.Add(go.GetComponent<Renderer>().material);\\n        }\\n        foreach( Transform t in go.transform ) {\\n            mats.AddRange( GetAllMaterials( t.gameObject ) );\\n        }\\n        return( mats.ToArray() );\\n    }\\n\\n\\n\\n\\n    //============================ Linear Interpolation ============================\\n\\n    // The standard Vector Lerp functions in Unity don\'t allow for extrapolation\\n    //   (which is input u values <0 or >1), so we need to write our own functions\\n    static public Vector3 Lerp (Vector3 vFrom, Vector3 vTo, float u) {\\n        Vector3 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for Vector2\\n    static public Vector2 Lerp (Vector2 vFrom, Vector2 vTo, float u) {\\n        Vector2 res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n    // The same function for float\\n    static public float Lerp (float vFrom, float vTo, float u) {\\n        float res = (1-u)*vFrom + u*vTo;\\n        return( res );\\n    }\\n\\n\\n\\n    //============================ Bzier Curves ============================\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// LerpUnclamped is used to allow extrapolation.\\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Vector3> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Vector3 Bezier( float u, List<Vector3> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector3 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector3 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector3 res = Vector3.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector3s as input\\n    static public Vector3 Bezier( float u, params Vector3[] vecs ) {\\n        return( Bezier( u, new List<Vector3>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for Vector2\\n    static public Vector2 Bezier( float u, List<Vector2> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Vector2 l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Vector2 r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        Vector2 res = Vector2.LerpUnclamped( l, r, u );\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Vector2s as input\\n    static public Vector2 Bezier( float u, params Vector2[] vecs ) {\\n        return( Bezier( u, new List<Vector2>(vecs) ) );\\n    }\\n\\n\\n    // The same two functions for float\\n    static public float Bezier( float u, List<float> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        float l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        float r = Bezier(u, list, i0+1, i1);\\n        // The result is the Lerp of these two recursive calls to Bezier\\n        float res = (1-u)*l + u*r;\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of floats as input\\n    static public float Bezier( float u, params float[] vecs ) {\\n        return( Bezier( u, new List<float>(vecs) ) );\\n    }\\n\\n\\n    /// <summary>\\n    /// While most Bzier curves are 3 or 4 points, it is possible to have\\n    ///   any number of points using this recursive function.\\n    /// This uses the Utils.Lerp function rather than the built-in Vector3.Lerp \\n    ///   because it needs to allow extrapolation.\\n    /// The \\n    /// </summary>\\n    /// <param name=\\\"u\\\">The amount of interpolation [0..1]</param>\\n    /// <param name=\\\"list\\\">A List<Quaternion> of points to interpolate</param>\\n    /// <param name=\\\"i0\\\">The index of the left extent of the used part of the list. \\n    ///   Defaults to 0.</param>\\n    /// <param name=\\\"i1\\\">The index of the right extent of the used part of the list. \\n    ///   Defaults to -1, which is then changed to the final element of the List.</param>\\n    static public Quaternion Bezier( float u, List<Quaternion> list, int i0=0, int i1=-1 ) {\\n        // Set i1 to the last element in list\\n        if (i1 == -1) i1 = list.Count-1;\\n\\n        // If we are only looking at one element of list, return it\\n        if (i0 == i1) {\\n            return( list[i0] );\\n        }\\n\\n        // Otherwise, call Bezier again with all but the leftmost used element of list\\n        Quaternion l = Bezier(u, list, i0, i1-1);\\n        // And call Bezier again with all but the rightmost used element of list\\n        Quaternion r = Bezier(u, list, i0+1, i1);\\n        // The result is the Slerp (spherical lerp) of these two recursive calls to Bezier\\n        Quaternion res = Quaternion.SlerpUnclamped( l, r, u );\\n\\n        return( res );\\n    }\\n\\n    // This version allows an Array or a series of Quaternions as input\\n    static public Quaternion Bezier( float u, params Quaternion[] arr ) {\\n        return( Bezier( u, new List<Quaternion>(arr) ) );\\n    }\\n\\n\\n\\n    //============================ Trace & Logging Functions ============================\\n\\n    static public void tr(params object[] objs) {\\n        string s = objs[0].ToString();\\n        for (int i=1; i<objs.Length; i++) {\\n            s += \\\"\\\\t\\\"+objs[i].ToString();\\n        }\\n        print (s);\\n    }\\n    \\n\\tstatic public string RemoveLineEndings(string sIn) {\\n        if(System.String.IsNullOrEmpty(sIn)) {\\n            return sIn;\\n        }\\n        string lineSeparator = ((char) 0x2028).ToString();\\n        string paragraphSeparator = ((char)0x2029).ToString();\\n\\n        return sIn.Replace(\\\"\\\\r\\\\n\\\", string.Empty).Replace(\\\"\\\\n\\\", string.Empty).Replace(\\\"\\\\r\\\", string.Empty).Replace(\\\"\\\\f\\\", string.Empty).Replace(lineSeparator, string.Empty).Replace(paragraphSeparator, string.Empty);\\n    }\\n\\n\\n    //============================ Math Functions ============================\\n\\n    static public float RoundToPlaces(float f, int places=2) {\\n        float mult = Mathf.Pow(10,places);\\n        f *= mult;\\n        f = Mathf.Round (f);\\n        f /= mult;\\n        return(f);\\n    }\\n\\n    static public string AddCommasToNumber(float f, int places=2) {\\n        int n = Mathf.RoundToInt(f);\\n        f -= n;\\n        f = RoundToPlaces(f,places);\\n        string str = AddCommasToNumber( n );\\n        str += \\\".\\\"+(f*Mathf.Pow(10,places));\\n        return( str );\\n    }\\n    static public string AddCommasToNumber(int n) {\\n        int rem;\\n        int div;\\n        string res = \\\"\\\";\\n        string rems;\\n        while (n>0) {\\n            rem = n % 1000;\\n            div = n / 1000;\\n            rems = rem.ToString();\\n\\n            while (div>0 && rems.Length<3) {\\n                rems = \\\"0\\\"+rems;\\n            }\\n            // TODO: I think there must be a faster way to concatenate strings. Maybe I could do this with an array or something\\n            if (res == \\\"\\\") {\\n                res = rems;\\n            } else {\\n                res = rems + \\\",\\\" + res.ToString();\\n            }\\n            n = div;\\n        }\\n        if (res == \\\"\\\") res = \\\"0\\\";\\n        return( res );\\n    }\\n\\n\\n\\n\\n}\\n\\n\\n//============================ Easing Classes ============================\\n[System.Serializable]\\npublic class EasingCachedCurve {\\n    public List<string>     curves =    new List<string>();\\n    public List<float>      mods =      new List<float>();\\n}\\n\\npublic class Easing {\\n    static public string Linear =       \\\",Linear|\\\";\\n    static public string In =           \\\",In|\\\";\\n    static public string Out =          \\\",Out|\\\";\\n    static public string InOut =        \\\",InOut|\\\";\\n    static public string Sin =          \\\",Sin|\\\";\\n    static public string SinIn =        \\\",SinIn|\\\";\\n    static public string SinOut =       \\\",SinOut|\\\";\\n\\n    static public Dictionary<string,EasingCachedCurve> cache;\\n    // This is a cache for the information contained in the complex strings\\n    //   that can be passed into the Ease function. The parsing of these\\n    //   strings is most of the effort of the Ease function, so each time one\\n    //   is parsed, the result is stored in the cache to be recalled much \\n    //   faster than a parse would take.\\n    // Need to be careful of memory leaks, which could be a problem if several\\n    //   million unique easing parameters are called\\n\\n    static public float Ease( float u, params string[] curveParams ) {\\n        // Set up the cache for curves\\n        if (cache == null) {\\n            cache = new Dictionary<string, EasingCachedCurve>();\\n        }\\n\\n        float u2 = u;\\n        foreach ( string curve in curveParams ) {\\n            // Check to see if this curve is already cached\\n            if (!cache.ContainsKey(curve)) {\\n                // If not, parse and cache it\\n                EaseParse(curve);\\n            } \\n            // Call the cached curve\\n            u2 = EaseP( u2, cache[curve] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private void EaseParse( string curveIn ) {\\n        EasingCachedCurve ecc = new EasingCachedCurve();\\n        // It\'s possible to pass in several comma-separated curves\\n        string[] curves = curveIn.Split(\',\');\\n        foreach (string curve in curves) {\\n            if (curve == \\\"\\\") continue;\\n            // Split each curve on | to find curve and mod\\n            string[] curveA = curve.Split(\'|\');\\n            ecc.curves.Add(curveA[0]);\\n            if (curveA.Length == 1 || curveA[1] == \\\"\\\") {\\n                ecc.mods.Add(float.NaN);\\n            } else {\\n                float parseRes;\\n                if ( float.TryParse(curveA[1], out parseRes) ) {\\n                    ecc.mods.Add( parseRes );\\n                } else {\\n                    ecc.mods.Add( float.NaN );\\n                }\\n            }   \\n        }\\n        cache.Add(curveIn, ecc);\\n    }\\n    \\n    \\n    static public float Ease( float u, string curve, float mod ) {\\n        return( EaseP( u, curve, mod ) );\\n    }\\n    \\n    static private float EaseP( float u, EasingCachedCurve ec ) {\\n        float u2 = u;\\n        for (int i=0; i<ec.curves.Count; i++) {\\n            u2 = EaseP( u2, ec.curves[i], ec.mods[i] );\\n        }\\n        return( u2 );\\n    }\\n    \\n    static private float EaseP( float u, string curve, float mod ) {\\n        float u2 = u;\\n        \\n        switch (curve) {\\n            case \\\"In\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = Mathf.Pow(u, mod);\\n                break;\\n                \\n            case \\\"Out\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                u2 = 1 - Mathf.Pow( 1-u, mod );\\n                break;\\n                \\n            case \\\"InOut\\\":\\n                if (float.IsNaN(mod)) mod = 2;\\n                if ( u <= 0.5f ) {\\n                    u2 = 0.5f * Mathf.Pow( u*2, mod );\\n                } else {\\n                    u2 = 0.5f + 0.5f * (  1 - Mathf.Pow( 1-(2*(u-0.5f)), mod )  );\\n                }\\n                break;\\n                \\n            case \\\"Sin\\\":\\n                if (float.IsNaN(mod)) mod = 0.15f;\\n                u2 = u + mod * Mathf.Sin( 2*Mathf.PI*u );\\n                break;\\n                \\n            case \\\"SinIn\\\":\\n                // mod is ignored for SinIn\\n                u2 = 1 - Mathf.Cos( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"SinOut\\\":\\n                // mod is ignored for SinOut\\n                u2 = Mathf.Sin( u * Mathf.PI * 0.5f );\\n                break;\\n                \\n            case \\\"Linear\\\":\\n            default:\\n                // u2 already equals u\\n                break;\\n        }\\n        \\n        return( u2 );\\n    }\\n\\n\\n}\\n\"}}, \"Mission Demolition\": {\"Coding the Prototype\": {\"Scripts/Cloud.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Cloud : MonoBehaviour\\n{\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject cloudSphere;\\n    public int numSpheresMin = 6;\\n    public int numSpheresMax = 10;\\n    public Vector3 sphereOffsetScale = new Vector3(5, 2, 1);\\n    public Vector2 sphereScaleRangeX = new Vector2(4, 8);\\n    public Vector2 sphereScaleRangeY = new Vector2(3, 4);\\n\\n\\n    public Vector2 sphereScaleRangeZ = new Vector2(2, 4);\\n    public float scaleYMin = 2f;\\n    private List<GameObject> spheres;\\n    void Start()\\n    {\\n        spheres = new List<GameObject>();\\n        int num = Random.Range(numSpheresMin, numSpheresMax);\\n        for (int i = 0; i < num; i++)\\n        {\\n            GameObject sp = Instantiate<GameObject>(cloudSphere);\\n            spheres.Add(sp);\\n            Transform spTrans = sp.transform;\\n            spTrans.SetParent(this.transform);\\n\\n            Vector3 offset = Random.insideUnitSphere;\\n            offset.x *= sphereOffsetScale.x;\\n            offset.y *= sphereOffsetScale.y;\\n            offset.z *= sphereOffsetScale.z;\\n            spTrans.localPosition = offset;\\n\\n            Vector3 scale = Vector3.one;\\n            scale.x = Random.Range(sphereScaleRangeX.x, sphereScaleRangeX.y);\\n            scale.y = Random.Range(sphereScaleRangeY.x, sphereScaleRangeY.y);\\n            scale.z = Random.Range(sphereScaleRangeZ.x, sphereScaleRangeZ.y);\\n\\n            scale.y *= 1 - (Mathf.Abs(offset.x) / sphereOffsetScale.x);\\n            scale.y = Mathf.Max(scale.y, scaleYMin);\\n            spTrans.localScale = scale;\\n        }\\n    }\\n\\n    void Update()\\n    {\\n        // if (Input.GetKeyDown(KeyCode.Space))\\n        // {\\n        //     Restart();\\n        // }\\n    }\\n    void Restart()\\n    {\\n        foreach (GameObject sp in spheres)\\n        {\\n            Destroy(sp);\\n        }\\n\\n        Start();\\n    }\\n}\\n\", \"Scripts/CloudCrafter.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class CloudCrafter : MonoBehaviour\\n{\\n    [Header(\\\"Set in Inspector\\\")]\\n    public int numClouds = 40;\\n    public GameObject cloudPrefab;\\n    public Vector3 cloudPosMin = new Vector3(-50, -5, 10);\\n    public Vector3 cloudPosMax = new Vector3(150, 100, 10);\\n    public float cloudScaleMin = 1;\\n    public float cloudScaleMax = 3;\\n    public float cloudSpeedMult = 0.5f;\\n    private GameObject[] cloudInstances;\\n    void Awake()\\n    {\\n        cloudInstances = new GameObject[numClouds];\\n        GameObject anchor = GameObject.Find(\\\"CloudAnchor\\\");\\n        GameObject cloud;\\n        for (int i = 0; i < numClouds; i++)\\n        {\\n            cloud = Instantiate<GameObject>(cloudPrefab);\\n            Vector3 cPos = Vector3.zero;\\n            cPos.x = Random.Range(cloudPosMin.x, cloudPosMax.x);\\n            cPos.y = Random.Range(cloudPosMin.y, cloudPosMax.y);\\n            float scaleU = Random.value;\\n            float scaleVal = Mathf.Lerp(cloudScaleMin, cloudScaleMax, scaleU);\\n            cPos.y = Mathf.Lerp(cloudPosMin.y, cPos.y, scaleU);\\n            cPos.z = 100 - 90 * scaleU;\\n            cloud.transform.position = cPos;\\n            cloud.transform.localScale = Vector3.one * scaleVal;\\n            cloud.transform.SetParent(anchor.transform);\\n            cloudInstances[i] = cloud;\\n        }\\n    }\\n\\n    void Update()\\n    {\\n        foreach (GameObject cloud in cloudInstances)\\n        {\\n            float scaleVal = cloud.transform.localScale.x;\\n            Vector3 cPos = cloud.transform.position;\\n            cPos.x -= scaleVal * Time.deltaTime * cloudSpeedMult;\\n            if (cPos.x <= cloudPosMin.x)\\n            {\\n                cPos.x = cloudPosMax.x;\\n            }\\n            cloud.transform.position = cPos;\\n        }\\n    }\\n}\", \"Scripts/FollowCam.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class FollowCam : MonoBehaviour\\n{\\n    static public GameObject POI;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float easing = 0.05f;\\n    public Vector2 minXY = Vector2.zero;\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public float camZ;\\n\\n    void Awake()\\n    {\\n        camZ = this.transform.position.z;\\n    }\\n\\n    void FixedUpdate()\\n    {\\n        Vector3 destination;\\n        // If there is no poi, return to P:[ 0, 0, 0 ]\\n        if (POI == null)\\n        {\\n            destination = Vector3.zero;\\n        }\\n        else\\n        {\\n            // Get the position of the poi\\n            destination = POI.transform.position;\\n            // If poi is a Projectile, check to see if it\'s at rest\\n            if (POI.tag == \\\"Projectile\\\")\\n            {\\n                // if it is sleeping (that is, not moving)\\n                if (POI.GetComponent<Rigidbody>().IsSleeping())\\n                {\\n                    // return to default view\\n                    POI = null;\\n                    // in the next update\\n                    return;\\n                }\\n            }\\n        }\\n\\n        destination.x = Mathf.Max(minXY.x, destination.x);\\n        destination.y = Mathf.Max(minXY.y, destination.y);\\n        destination = Vector3.Lerp(transform.position, destination, easing);\\n        destination.z = camZ;\\n        transform.position = destination;\\n        Camera.main.orthographicSize = destination.y + 10;\\n    }\\n}\\n\", \"Scripts/Goal.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class Goal : MonoBehaviour\\n{\\n    static public bool goalMet = false;\\n    void OnTriggerEnter(Collider other)\\n    {\\n        if (other.gameObject.tag == \\\"Projectile\\\")\\n        {\\n            Goal.goalMet = true;\\n\\n            Material mat = GetComponent<Renderer>().material;\\n            Color c = mat.color;\\n            c.a = 1;\\n            mat.color = c;\\n        }\\n    }\\n}\", \"Scripts/MissionDemolition.cs\": \"using UnityEngine;\\nusing System.Collections;\\nusing UnityEngine.UI;\\npublic enum GameMode\\n{\\n    idle,\\n    playing,\\n    levelEnd\\n}\\npublic class MissionDemolition : MonoBehaviour\\n{\\n    static private MissionDemolition S;\\n    [Header(\\\"Set in Inspector\\\")]\\n    public Text uitLevel;\\n    public Text uitShots;\\n    public Text uitButton;\\n    public Vector3 castlePos;\\n    public GameObject[] castles;\\n    [Header(\\\"Set Dynamically\\\")]\\n    public int level;\\n    public int levelMax;\\n    public int shotsTaken;\\n    public GameObject castle;\\n    public GameMode mode = GameMode.idle;\\n    public string showing = \\\"Show Slingshot\\\";\\n\\n    void Start()\\n    {\\n        S = this;\\n        level = 0;\\n        levelMax = castles.Length;\\n        StartLevel();\\n    }\\n    void StartLevel()\\n    {\\n        if (castle != null)\\n        {\\n            Destroy(castle);\\n        }\\n\\n        GameObject[] gos = GameObject.FindGameObjectsWithTag(\\\"Projectile\\\");\\n        foreach (GameObject pTemp in gos)\\n        {\\n            Destroy(pTemp);\\n        }\\n\\n        castle = Instantiate<GameObject>(castles[level]);\\n        castle.transform.position = castlePos;\\n        shotsTaken = 0;\\n\\n        SwitchView(\\\"Show Both\\\");\\n        ProjectileLine.S.Clear();\\n\\n        Goal.goalMet = false;\\n        UpdateGUI();\\n        mode = GameMode.playing;\\n    }\\n    void UpdateGUI()\\n    {\\n        uitLevel.text = \\\"Level: \\\" + (level + 1) + \\\" of \\\" + levelMax;\\n        uitShots.text = \\\"Shots Taken: \\\" + shotsTaken;\\n    }\\n\\n    void Update()\\n    {\\n        UpdateGUI();\\n        if ((mode == GameMode.playing) && Goal.goalMet)\\n        {\\n            mode = GameMode.levelEnd;\\n\\n            SwitchView(\\\"Show Both\\\");\\n\\n            Invoke(\\\"NextLevel\\\", 2f);\\n        }\\n    }\\n    void NextLevel()\\n    {\\n        level++;\\n        if (level == levelMax)\\n        {\\n            level = 0;\\n        }\\n        StartLevel();\\n    }\\n    public void SwitchView(string eView = \\\"\\\")\\n    {\\n        if (eView == \\\"\\\")\\n        {\\n            eView = uitButton.text;\\n        }\\n        showing = eView;\\n        switch (showing)\\n        {\\n            case \\\"Show Slingshot\\\":\\n                FollowCam.POI = null;\\n                uitButton.text = \\\"Show Castle\\\";\\n                break;\\n            case \\\"Show Castle\\\":\\n                FollowCam.POI = S.castle;\\n                uitButton.text = \\\"Show Both\\\";\\n                break;\\n            case \\\"Show Both\\\":\\n                FollowCam.POI = GameObject.Find(\\\"ViewBoth\\\");\\n                uitButton.text = \\\"Show Slingshot\\\";\\n                break;\\n        }\\n    }\\n\\n    public static void ShotFired()\\n    {\\n        S.shotsTaken++;\\n    }\\n}\", \"Scripts/ProjectileLine.cs\": \"using System.Collections;\\nusing System.Collections.Generic;\\nusing UnityEngine;\\n\\npublic class ProjectileLine : MonoBehaviour\\n{\\n    static public ProjectileLine S;\\n    [Header(\\\"Set in Inspector\\\")]\\n    public float minDist = 0.1f;\\n    private LineRenderer line;\\n    private GameObject _poi;\\n    private List<Vector3> points;\\n    void Awake()\\n    {\\n        S = this;\\n        line = GetComponent<LineRenderer>();\\n        line.enabled = false;\\n        points = new List<Vector3>();\\n    }\\n    public GameObject poi\\n    {\\n        get\\n        {\\n            return (_poi);\\n        }\\n        set\\n        {\\n            _poi = value;\\n            if (_poi != null)\\n            {\\n                line.enabled = false;\\n                points = new List<Vector3>();\\n                AddPoint();\\n            }\\n        }\\n    }\\n    public void Clear()\\n    {\\n        _poi = null;\\n        line.enabled = false;\\n        points = new List<Vector3>();\\n    }\\n\\n    public void AddPoint()\\n    {\\n        Vector3 pt = _poi.transform.position;\\n        if (points.Count > 0 && (pt - lastPoint).magnitude < minDist)\\n        {\\n\\n            return;\\n        }\\n        if (points.Count == 0)\\n        {\\n            Vector3 launchPosDiff = pt - Slingshot.LAUNCH_POS;\\n\\n            points.Add(pt + launchPosDiff);\\n            points.Add(pt);\\n            line.positionCount = 2;\\n            line.SetPosition(0, points[0]);\\n            line.SetPosition(1, points[1]);\\n            line.enabled = true;\\n        }\\n        else\\n        {\\n            points.Add(pt);\\n            line.positionCount = points.Count;\\n            line.SetPosition(points.Count - 1, lastPoint);\\n            line.enabled = true;\\n        }\\n    }\\n    public Vector3 lastPoint\\n    {\\n        get\\n        {\\n            if (points == null)\\n            {\\n                return (Vector3.zero);\\n            }\\n            return (points[points.Count - 1]);\\n        }\\n    }\\n    void FixedUpdate()\\n    {\\n        if (poi == null)\\n        {\\n            if (FollowCam.POI != null)\\n            {\\n                if (FollowCam.POI.tag == \\\"Projectile\\\")\\n                {\\n                    poi = FollowCam.POI;\\n                }\\n                else\\n                {\\n                    return;\\n                }\\n            }\\n            else\\n            {\\n                return;\\n            }\\n        }\\n        AddPoint();\\n        if (FollowCam.POI == null)\\n        {\\n            poi = null;\\n        }\\n    }\\n}\", \"Scripts/RigidbodySleep.cs\": \"using UnityEngine;\\npublic class RigidbodySleep : MonoBehaviour\\n{\\n    void Start()\\n    {\\n        Rigidbody rb = GetComponent<Rigidbody>();\\n        if (rb != null) rb.Sleep();\\n    }\\n}\", \"Scripts/Slingshot.cs\": \"using UnityEngine;\\nusing System.Collections;\\n\\npublic class Slingshot : MonoBehaviour\\n{\\n    static private Slingshot S;\\n\\n    [Header(\\\"Set in Inspector\\\")]\\n    public GameObject prefabProjectile;\\n    public float velocityMult = 8f;\\n\\n\\n    [Header(\\\"Set Dynamically\\\")]\\n    public GameObject launchPoint;\\n    public Vector3 launchPos;\\n    public GameObject projectile;\\n    public bool aimingMode;\\n    private Rigidbody projectileRigidbody;\\n\\n    static public Vector3 LAUNCH_POS\\n    {\\n        get\\n        {\\n            if (S == null) return Vector3.zero;\\n            return S.launchPos;\\n        }\\n    }\\n\\n    void Awake()\\n    {\\n        S = this;\\n        Transform launchPointTrans = transform.Find(\\\"LaunchPoint\\\");\\n        launchPoint = launchPointTrans.gameObject;\\n        launchPoint.SetActive(false);\\n        launchPos = launchPointTrans.position;\\n    }\\n    void OnMouseEnter()\\n    {\\n        launchPoint.SetActive(true);\\n    }\\n    void OnMouseExit()\\n    {\\n        launchPoint.SetActive(false);\\n    }\\n\\n    void OnMouseDown()\\n    {\\n        aimingMode = true;\\n        projectile = Instantiate(prefabProjectile) as GameObject;\\n        projectile.transform.position = launchPos;\\n        projectileRigidbody = projectile.GetComponent<Rigidbody>();\\n        projectileRigidbody.isKinematic = true;\\n    }\\n\\n\\n\\n    void Update()\\n    {\\n        if (!aimingMode) return;\\n        Vector3 mousePos2D = Input.mousePosition;\\n        mousePos2D.z = -Camera.main.transform.position.z;\\n        Vector3 mousePos3D = Camera.main.ScreenToWorldPoint(mousePos2D);\\n        Vector3 mouseDelta = mousePos3D - launchPos;\\n        float maxMagnitude = this.GetComponent<SphereCollider>().radius;\\n        if (mouseDelta.magnitude > maxMagnitude)\\n        {\\n            mouseDelta.Normalize();\\n            mouseDelta *= maxMagnitude;\\n        }\\n\\n        Vector3 projPos = launchPos + mouseDelta;\\n        projectile.transform.position = projPos;\\n        if (Input.GetMouseButtonUp(0))\\n        {\\n            aimingMode = false;\\n            projectileRigidbody.isKinematic = false;\\n            projectileRigidbody.velocity = -mouseDelta * velocityMult;\\n            FollowCam.POI = projectile;\\n            MissionDemolition.ShotFired();\\n            ProjectileLine.S.poi = projectile;\\n            projectile = null;\\n        }\\n    }\\n}\"}}}}"
# PYEND
  end

  def getContents() do
    Jason.decode!(rawContents())
  end
end
